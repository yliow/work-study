%-*-latex-*-
\sectionthree{Queue}
\begin{python0}
from solutions import *; clear()
\end{python0}

A queue (see CISS240/245) is an ADT where you can put things into the container
and you can take things out of it.
The operation of putting a value into a queue is called enqueue
and the operation of taking a value out of a queue is called dequeue.
Like the stack, it's self-organizing: you don't have to tell the
queue where to put a value and you don't have to tell the queue
which one to remove.

Suppose this is a queue:

\input{stdout25.tex}

A queue has a front and a back.
Let's say for the above diagram the value 1 is the front and the 3 is the back.
If I enqueue with 7, the queue becomes:

\input{stdout26.tex}

If I dequeue, the 1 is removed (frequently returned) and the queue
becomes

\input{stdout27.tex}

Note that the value removed is the value that was in the queue the
longest.
So we say that a queue is a
\defterm{first-in-first-out}\tinysidebar{first-in-first-out\\ FIFO}\index{first-in-first-out},
\defterm{FIFO}\index{FIFO},
data structure.

You see queues everywhere:
a network router processes messages that are stored in a queue.
A webserver processes requests that are stored in a queue.
The OS running your laptop will run processes that are stored in a queue.
I/O requests are also stored in queues.
Etc.

Note that since you have to operate a queue on both ends,
you should use a doubly linked list and not a singly linked list.
(An array implementation is possible if the maximum length of the
queue is small and fixed.)

Frequently, jobs entering a queue has a priority number
that allows the job to jump ahead.
For instance the following is a queue of jobs and the
numbers are the priority numbers where low means high priority:

\input{stdout28.tex}

So if I enqueue 5, the 5 will enter the queue at the end
but will jump ahead of the job with priority 7,
jump ovrer the jobn with priority 6, but will not jump ahead of the
job with priorityt 5 that was already there:

\input{stdout29.tex}

Such things are called priority queues.
We'll come back to this later when we look at heaps.


\begin{ex}
  \begin{tightlist}
    \li If you use an array to implement a queue, what is the
    runtime of enqueue and dequeue?
    \li If you use a singly linked list to implement a queue, what is the
    runtime of enqueue nad dequeue? (Remember that in this case
    you have to say where is the front and where is the end of the queue
    with respect to the list.)
    \li If you use a doubly linked list to implement queue, what is the
    runtime of enqueue nad dequeue? 
  \end{tightlist}
  \qed
\end{ex}

\begin{ex}
  \begin{tightlist}
    \li If you use an array to implement a priority queue, what is the
    runtime of enqueue and dequeue?
    \li If you use a singly linked list to implement a priority
    queue, what is the
    runtime of enqueue nad dequeue? (Remember that in this case
    you have to say where is the front and where is the end of the queue
    with respect to the list.)
    \li If you use a doubly linked list to implement a priority
    queue, what is the
    runtime of enqueue nad dequeue? 
  \end{tightlist}
  \qed
\end{ex}
