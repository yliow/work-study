%-*-latex-*-
\sectionthree{ADT: Abstract data type}
\begin{python0}
from solutions import *; clear()
\end{python0}

An \defone{abstract data type} (ADT) is just a fancy name for a type.
The description of the type includes a description of the operations on
objects/values of that type without actually describing the implementation.

Think about a battery.
If I say I have an \lq\lq AAA" battery, then I'm saying the battery has
a certain standard size and 
you can use the battery in a device that
expects an AAA battery.
The type \lq\lq AAA" does not tell you the chemicals are used in that
battery, i.e., \lq\lq AAA" does not specify the \lq\lq implementation"
of this battery.
(But if I tell you the brand and the model of this AAA battery, then
that would reveal the implementation.)

An example of an ADT is the stack.
The stack ADT is a type for containers with
mainly two operations:
\begin{tightlist}
  \li \verb!push!: for putting a value into the stack
  \li \verb!pop!: for removing a value from the stack
\end{tightlist}
Therefore other auxiliary operations such as
\verb!is_empty!
that tells you if the stack is empty or not.
The \verb!push! and \verb!pop! works this way:
If the stack is not empty, pop will remove from the stack
the value that was
last pushed onto the stack.
The stack is an example of a
\index{self-organizing container}\defterm{self-organizing container}\tinysidebar{self-organizing container}
because you
don't tell the stack where to put the value that is inserted into the stack.
You can (and should) think of a stack as a stack of plates at a buffet:
the plate you take from the stack of plates is the plate on top of the stack
which is the last plate placed on top of the stack.
The value that is popped from the stack is called the
\defterm{top}\tinysidebar{top}\index{top}
of the stack.
This is the reason why the stack is also called a
\defterm{LIFO}\tinysidebar{LIFO\\last-in-first-out\\data structure}\index{LIFO},
\defterm{last-in-first-out}\index{LIFO},
data structure.
Here, a
\index{data structure}\defterm{data structure}
refers to a container of values with a particular
organizational behavior.

In terms of implementation, you can for instance use an array with a size
variable (or \verb!std::vector!)
where the top of the stack is the value at the last index position.
Based on this implementation you can then talk about the runtimes of the
push and pop operation.

Another implementation is if you again use an array with a size variable
(or vector), but the top of the stack correspond to the value at index 0.
This stack implementation would have a different runtime from the one
above.

