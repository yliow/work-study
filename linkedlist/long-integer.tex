%-*-latex-*-
\sectionthree{Long integer}
\begin{python0}
from solutions import *; clear()
\end{python0}

Recall (see CISS245) that you can model a long integer (some people
call it a big integer) with an array (or vector) of integers
where each integer in the array is a digit in the integer being modeled.
(Of course instead of storing a single digit in one cell of the array/vector
of integers, you can store for instance 9 digits.)
Is this the best container to use?

Look at the addition algorithm for integers.
You can really traversing the digits of two long integers
starting from the lowest order digit to the highest.
The resulting long integer is also filled in the first direction.
This is the same for addition.

What about multiplication?
If you do 2 or 3 multicolumn multiplication of integers,
you'll see that you also traverse the digits from the
lowest order digit to the highest.

Division?
The standard method for division is long division.
If you do 2 or 3 long divisions, you'll see that
you actually have to look at the highest order digit first.

Aha!

This means that the right data structure to use is
the doubly linked list.
Note that in this case, the digits are stored in the
linked list.
There's no key.

(In serious number crunching, \texttt{std::vector} \textit{is} used
because for those applications -- which includes breaking codes --
speed is essesntial.
For that kind of work, after a good algorithm is found,
say a $O(n)$ and a $O(n^2)$ algorithm are found and the
$O(n)$ is chosen, they still care about whether the
algorithm is roughly $10n$ or $12n$.)


\begin{ex}
Implement a \verb!LongInt! class using doubly linked list.
\qed
\end{ex}

\begin{ex}
Implement a \verb!Polynomial! class using doubly linked list.
\qed
\end{ex}

\begin{ex}
A matrix is a rectangular array of values.
Viewing each row as a singly linked list, implement
a matrix class.
Note again that matrices are used a lot in number crunching
cryptographic and scientific applications.
In those cases speed might be more important than saving
memory.
However some matrices in scientific applications
are so huge that they have to be broken up
not because of lack of memory (or memory fragmentation)
but because the system does not support such a huge chunk of
contiguous memory.
Another reason for breaking it up is to allow better
parallel computation.
However mstrices are usual broken up into blocks and not
rows.
Furthermore matrices are frequently processed column-wise
as well as row-wise.
\qed
\end{ex}
  
