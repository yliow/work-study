%-*-latex-*-
\sectionthree{More exercises}
\begin{python0}
from solutions import *; clear()
\end{python0}

\begin{ex}
I'm going to make some changes to the doubly linked list.
Here's a doubly linked list (without sentinel nodes):

\input{stdout41.tex}

The usual delete tail will result in this:

\input{stdout42.tex}

Write a doubly linked list class that does this instead:

\input{stdout43.tex}

When I insert 8 as tail, I don't have to allocate memory. I just use the node
with 5, but I replace the 5 with 8:

\input{stdout44.tex}

In other words, we delay the deallocation of head and tail nodes.
We can think of the used but not deallocated nodes as extra nodes
waiting to be reused.
When we do want to release the memory, we call the
\verb!shrink_to_fit()!.
Likewise, the same tbing happens at the end.

Next, add sentinel nodes:

\input{stdout45.tex}

Note that I'm renaming \texttt{phead} to 
\texttt{pheadsentinel}
and
\texttt{ptail}
to
\texttt{ptailsentinel}
(The \texttt{?} denotes integer values we don't care about.)
And if I delete the tail, the above becomes

\input{stdout46.tex}

At this point, the size of the linked list is (of course) 3
and the capacity is 4.

Of course the linked list starts off as an empty list
that looks like this (there are two sentinel nodes)

\input{stdout47.tex}

Objects of this type of linked list have
\texttt{size()} and \texttt{capacity()}
that returns the obvious integer values.
For instance for this case:

\input{stdout48.tex}

the size is 3 and the capacity is 4.

Implement this type of linked list.
\qed
\end{ex}


\begin{ex}
Write this function
\begin{Verbatim}[frame=single]
template < typename T >
void mergesort(std::list< T > & x);
\end{Verbatim}
that performs mergesort on linked lists.
\qed
\end{ex}

\begin{ex}
Write a sorted doubly linked list class.
\qed
\end{ex}


\begin{ex}
  skip list
\end{ex}

\begin{ex}
[Random maze generation]
The goal is to generate a maze in a 2D grid.
Suppose you have the following 4x4 grid:
\begin{console}
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
\end{console}
You can think of the above as a grid of 4-by-4 rooms.
Initially think of each room as completely sealed with walls.
You can think of building a maze as punching a hole in the wall.
For instance here's a hole, from (0,0) to (0,1):
\begin{console}
+-+-+-+-+
|  x| | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
\end{console}
I'm using \texttt{x} to match where I am in the grid.
And now I punch another hole from (0,1) to (1,1):
\begin{console}
+-+-+-+-+
|   | | |
+-+ +-+-+
| |x| | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
\end{console}
Now if I punch (1,1) to (1,2) to (1,3) to (0,3) to (0,2) I get this:
\begin{console}
+-+-+-+-+
|   |x  |
+-+ +-+ +
| |     |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
\end{console}
At this point, I'm stuck -- see the \texttt{x} in the incomplete maze.
I'm stuck in the sense that I can only punch two walls but each will
go into a room that is already visited. Again see the diagram above.
What I need to do is to go backwards.
Going one step back, I get to this point:
\begin{console}
+-+-+-+-+
|   |  x|
+-+ +-+ +
| |     |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
\end{console}
But I'm still stuck: I don't any walls to punch (you have to stay in
the grid so you cannot punch the perimeter wall).
Butif I cgo one more step back I arrive at this point:
\begin{console}
+-+-+-+-+
|   |   |
+-+ +-+ +
| |    x|
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
\end{console}
At this point I can go from (1,3) to (2,3):
\begin{console}
+-+-+-+-+
|   |   |
+-+ +-+ +
| |     |
+-+-+-+ +
| | | |x|
+-+-+-+-+
| | | | |
+-+-+-+-+
\end{console}
To be able to build the maze I will need the following idea.
Make sure you study and think about it and make
changes/corrections/modification when necessary.
\begin{console}
ALGORITHM: build_maze
INPUT: (r,c) - the starting point

let UNVISITED be the container of unvisited cells:
    initially this should be all cells except for (r,c)
let PATH be the container containing only (r,c)
let VISITED be a container containing only (r,c)
let PUNCHED be an empty container of "(r0,c0) -- (r1,c1)"
    that represents punched walls

while PATH is not empty:
    look at the last step stored in PATH -- call it x
    look at all the surrounding cells around x
    the available cells to go to are the
        cells to the north, south, east, west of x
        which are within the grid and not visited yet,
        i.e., in UNVISITED.
    if there is at least one available cell:
        randomly choose one available cell -- call it y
        store y in VISITED and add that to PATH
        remove y from UNVISITED
        store x--y (the punched wall) in PUNCHED
    else:
        there are are no available cells
        we have to go backwards -- remove x from PATH 
\end{console}
Note that the \texttt{PATH} is a stack
(this should be clear from the way I describe how I use
\texttt{PATH}).
(Do I need both  \texttt{VISITED}.
and \texttt{UNVISITED}?)

Note that you can view the maze as a graph.
The nodes are of the form $(r,c)$.
An edge joins \texttt{(r0,c0)} to
\texttt{(r1,c1)} is the same as you can go from
room \texttt{(r0,c0)} to \texttt{(r1,c1)}.
The maze can be described by a vector of \texttt{PunchedWall}. 
Call the function
\begin{console}
class Cell
{
public:
    int r, c;
};

class PunchedWall
{
public:
    Cell c0, c1;
};
  
// Return an adjacency list describing the maze
// The maze is n-by-n and (r,c) is the starting point of the
// maze.
std::vector< PunchedWall > build_maze(int n,
                                      int r, int c);

void print_maze( int n, const std::vector<PunchedWall> & v)
\end{console}
The \verb!print_maze! will print a maze in the following manner:
\begin{console}
+-+-+-+-+
|   |   |
+-+ +-+ +
| |     |
+ +-+-+ +
|     | |
+-+ +-+ +
|       |
+-+-+-+-+
\end{console}
\end{ex}

Here's the (obvious) main():
\begin{console}
int main()
{
    int n, r, c;
    std::cin >> n >> r >> c;

    punched_walls = build_maze(int n, int r, int c);
    print_maze(n, punched_walls);

    return 0;
}
\end{console}
