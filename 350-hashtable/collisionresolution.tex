\sectionthree{Collision Resolution}

One thing I can do is to just go onto the \textit{next} index value.
Don't forget that the index values are from 0 to 9.
So if I hash to \verb!9! and there's someone at \verb!9!,
and I compute the \textit{next} index value to get \verb!10!,
I'm outside the array.
In other words, I need to mod by 10 (the size of the array).

Computation of new hash values in case of a collision is
sometimes called \defone{probing}.
There are many different methods for probing.
The \lq\lq \textit{go to next one with mod}''
is called \defone{linear probing}.

Going back to our example, if I use linear probing, since
\verb!Annie! is hashed to \verb!5!, the row occupied by \verb!Abe!,
I will put \verb!Annie! at index \verb!6!.

\input{stdout07.tex}

One step up is \textbf{quadratic probes}.
Suppose you hash to value $h$.
If there's a collision, you look at $h + 1^2$.
If there's another collision, you look at $h + 2^2$.
If there's again another collision, you look at $h + 3^2$.
Etc.
That's it.
More generally, instead of using $x^2$, you can 
use $ax^2 + bx + c$.
For instance, say whenever you have a hash collision,
you use
the quadratic probe with $a = 1$, $b = 1$, $c = 0$.
If you have a collision with value $h$, then
the next value to try is 
$h + 1^2 + 1^1$.
If that's again a collision, you look at 
$h + 2^2 + 2^1$.
And if this is again a collision, you look at
$h + 3^2 + 3^1$.
Etc.{double hashing}.
Here's how it works.
You need two hash functions.
Let's say I call them $h$ and $h'$.
Suppose your key if $k$.
The first hash value you look at is $h(k)$.
If there's a collision, you look at 
$h(k) + h'(k)$.
If there's another colliion, you look at
$h(k) + 2h'(k)$.
If there's yet another collision, you look at
$h(k) + 3h'(k)$.
Etc.

\input{exercises/hastable0/main.tex}

\input{exercises/hastable1/main.tex}

\input{exercises/hastable2/main.tex}

\input{exercises/hastable3/main.tex}

\input{exercises/hastable4/main.tex}




\newpage
