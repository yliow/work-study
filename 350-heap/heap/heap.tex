%-*-latex-*-
\sectionthree{Binary heaps}
\begin{python0}
from solutions import *; clear()
\end{python0}

Look at this tree:

\input{stdout06.tex}

No is not a BST.
But the numbers are not totally random:
each node has value $\geq$ all
the children.
This is called a \defone{maxheap}.

Not too surprising, this is called \defone{minheap}:

\input{stdout07.tex}

Each node has value $\leq$ all children.

Note that I have only defined max- and minheaps for \textit{binary} 
trees.
There are also called \defone{binary heaps}.
It's not too difficult to see that you can
generalize these to
\defone{$k$--ary minheaps}
or
\defone{$k$--ary maxheaps}.

More generally you can define heaps with respect to an ordering relation.
In the above the ordering is $\geq$ (for maxheap)
and $\leq$ (for minheap).

Let me formalize the definitions for max- and minheap:

A tree satisfies the \defone{maxheap property}
if every node in the tree is greater than or equal to the children.
A \defone{maxheap} is a tree that satisfies the maxheap property.
A $k$--ary tree satisfies the \defone{minheap property}
if every node in the tree is less than or equal  to the children.
A \defone{minheap} is a tree that satisfies the maxheap property.

Although most of what we'll talk about regarding heaps works
for all binary max/minheaps, we are usually only interested in
complete heaps, i.e., all the levels are full except possibly for the last.
This will ensure that the height is $O(\log n)$.
Furthermore, the places where the level is not filled (if any)
is \lq\lq on the
right''.
For instance instead of a maxheap like this:


\input{stdout08.tex}

we will usually consider this instead:

\input{stdout09.tex}

This will ensure that when this heap is implemented
using an array, the values occupied are contiguous.

\input{stdout10.tex}

Cells which are not relevant are left blank.
Of course there are integer values there --
but we don't care about them.
Furthermore, this array would usually come with a
size or length variable (in the above example size would have value
\texttt{6}) which is the case if I use
\verb!std::vector!.
The size variable would tell me the index position of
the first available cell in the array

\input{stdout11.tex}

which would correspond nicely with the
next available node in the tree to keep the tree
in the \lq\lq heap shape'',
i.e., complete and unfilled nodes on a level
(if any) on the right:

\input{stdout12.tex}

From now on, I will assume that a max- or minheap
look like that,
i.e., is complete where the unfilled slots (if any)
are all on the same level
and all \lq\lq on the right''.

\input{exercises/heap-0/main.tex}

\input{exercises/heap-1/main.tex}

\input{exercises/heap-2/main.tex}
