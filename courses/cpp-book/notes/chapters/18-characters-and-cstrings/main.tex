% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\ifLuaTeX
  \usepackage{luacolor}
  \usepackage[soul]{lua-ul}
\else
  \usepackage{soul}
\fi
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\author{}
\date{}

\begin{document}

18. Characters and C-strings

Objectives

\begin{itemize}
\tightlist
\item
  Declare character variables with or without initialization
\item
  Output and input character values
\item
  Use operators for character type
\item
  Understand the relationship between characters and ASCII decimal
  values
\item
  Declare C-string variables with or without initialization
\item
  Use C-string functions
\end{itemize}

Containers

We\textquotesingle re already talked about arrays (arrays of ints,
arrays of doubles, etc.) Usually we use all the slots in the arrays.
However an array can be used to model \textbf{containers}. What do I
mean by that? For instance suppose you want to write a program to
contain student IDs of current students who are at least 7 feet tall.
(Not a big list I suppose \ldots) In fall 2009 the list might contain:

3145673, 4135778, 2356317

in spring 2009 it might be

3145673, 4135778, 2356317, 5678246

and in fall 2010 it might be

2356317, 5678246

As you can see the number of things in the list changes.

An array can be used to model a container. It can be done in two ways
(at least!) You can keep an extra variable to indicate the number of
things modeled by the array. For instance try this program that prompts
the user for ids to be added to the id array and terminates when the
user enters -1.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int length = 0;

int id{[}10{]};

while (1)

\{

if (length == 10)

\{

std::cout \textless\textless{} "oops ... I\textquotesingle m
full!\textbackslash n";

\vtop{\hbox{\strut  break;}\hbox{\strut  \}}}

int x;

std::cin \textgreater\textgreater{} x;

if (x == -1) break;

id{[}length{]} = x;

length++;

for (int i = 0; i \textless{} length; i++)

\{

\vtop{\hbox{\strut  std::cout \textless\textless{} id{[}i{]}
\textless\textless{} \textquotesingle{} \textquotesingle;}\hbox{\strut 
\}}}

\vtop{\hbox{\strut  std::cout \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle;}\hbox{\strut \}}} \\
\end{longtable}

In this case \emph{\textbf{length}} is used to indicate that the actual
student ids are

\emph{id{[}0{]}, id{[}1{]}, \ldots, id{[}length-1{]}}

and the rest

\emph{id{[}length{]}, id{[}length+1{]}, \ldots, id{[}999{]}}

are unused.

A second way to model a container is to use a special \textbf{sentinel}
value to denote \textbf{``end-of-data''}. Try this program that does the
same thing as above except that I\textquotesingle m using -9999 to mark
the end-of-data.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int id{[}10{]} = \{-9999\};

while (1)

\{

// find length

int length = 0;

for (int i = 0; i \textless{} 10; i++)

\{

if (id{[}i{]} == -9999)

\{

length = i;

break;

\}

\}

if (length == 9)

\{

std::cout \textless\textless{} "oops ... I\textquotesingle m
full!\textbackslash n";

break;

\}

int x;

std::cin \textgreater\textgreater{} x;

if (x == -1) break;

id{[}length{]} = x;

id{[}length + 1{]} = -9999;

// print values in container

int i = 0;

while (id{[}i{]} != -9999)

\{

std::cout \textless\textless{} id{[}i{]} \textless\textless{}
\textquotesingle{} \textquotesingle;

i++;

\}

std::cout \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle;

\} \\
\end{longtable}

Note that the array begins with

-9999, \ldots{}

(the \ldots{} after the -9999) If I entered 42, the array becomes

42, -9999, \ldots{}

And if I entered 135 as the next number, the array becomes

42, 135, -9999, \ldots{}

Note that when using a sentinel to implement a container

\begin{itemize}
\tightlist
\item
  When adding the end of the container you always need to search for the
  sentinel value (more or less to compute the length of the container)
\item
  The number of values you can put into the container is always
  \textbf{one less than the actual size} of the container. Why? Because
  the sentinel value takes up on of the spots in the array!
\end{itemize}

We\textquotesingle ll be talking about C-strings in this set of notes.
You\textquotesingle ll see that the C-string uses the second method to
describe characters in a string.

Characters

Recall that this is a character:

\textquotesingle A\textquotesingle{}

That\textquotesingle s nothing new. To declare a character variable you
do this:

\emph{char c;}

You can of course initialize it too:

\emph{char c = \textquotesingle A\textquotesingle;}

And of course you already know that you can output and input characters:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} \textquotesingle A\textquotesingle{}
\textless\textless{} std::endl;

char c = \textquotesingle A\textquotesingle;

std::cout \textless\textless{} c \textless\textless{} std::endl;

std::cin \textgreater\textgreater{} c;

std::cout \textless\textless{} c \textless\textless{} std::endl; \\
\end{longtable}

Another thing you already know is that you can compare characters:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char c = \textquotesingle A\textquotesingle;

std::cout \textless\textless{} "gimme an A: ";

std::cin \textgreater\textgreater{} c;

if (c == \textquotesingle A\textquotesingle)

\{

std::cout \textless\textless{} "thanks!";

\}

else

\{

std::cout \textless\textless{} "r u the troublemaker-type?";

\} \\
\end{longtable}

ASCII: Characters and integers

One important thing you should know is that the character type is
actually an integer type. You can typecast between the two. Try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} (int)
\textquotesingle A\textquotesingle{} \textless\textless{} std::endl;

std::cout \textless\textless{} int(\textquotesingle A\textquotesingle)
\textless\textless{} std::endl;

char c = \textquotesingle A\textquotesingle;

std::cout \textless\textless{} (int) c \textless\textless{} std::endl;

std::cout \textless\textless{} int(c) \textless\textless{} std::endl; \\
\end{longtable}

As you can see the integer value corresponding to character
\textquotesingle A\textquotesingle{} is 65. Now try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} (char) 65 \textless\textless{} std::endl;

std::cout \textless\textless{} char(65) \textless\textless{}
std::endl; \\
\end{longtable}

The translation between characters and integer value is provided by the
so-called ASCII table. You can google the web to read more about the
ASCII standard and its history. You can also go straight to
wikipedia.com and search for ``ascii''. Here\textquotesingle s one such
table. Look for \textquotesingle A\textquotesingle{} and you see that
the integer value corresponding to \textquotesingle A\textquotesingle{}
is 65 (look under the ``Dec'' column - ``Dec'' means the integer value
is in base 10 \emph{\textbf{dec}}imal notation.)

\includegraphics[width=6.9846in,height=4.8701in]{Pictures/10000000000002CB000001E83D872810C8DA2306.png}

\textbf{Exercise.} What is the ASCII value of
\textquotesingle Z\textquotesingle? (You can of course use the web ...
but it\textquotesingle s easier just to write a program).

Now with the ASCII value of \textquotesingle Z\textquotesingle, fill in
the blank and run this program ... WAIT!!! ... can you figure out what
it does BEFORE running the program?

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
for (int i = 65; i \textless= \_\_\_\_\_; ++i)

\{

std::cout \textless\textless{} (char) i \textless\textless{} std::endl;

\} \\
\end{longtable}

In fact since characters can be automatically typecasted to integers you
can do this too:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
for (int i = \textquotesingle A\textquotesingle; i \textless=
\textquotesingle Z\textquotesingle; ++i)

\{

std::cout \textless\textless{} (char) i \textless\textless{} std::endl;

\} \\
\end{longtable}

\textbf{Exercise.} What is the ASCII value of
\textquotesingle Z\textquotesingle{} and
\textquotesingle5\textquotesingle? (Use the above ASCII table.) Is the
following true or false?

\textquotesingle Z\textquotesingle{} \textless{}
\textquotesingle5\textquotesingle{}

Now verify your guess by running this:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} (\textquotesingle Z\textquotesingle{}
\textless{} \textquotesingle5\textquotesingle) \textless\textless{}
std::endl; \\
\end{longtable}

\emph{\textbf{YET}} another way to do this is to realize that there are
arithmetic operators on the character type. First try this:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} \textquotesingle A\textquotesingle{} + 1
\textless\textless{} std::endl; \\
\end{longtable}

This tells you that \textquotesingle A\textquotesingle{} is
automatically typecasted to it\textquotesingle s ASCII value. Now you
can do this:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{}
(char)(\textquotesingle A\textquotesingle{} + 1) \textless\textless{}
std::endl; \\
\end{longtable}

\emph{\textbf{Finally}} ... run this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
for (char c = \textquotesingle A\textquotesingle; c \textless=
\textquotesingle Z\textquotesingle; ++c)

\{

std::cout \textless\textless{} c \textless\textless{} std::endl;

\} \\
\end{longtable}

This tells us that besides == and !=, the character type has the boolean
operators \textless, \textless=, \textgreater, \textgreater=. Basically
these comparison operators compare the ASCII value of the character. And
of course you have arithmetic operators since the character type is an
integer type.

So you see ... characters are actually numbers ... at least in the
computer.

Digit Character to Integer Value

Here\textquotesingle s a neat trick.

Suppose you want to ``translate'' the character
\emph{\textquotesingle0\textquotesingle{}} to integer \emph{0},
character \emph{\textquotesingle1\textquotesingle{}} to integer
\emph{1}, ..., character \textquotesingle{}\emph{9\textquotesingle{}} to
\emph{9''}. One way is to do this: Suppose \emph{c} is a character with
character \emph{\textquotesingle0\textquotesingle{}} or
\emph{\textquotesingle1\textquotesingle{}} or \ldots{} or
\emph{\textquotesingle9\textquotesingle{}}, and you want \emph{i} which
is an \emph{int} to be \emph{0} if \emph{c} is
\emph{\textquotesingle0\textquotesingle{}}, \emph{1} if \emph{c} is
\emph{\textquotesingle1\textquotesingle{}}, etc. You can do this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char c = \textquotesingle{} \textquotesingle;

std::cin \textgreater\textgreater{} c;

int i = 0;

switch (c)

\{

case \textquotesingle0\textquotesingle: i = 0;

break;

case \textquotesingle1\textquotesingle: i = 1;

break;

case \textquotesingle2\textquotesingle: i = 2;

break;

case \textquotesingle3\textquotesingle: i = 3;

break;

case \textquotesingle4\textquotesingle: i = 4;

break;

case \textquotesingle5\textquotesingle: i = 5;

break;

case \textquotesingle6\textquotesingle: i = 6;

break;

case \textquotesingle7\textquotesingle: i = 7;

break;

case \textquotesingle8\textquotesingle: i = 8;

break;

case \textquotesingle9\textquotesingle: i = 9;

break;

\}

std::cout \textless\textless{} i \textless\textless{} std::endl; \\
\end{longtable}

Or you can also use a stack of if-else. Make sure you run this program.

That\textquotesingle s great. It works. But it shows
you\textquotesingle re a newbie!!! Here\textquotesingle s the smart way
to do it. Notice that the ASCII table for
\textquotesingle0\textquotesingle, \textquotesingle1\textquotesingle,
..., \textquotesingle9\textquotesingle{} is this:

character ASCII integer value value that you want

\textquotesingle0\textquotesingle{} 48 0

\textquotesingle1\textquotesingle{} 49 1

\textquotesingle2\textquotesingle{} 50 2

\textquotesingle3\textquotesingle{} 51 3

\textquotesingle4\textquotesingle{} 52 4

\textquotesingle5\textquotesingle{} 53 5

\textquotesingle6\textquotesingle{} 54 6

\textquotesingle7\textquotesingle{} 55 7

\textquotesingle8\textquotesingle{} 56 8

\textquotesingle9\textquotesingle{} 57 9

Do you see a pattern? (SPOILERS AHEAD)

The point is that the character \textquotesingle0\textquotesingle, ...,
\textquotesingle9\textquotesingle{} appear in order in the ASCII table.
Look at the table again:

character ASCII integer value translated value

\textquotesingle0\textquotesingle{} 48 0 = 48 -- 48

\textquotesingle1\textquotesingle{} 49 1 = 49 -- 48

\textquotesingle2\textquotesingle{} 50 2 = 50 -- 48

\textquotesingle3\textquotesingle{} 51 3 = 51 -- 48

\textquotesingle4\textquotesingle{} 52 4 = 52 -- 48

\textquotesingle5\textquotesingle{} 53 5 = 53 -- 48

\textquotesingle6\textquotesingle{} 54 6 = 54 -- 48

\textquotesingle7\textquotesingle{} 55 7 = 55 -- 48

\textquotesingle8\textquotesingle{} 56 8 = 56 -- 48

\textquotesingle9\textquotesingle{} 57 9 = 57 -- 48

which is the same as

character ASCII integer value translated value

\textquotesingle0\textquotesingle{} 48 0 =
int(\textquotesingle0\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle1\textquotesingle{} 49 1 =
int(\textquotesingle1\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle2\textquotesingle{} 50 2 =
int(\textquotesingle2\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle3\textquotesingle{} 51 3 =
int(\textquotesingle3\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle4\textquotesingle{} 52 4 =
int(\textquotesingle4\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle5\textquotesingle{} 53 5 =
int(\textquotesingle5\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle6\textquotesingle{} 54 6 =
int(\textquotesingle6\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle7\textquotesingle{} 55 7 =
int(\textquotesingle7\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle8\textquotesingle{} 56 8 =
int(\textquotesingle8\textquotesingle{} --
\textquotesingle0\textquotesingle)

\textquotesingle9\textquotesingle{} 57 9 =
int(\textquotesingle9\textquotesingle{} --
\textquotesingle0\textquotesingle)

In all cases, if c is a character
\textquotesingle0\textquotesingle,...,\textquotesingle9\textquotesingle{}
the integer value you want is ...

c -- \textquotesingle0\textquotesingle{}

\textbf{That\textquotesingle s all!!! }In other words, this program:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char c = \textquotesingle{} \textquotesingle;

std::cin \textgreater\textgreater{} c;

int i = 0;

switch (c)

\{

case \textquotesingle0\textquotesingle: i = 0;

break;

case \textquotesingle1\textquotesingle: i = 1;

break;

case \textquotesingle2\textquotesingle: i = 2;

break;

case \textquotesingle3\textquotesingle: i = 3;

break;

case \textquotesingle4\textquotesingle: i = 4;

break;

case \textquotesingle5\textquotesingle: i = 5;

break;

case \textquotesingle6\textquotesingle: i = 6;

break;

case \textquotesingle7\textquotesingle: i = 7;

break;

case \textquotesingle8\textquotesingle: i = 8;

break;

case \textquotesingle9\textquotesingle: i = 9;

break;

\}

std::cout \textless\textless{} i \textless\textless{} std::endl; \\
\end{longtable}

can be \textbf{rewritten} as:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char c = \textquotesingle{} \textquotesingle;

std::cin \textgreater\textgreater{} c;

int i = c - \textquotesingle0\textquotesingle;

std::cout \textless\textless{} i \textless\textless{} std::endl; \\
\end{longtable}

I don\textquotesingle t know about you. But I prefer the second
version!!! Make sure you run this program.

\textbf{Exercise.} Write a program that prompts the user for a, b, c,
\ldots, z (i.e. lowercase letters) and prints 0, 1, 2, \ldots, 25
respectively.

\textbf{Exercise.} Write a program that prompts the user for a, b, c,
\ldots, z, A, B, C, \ldots, Z (i.e. lower and uppercase letters) and
prints 0 for a or A, 1 for b or B, 2 for c or C, \ldots, 25 for z or Z
respectively.

C-strings

A \textbf{C-string} is nothing more than an array of characters. The
only thing different between a C-string and an array of integers (say)
is that the \textbf{special escape character
\textquotesingle\textbackslash0\textquotesingle{}} (the 0 is the
\textbf{number} 0, not the letter O) is used to mark the
\textbf{end-of-string}. This is a special character just like
\textquotesingle\textbackslash n\textquotesingle{} or
\textquotesingle\textbackslash t\textquotesingle{} because
\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle\textbackslash n\textquotesingle,
\textquotesingle\textbackslash t\textquotesingle{} are not ``visible''
characters.

Try to print \textquotesingle\textbackslash0\textquotesingle{} and you
won\textquotesingle t see a thing:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{}
\textquotesingle\textbackslash0\textquotesingle{} \textless\textless{}
std::endl; \\
\end{longtable}

(There are in fact lots of invisible characters.)

The point of the end-of-string marker
\textquotesingle\textbackslash0\textquotesingle, is to end some string
processing. This is what I mean. Try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char spam{[}{]} = \{\textquotesingle a\textquotesingle,
\textquotesingle b\textquotesingle, \textquotesingle c\textquotesingle,
\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle d\textquotesingle,
\textquotesingle e\textquotesingle\};

std::cout \textless\textless{} spam \textless\textless{} std::endl; \\
\end{longtable}

In this case the ``processing'' is the print statement:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} spam \textless\textless{} std::endl; \\
\end{longtable}

The \emph{\textquotesingle\textbackslash0\textquotesingle{}} basically
tells the print statement that printing should stop after printing the
third character \emph{\textquotesingle c\textquotesingle{}}. The output
looks like this:

\emph{abc}

Note another thing ... \textbf{You can actually print a character
array!!!} Remember that you cannot do that for an array of integers,
doubles, or booleans. You have to write a for-loop in those case. As a
reminder try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int x{[}{]} = \{1, 2, 3, 4, 5\};

std::cout \textless\textless{} x \textless\textless{} std::endl; \\
\end{longtable}

Let\textquotesingle s go back to the above example:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char spam{[}{]} = \{\textquotesingle a\textquotesingle,
\textquotesingle b\textquotesingle, \textquotesingle c\textquotesingle,
\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle d\textquotesingle,
\textquotesingle e\textquotesingle\};

std::cout \textless\textless{} spam \textless\textless{} std::endl; \\
\end{longtable}

Note that it does NOT mean that the size of the array is 3; it is true
that three characters are printed. There are actually 6 characters in
the array:

\textquotesingle a\textquotesingle, \textquotesingle b\textquotesingle,
\textquotesingle c\textquotesingle,
\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle d\textquotesingle, \textquotesingle e\textquotesingle{}

So you need to distinguish the difference between the
\emph{\textbf{size}} of the string \emph{spam} and its
\emph{\textbf{length}} which is defined to be the number of characters
up to, but not including, the first
\emph{\textquotesingle\textbackslash0\textquotesingle{}}.

Informally when we think of

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char spam{[}{]} = \{\textquotesingle a\textquotesingle,
\textquotesingle b\textquotesingle, \textquotesingle c\textquotesingle,
\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle d\textquotesingle,
\textquotesingle e\textquotesingle\};  \\
\end{longtable}

\textbf{as a string}, we say that it is made up of
\textquotesingle a\textquotesingle, \textquotesingle b\textquotesingle,
\textquotesingle c\textquotesingle. But \textbf{as a character array} is
made up of six characters. Make sure you remember that.

You can think of the character
\textquotesingle\textbackslash0\textquotesingle{} in the array

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char spam{[}{]} = \{\textquotesingle a\textquotesingle,
\textquotesingle b\textquotesingle, \textquotesingle c\textquotesingle,
\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle d\textquotesingle,
\textquotesingle e\textquotesingle\};  \\
\end{longtable}

as a sentinel value to mark the end of data for the string represented
as an array. The character
\textquotesingle\textbackslash0\textquotesingle{} is also called the
\textbf{null character}. This is the reason why C-strings are also
called \textbf{null-terminated strings}.

Exercise. What are the lengths and sizes of the following variables?

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char ham{[}{]} = \{\textquotesingle3\textquotesingle,
\textquotesingle.\textquotesingle,
\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle1\textquotesingle, \textquotesingle4\textquotesingle\};

char eggs{[}{]} = \{\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle b\textquotesingle,
\textquotesingle\textbackslash0\textquotesingle,
\textquotesingle a\textquotesingle\};  \\
\end{longtable}

You can verify your answers by counting the number of characters
printed:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} ham \textless\textless{} std::endl;

std::cout \textless\textless{} eggs \textless\textless{} std::endl; \\
\end{longtable}

There is a shorthand for \{\textquotesingle a\textquotesingle,
\textquotesingle b\textquotesingle, \textquotesingle c\textquotesingle,
\textquotesingle\textbackslash0\textquotesingle\}. Try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char spam{[}{]} = "abc"

std::cout \textless\textless{} spam \textless\textless{} std::endl; \\
\end{longtable}

Note in this case that spam has size 4 (there are 4 characters in the
array) and length 3 (there are 3 characters before the first
\textquotesingle\textbackslash0\textquotesingle); "abc" is

\emph{\{\textquotesingle a\textquotesingle,
\textquotesingle b\textquotesingle, \textquotesingle c\textquotesingle,
\textbf{\textquotesingle\textbackslash0\textquotesingle{}}\}.}

Exercise. What is the length and size of the following variable?

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char spam{[}100{]} = "ab\textbackslash0cd"; \\
\end{longtable}

Exercise. What is the length and size of the following variable?

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char spam{[}{]} = "ab\textbackslash0cd"; \\
\end{longtable}

Exercise. What are the length and size of the following variable?

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char spam{[}100{]} = ""; \\
\end{longtable}

Of course you can do this:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} \textbf{"abc\textbackslash0de"}
\textless\textless{} std::endl; \\
\end{longtable}

You have already seen this ...

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} "hello world" \textless\textless{}
std::endl; \\
\end{longtable}

during the first week of class. Now you know that \emph{"hello world"}
is an array of characters. It\textquotesingle s just the character array
made up of the following characters:

\textquotesingle h\textquotesingle,\textquotesingle e\textquotesingle,\textquotesingle l\textquotesingle,\textquotesingle l\textquotesingle,\textquotesingle o\textquotesingle,\textquotesingle{}
\textquotesingle,\textquotesingle w\textquotesingle,\textquotesingle o\textquotesingle,\textquotesingle r\textquotesingle,\textquotesingle l\textquotesingle,\textquotesingle d\textquotesingle,\textquotesingle\textbackslash0\textquotesingle{}

(Don\textquotesingle t forget the
\textquotesingle\textbackslash0\textquotesingle!!!)

\textbf{Exercise.} Can you do the following?

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} \{\textquotesingle a\textquotesingle,
\textquotesingle b\textquotesingle, \textquotesingle c\textquotesingle\}
\textless\textless{} std::endl; \\
\end{longtable}

If you have a long string you can break it up like this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char foo{[}{]} = \textbf{"abc"}

\textbf{ "def"};

std::cout \textless\textless{} foo \textless\textless{} std::endl; \\
\end{longtable}

Basically C++ will join it up for you so that the above code is the same
as this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char foo{[}{]} = \textbf{"abcdef"};

std::cout \textless\textless{} foo \textless\textless{} std::endl; \\
\end{longtable}

\textbf{Exercise.} Can you do this:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} \textbf{"abc" "def"} \textless\textless{}
std::endl; \\
\end{longtable}

Can you do the same for integers?

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} 123\textbf{ }456 \textless\textless{}
std::endl; \\
\end{longtable}

\textbf{Exercise.} You now know that although you cannot print an array
of integers with \emph{std::cout} (you need to write a for-loop), you
can print an array of characters (it will only print up to
\textquotesingle{}\emph{\textbackslash0\textquotesingle{}}). What about
input? Try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char s{[}100{]};

std::cin \textgreater\textgreater{} s; // type in abcde

std::cout \textless\textless{} s \textless\textless{} std::endl; \\
\end{longtable}

Not too shocking right?

\textbf{Exercise.} Run the above program again and enter this as input:

\emph{hello world}

What do you see?

The problem with \emph{std::cin} is that is that \emph{std::cin} cuts up
inputs at spaces, tabs, or newline (i.e. whitespaces). So for the above
exercise, C++ will only give the string \emph{\textbf{"}hello\textbf{"}}
to variable s. If you do want spaces to go into your string variable,
then you need to do something else for input. Check out a later section
on the \emph{getline()} function.

The \emph{strlen()} function

C-strings are so useful that several functions are provided with your
compiler so that you can work effectively with them. Depending on your
compiler, you might need to do this when you want to use these C-string
functions:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\#include \textless iostream\textgreater{}

\#include \textless cstring\textgreater{}

... YOUR PROGRAM ... \\
\end{longtable}

If your compiler is really old then you might need to do this instead:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\#include \textless iostream\textgreater{}

\#include "string.h"

... YOUR PROGRAM ... \\
\end{longtable}

Here\textquotesingle s the first function ...

The function strlen() returns the \textbf{length} of the string
parameter. This is called the \textbf{string length function}. Try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} strlen("abc") \textless\textless{}
std::endl;

std::cout \textless\textless{} strlen("a\textbackslash0c")
\textless\textless{} std::endl;

std::cout \textless\textless{} strlen("") \textless\textless{}
std::endl;

char s{[}{]} = "abc";

std::cout \textless\textless{} strlen(s) \textless\textless{} std::endl;

char t{[}{]} = "ab\textbackslash0c";

std::cout \textless\textless{} strlen(t) \textless\textless{} std::endl;

char u{[}100{]} = "";

std::cout \textless\textless{} strlen(u) \textless\textless{}
std::endl; \\
\end{longtable}

By the way, what if your compiler does not have the \emph{strlen()}
function? Well the code to perform the same thing as the \emph{strlen()}
function is very simple. You just loop through the character array until
you see \emph{\textquotesingle\textbackslash0\textquotesingle{}}. You
have a counter that counts the number of characters scanned until
\emph{\textquotesingle\textbackslash0\textquotesingle{}}, not including
the \emph{\textquotesingle\textbackslash0\textquotesingle{}} character.
Here you go:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char x{[}100{]} = "abc";

int len = 0;

while (x{[}len{]} != \textquotesingle\textbackslash0\textquotesingle)

\{

len++;

\}

std::cout \textless\textless{} len \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle; \\
\end{longtable}

Run the program. Change it to this and run it again:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char x{[}100{]} = "hello world";

int len = 0;

while (x{[}len{]} != \textquotesingle\textbackslash0\textquotesingle)

\{

len++;

\}

std::cout \textless\textless{} len \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle; \\
\end{longtable}

There\textquotesingle s actually a ``problem'' with the \emph{strlen()}
function. You see ... if a person accidentally calls the \emph{strlen()}
function with a character array that does \emph{\textbf{not}} contain a
\emph{\textquotesingle\textbackslash0\textquotesingle{}}, the function
can actually go beyond the array bound. This might crash the program.
Here\textquotesingle s an example:

char x{[}{]} = \{\textquotesingle a\textquotesingle,
\textquotesingle b\textquotesingle,
\textquotesingle c\textquotesingle\};

std::cout \textless\textless{} strlen(x) \textless\textless{} std::endl;

This is what we call a \textbf{buffer overflow}: Your string length
function will access a value in the array \emph{x} that is actually
outside \emph{x}. We\textquotesingle ll come back to this issue later.

Other C-string functions

In fact there are MANY standard string functions that come with all C
compilers. Here are some of the most basic ones. Experiment with this
code and figure out what the string functions do:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char s{[}100{]} = "aaa";

char t{[}100{]} = "bbb";

char u{[}100{]};

// string copy function

// overwrite the string in u with the string in

// s

strcpy(u, s);

std::cout \textless\textless{} u \textless\textless{} std::endl;

// string concatenation function

// put the string in t to the end of the string

// in u

strcat(u, t);

std::cout \textless\textless{} u \textless\textless{} std::endl;

// WARNING: You cannot do strcat(u, u), i.e., the

// two arguments of the function must be different.

// string comparison function

// 0 is returned when the strings are

// the same. Otherwise a nonzero value is

// returned.

int i = strcmp(u, s);

std::cout \textless\textless{} i \textless\textless{} std::endl; \\
\end{longtable}

You might wonder what nonzero value is returned by \emph{strcmp()} when
the strings are different.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
std::cout \textless\textless{} strcmp("a", "b") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("a", "c") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("a", "d") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("a", "z") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("a", "!") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("a", "ba") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("b", "a") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("c", "a") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("d", "a") \textless\textless{}
std::endl;

std::cout \textless\textless{} strcmp("ba", "a") \textless\textless{}
std::endl; \\
\end{longtable}

See it yet? (Hint: Check an ASCII table.)

There are other C-string functions but you will need to know a little
more in order to understand how to use them.

The \emph{strnlen()}, \emph{strncmp()}, \emph{strncat()} functions

All the string functions we talked about run into problems if the
character arrays passed into these function do not contain
\textquotesingle\textbackslash0\textquotesingle{} resulting in buffer
overflow.

In fact this is one scenario of the so-called \textbf{buffer overflow
attack}, a technique used in many virus software (malware).

Accompanying these functions are similar functions that allow you to
specify a stopping point. For instance in the case of strlen() (the
string length function) there is a function called

strnlen()

Besides passing in a string, you also pass in a maximum possible length
for the string.

char s{[}100{]} = ""; // s{[}0{]} =
\textquotesingle\textbackslash0\textquotesingle;

std::cin \textgreater\textgreater{} s;

std::cout \textless\textless{} \textbf{strnlen}(s, \textbf{99})
\textless\textless{} std::endl;

Note that I pass in 99 and not 100. If s has a \textbf{size of 100}
the\includegraphics[width=2.4484in,height=1.4882in]{Pictures/100000000000016A000000DC2854AEEECF9FE6F2.png}
\textbf{maximum possible length is 99} since in this case the
\textbf{last character is used by \st{by}
\textquotesingle\textbackslash0\textquotesingle{}}. Therefore \emph{s}
(of size 100) has a maximum length of 99.

\textbf{Exercise.} What is the output of this code:

The accompanying safer functions for strcmp() and strcat() are strncmp()
and strncat(). So we have the following \emph{\textbf{pairs}} of
functions:

strlen() strnlen()

strcmp() strncmp()

strcat() strncat()

Try this program:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char s{[}100{]} = "aaa";

char t{[}100{]} = "bbb";

char u{[}100{]};

// string copy function

// In this case at most 100 chars are copied

// from s to u

strncpy(u, s, 100);

std::cout \textless\textless{} u \textless\textless{} std::endl;

// string concatenation function

// In this case at most 100 chars are

// concatenated from t to u

strncat(u, t, 100);

std::cout \textless\textless{} u \textless\textless{} std::endl;

// string comparison function

// In this case at most 100 characters are

// compared.

int i = strncmp(u, s, 100);

std::cout \textless\textless{} i \textless\textless{} std::endl; \\
\end{longtable}

The only problem in the above example is the call to strncat() function.
You see if \emph{u} already has a string of length 10, then only 90
characters are left for concatenation. If \emph{t} has length greater
than that, the program might crash. Therefore it\textquotesingle s safe
to write this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// string concatenation function

// In this case at most 100 chars are

// concatenated from t to u

strncat(u, t, 100 -- strnlen(u, 100));

std::cout \textless\textless{} u \textless\textless{} std::endl; \\
\end{longtable}

But in this case some character might not be copied from \emph{t} to
\emph{u}. Depending on what your program is supposed to do, you might
want to print an error message and halt the program.

The \emph{std::cin.getline()} function

Recall that there is a problem with input of strings ...

\emph{std::cin} cuts up inputs at spaces, tabs, or newline (i.e.
whitespaces). So if you run this code:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char s{[}100{]};

std::cin \textgreater\textgreater{} s;

std::cout \textless\textless{} s \textless\textless{} std::endl; \\
\end{longtable}

with this input

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
to be or not to be \\
\end{longtable}

you will find that the output is

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
to \\
\end{longtable}

In other words C++ chops up the input at spaces, tabs and newlines. So
\emph{s} is only assigned the string \emph{"to"}.

Now \ldots{} what ever happened to the rest of the input:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
be or not to be \\
\end{longtable}

?!? Try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char s{[}100{]};

char t{[}100{]};

char u{[}100{]};

std::cin \textgreater\textgreater{} s \textgreater\textgreater{} t
\textgreater\textgreater{} u;

std::cout \textless\textless{} s \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle{} \textless\textless{}
t \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle{} \textless\textless{}
u \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle; \\
\end{longtable}

with input

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
i\textquotesingle m zaphad beeblebrox \\
\end{longtable}

Get it?

\textbf{Exercise.} What if you entered 5 spaces at the
\emph{\textbf{beginning}} of the input like this

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\emph{ \textbf{i\textquotesingle m zaphad beeblebrox}} \\
\end{longtable}

What is the value of \emph{s} in this case?

So how do you handle the problem of spaces and tabs? What if you really
want spaces and tabs to go into a string? Then you have to use another
function. Try running this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char s{[}100{]};

std::cin.getline(s, 100);

std::cout \textless\textless{} s \textless\textless{} std::endl; \\
\end{longtable}

with this input:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
to be or not to be \\
\end{longtable}

Note that the \emph{std::cin.getline()} function also allows you to
specify the size of \emph{s}. In the above example, C++ will only read
in at most 99 characters, reserving the last for
\textquotesingle\textbackslash0\textquotesingle. This prevents buffer
overflow.

The \emph{std::cin.getline()} function will assign all the characters up
to but not including
\emph{\textquotesingle\textbackslash n\textquotesingle{}} (when you
press the enter key you are including a

\emph{\textquotesingle\textbackslash n\textquotesingle{}} in your input.
In other words \emph{getline()} cuts up input at the
\emph{\textquotesingle\textbackslash n\textquotesingle{}} character.

The \emph{std::cin.getline()} function can actually do a lot more. You
can get it to cut up input at any character you specify. For instance
\emph{ }

std::cin.getline(s, 100,
\textquotesingle\textbackslash t\textquotesingle);

will cut up input at
\emph{\textquotesingle\textbackslash t\textquotesingle{}} (tab)
characters. (The
\emph{\textquotesingle\textbackslash t\textquotesingle{}} in this case
is sometimes called the stop character.)

Try this

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char s{[}10{]};

char t{[}10{]};

char u{[}10{]};

std::cin.getline(s, 10, \textquotesingle,\textquotesingle);

std::cin.getline(t, 10, \textquotesingle,\textquotesingle);

std::cin.getline(u, 10, \textquotesingle,\textquotesingle);

std::cout \textless\textless{} \textquotesingle{[}\textquotesingle{}
\textless\textless{} s \textless\textless{} "{]}\textbackslash n"

\textless\textless{} \textquotesingle{[}\textquotesingle{}
\textless\textless{} t \textless\textless{} "{]}\textbackslash n"

\textless\textless{} \textquotesingle{[}\textquotesingle{}
\textless\textless{} u \textless\textless{} "{]}\textbackslash n" ; \\
\end{longtable}

with input

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
aaa, bbb ,c c c, \\
\end{longtable}

\textbf{Exercise.} What happens when you run the above program with this
input

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0123456789,b,c, \\
\end{longtable}

\textbf{ }

\emph{std::cin} and \emph{std::cin.getline()}

The \textbf{extremely important thing} to remember is that
\emph{std::cin} does not work well with \emph{std::cin.getline()}.

\textbf{Exercise.} Try to mix \emph{std::cin} and
\emph{std::cin.getline()} like this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char s{[}100{]};

int i;

std::cin \textgreater\textgreater{} i;

std::cout \textless\textless{} i \textless\textless{} std::endl;

std::cin.getline(s, 100);

std::cout \textless\textless{} s \textless\textless{} std::endl; \\
\end{longtable}

Run the program and see what happens.

Type conversion: C-strings to numerics

We\textquotesingle ve been using the \emph{std::cin} for inputs and it
works for input of integer values, double values, C-string values, etc.
We saw above that the problem is that \emph{std::cin} cuts up input at
whitespaces. The \emph{std::cin.getline()} does work by really taking in
everything as input. But the problem is that it works for strings.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\#include \textless iostream\textgreater{}

\#include \textless cstdlib\textgreater{}

int main()

\{

char s{[}100{]} = "123";

char t{[}100{]} = "12.3";

int i = strtol(s, NULL, 10);

double d = strtod(t, NULL);

std::cout \textless\textless{} i \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle{} \textless\textless{}
d \textless\textless{} \textquotesingle\textbackslash n\textquotesingle;

\} \\
\end{longtable}

The functions above are

strtol() string-to-long-integer

strtod() string-to-double

The \emph{strtol()} converts the string to a \emph{\textbf{long int}}
whose largest possible value might be larger than your usual
\emph{\textbf{int}}.

I\textquotesingle ll explain the \emph{NULL} business later. Right now I
just want to get the usage of the functions to you now so that you can
use it.

Type conversion: numerics to C-strings

Of course you also need to know how to convert an int or a double to a
C-string. There are several ways to do this.

Here\textquotesingle s the first method in C-style (i.e. using a C
function)

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\#include \textless cstdio\textgreater{} // or \#include
\textless stdio.h\textgreater{}

...

char c{[}100{]};

int i = 42;

double d = 3.14;

\textbf{sprintf(c, "\%d", i);}

std::cout \textless\textless{} c \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle;

\textbf{sprintf(c, "\%f", d);}

std::cout \textless\textless{} c \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle; \\
\end{longtable}

The second method uses C++ features:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\#include \textless sstream\textgreater{}}

\textbf{\textbf{}}

\textbf{\textbf{...}}

\textbf{\textbf{}}

\textbf{\textbf{ char c{[}100{]};}}

\textbf{\textbf{ int i = 123;}}

double d = 3.14;

\textbf{\textbf{}}

\textbf{ std::stringstream out;}

\textbf{}

\textbf{ out \textless\textless{} i;}

\textbf{ strcpy(c, out.str().c\_str());}

\textbf{\textbf{ std::cout \textless\textless{} c \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle;}}

\textbf{\textbf{}}

\textbf{\textbf{ }out \textless\textless{} d;}

\textbf{ strcpy(c, out.str().c\_str());}

\textbf{\textbf{ std::cout \textless\textless{} c \textless\textless{}
\textquotesingle\textbackslash n\textquotesingle;}} \\
\end{longtable}

Exercise

\textbf{Exercise.} Write a program that prompts the user for a string
and prints the character that occurs most frequently in the string.

\textbf{Exercise.} Write a program that prompts the user for a string
and checks if the string is a palindrome. The check should ignore
non-letters and the case of letters. For instance ``madam,
I\textquotesingle m Adam'' is a palindrome.

\textbf{Exercise.} Write a program that prompts the user for a string,
that allows user to perform a substitution of characters. For instance,
if the user enters ``hello world'' and then request to have l replaced
by r.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
input: hello world

source: l

target: r

hello world

l-\textgreater r

-\/-rr- -\/-\/-r-

source: d

target: e

hello world

l-\textgreater r, d-\textgreater e

-\/-rr- -\/-\/-re

source: l

target: o

l-\textgreater o, d-\textgreater e

hello world

-\/-oo- -\/-\/-oe

source: w

target: o

*** invalid target: o is already a target

target: i

l-\textgreater o, d-\textgreater e, w-\textgreater i

hello world

-\/-oo- i-\/---oe

source: +  \\
\end{longtable}

The program quits when the user enters + for source. This simple program
can be used to help you solve a type of encrypted text called
substitution cipher..

\textbf{Exercise. }Write a program that prompts the user for two strings
and checks if the second string occurs as a substring of the first. If
so the index where the second occurs in the first is printed. Otherwise
-1 is printed.

\textbf{Exercise.} Write a program that accepts a string from the user
and a window column size and prints the string in the console window
with the given size. For instance if the user entered ``it was a dark
and stormy night \ldots'' and a size of 10, then the output is

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
it was a

dark and

stormy

night ... \\
\end{longtable}

Note that at most 10 characters from the string is printed per row. If
the user entered 15 for the size then the output is

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
it was a dark

and stormy

night ... \\
\end{longtable}

\textbf{Exercise.} Write a program accepts a string that is an integer
expression, interprets the expression, perform the appropriate
operations and prints the results. For instance is the user enters the
string ``1 + 2'', the program prints 3. If the user enters ``1 -- 2 + 3
* 4'' the program prints 11. The program should handle +, -, *, /, \%
and integer values.

\end{document}
