\newpage\EMPHASIZE{08. \texttt{if} and \texttt{if-else}: Part 2}

This is a continuation of \lq\lq if and if-else: Part 1''.

Enough said. Move on!!!

\newpage\EMPHASIZE{\texttt{if}-\texttt{else} statements}

Run this twice by entering 42 and then 24 for input:
\begin{console}
int a = 0;
std::cout << "C++: What's your favorite number?"
          << std::endl << "User: ";
std::cin >> a;

if (a == 42)
   std::cout << "C++: Mine too!" <<std::endl;
if (a != 42)
   std::cout << "C++: boo!" << std::endl;
\end{console}

You want to either do one thing or another based on whether a boolean
condition is true or false (respectively). The above does work ...
\textit{but} it is the \EMPHASIZE{WRONG} way of doing it.

Now change the above to this:
\begin{console}[commandchars=\~\@\$]
int a = 0;
std::cout << "C++: What's your favorite number?"
          << std::endl << "User: ";
std::cin >> a;

if (a == 42)
   std::cout << "C++: Mine too!" << std::endl;
~textbf@else$
   std::cout << "C++: boo!" << std::endl;
\end{console}

You should \EMPHASIZE{NEVER} have a program like the earlier one with two
if's with opposite conditions next to each other:
\begin{console}
if (a == 42)
   std::cout << "C++: Mine too!" <<std::endl;
if (a != 42)      // BAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   std::cout << "C++: boo!" << std::endl;
\end{console}

In other words if you can rewrite a bunch of ifs with if-else, then you
should. Why? Because this avoids evaluating boolean expressions
unnecessarily and hence speed up your program. (There are other
reasons).

The \EMPHASIZE{second} way (the if-else) is the \EMPHASIZE{right} way:

\begin{console}
if (a == 42)
   std::cout << "C++: Mine too!" << std::endl;
else
   std::cout << "C++: boo!" << std::endl;
\end{console}

The format of the if-else statement is
\begin{center}
\EMPHASIZE{if (\texttt{[bool expr]})}\\
\EMPHASIZE{\texttt{[stmt1]}}\\
\EMPHASIZE{else}\\
\EMPHASIZE{\texttt{[stmt2]}}\\
\end{center}

If \textit{\texttt{[bool expr}} evaluates to \texttt{true}, \textit{\texttt{[stmt1}}
executes. When that's completed, the else part is
bypassed. If \textit{\texttt{[bool expr}} evaluates to \texttt{false}
\textit{\texttt{[stmt2}} is executed.

Obviously you can't write an else statement without an if!!!

%\textbf{Exercise.} 
\begin{ex}
Here's the first if-else warm up exercise. No sweat required to finish it. First try running this program so that you know what it does:
\begin{console}
int numHeads = 0;
std::cout << "How many heads do you have? ";
std::cin >> numHeads;
if (numHeads == 2)
   std::cout << "Are you Zaphod?" << std::endl;
if (numHeads != 2)
   std::cout << "You are not Zaphod" << std::endl;
\end{console}
\end{ex}

Next modify it to use if-else instead of two if's. Run
the program and test it. Here are some tests:
\begin{console}[commandchars=\~\@\$]
How many heads do you have? ~textbf@1$
You are not Zaphod
\end{console}

And here's an execution of the same program:

\begin{console}[commandchars=\~\@\$]
How many heads do you have? ~textbf@2$
Are you Zaphod?
\end{console}

\begin{ex}
Run the following program:
\begin{console}
std::cout << "How much do you have? ";
double savings = 0.0;
std::cin >> savings;

if (savings > 100)
   std::cout << "Can I borrow a ten?" << std::endl;
if (savings <= 100)
   std::cout << "Life is tough" << std::endl;
\end{console}
\end{ex}
Rewrite the program using if-else.

\begin{ex}
Write a program that prompts the user for an integer and tells you if the input is even or odd. Here's an execution:
\begin{console}[commandchars=\~\@\$]
gimme an int ~textbf@~underline@42$$
even!!!
\end{console}
\end{ex}
Here's another:
\begin{console}[commandchars=\~\@\$]
gimme an int ~textbf@~underline@35$$
odd!!!
\end{console}

\begin{ex}
No skeleton code here. This is a slight modification
of a previous program. Write a program that prompts the user for his/her
height (in ft) and weight (in lbs) and prints \lq\lq you will live more than
100 years!!!'' if the product of the height and weight is at least
200.45. (This is not supported by any form of research.) Otherwise it
prints \lq\lq you will not live more than 100 years''. Here's
an execution of the program:
\begin{console}[commandchars=\~\@\$]
~textbf@6.1 180.180$
you will live more than 100 years!!!
\end{console}
\end{ex}
Here's another
\begin{console}[commandchars=\~\@\$]
~textbf@3.4 23.4$
you will live more than 100 years!!!
\end{console}

\textbf{Exercise.}
\begin{ex}
 Write a program that prompts the user for his
employee code which is either 0 or 1. If the employee code is 0, his/her
hourly rate is \$123.45. If the employee code is 1, his/her hourly rate
is \$7.99. Prompt the user for the number of hours he/she worked this
week. Finally print the total amount he/she made this week.
Here's an informal description of the program that you
should follow (obviously you have to translate this to C++!!!):
\begin{console}
Declare constant HOURLY_RATE_0 and initialize it to 123.45.
Declare constant HOURLY_RATE_1 and initialize it to 7.99.

Declare variable employee_code.
Get employee_code from user.

Declare variable hourly_rate.
If employee_code is 0:
   set hourly_rate to HOURLY_RATE_0
Otherwise:
        set hourly_rate to HOURLY_RATE_1
        
Get number_of_hours from user.
Print total pay for this week.
\end{console}
\end{ex}

\newpage\EMPHASIZE{Mental picture: flow of execution for \texttt{if-else}}

The following picture shows you the flow of execution of a simple
program containing the if-else statement.
\begin{console}
int x = 0;
std::cin >> x;

if (x > 0)
   std::cout << "spam!" << std::endl;
else
   std::cout << "ham!" << std::endl;
   
std::cout << "eggs" << std::endl;
\end{console}
\begin{python}
from latextool_basic import *
p = Plot()
M = r'''
int x = 0;

std::cin >> x;
                                                                          
if (x > 0)

   std::cout << "spam!" << std::endl;   
else
   std::cout << "ham!" << std::endl;
   
std::cout << "eggs" << std::endl;
'''.strip()

points = [(-1.5, 0.72), (-1.5, -0.72), (13.7, -0.72), (13.7, -2.1), (-1.5, -2.1), (-1.5, -3.72), (13.7, -3.72), (13.7, -5.1), (-1.5, -5.1), (-1.5, -6.3), (-0.8, -6.3), (13, -9.7), (13.7, -9.7), (13.7, -11.72), (-1.5, -11.72), (-1.5, -12.72), (-0.8, -12.72)]

p += Line(points = [(-1.5, 0.72), (-1.5, -0.72)], linewidth = 0.1, linecolor='red')
p += Line(points = [(-1.5, -0.72), (-0.8, -0.72)], linewidth = 0.1, endstyle='>', linecolor='red')
p += Line(points = [(13, -0.72), (13.7, -0.72)], linewidth = 0.1, linecolor='red')
p += Line(points = [(13.7, -0.72), (13.7, -2.1)], linewidth = 0.1, linecolor='red')
p += Line(points = [(13.7, -2.1), (-1.5, -2.1)], linewidth = 0.1, linecolor='red')
p += Line(points = [(-1.5, -2.1), (-1.5, -3.72)], linewidth = 0.1, linecolor='red')
p += Line(points = [(-1.5, -3.72), (-0.8, -3.72)], linewidth = 0.1, endstyle='>', linecolor='red')
p += Line(points = [(13, -3.72), (13.7, -3.72)], linewidth = 0.1, linecolor='red')
p += Line(points = [(13.7, -3.72), (13.7, -5.1)], linewidth = 0.1, linecolor='red')
p += Line(points = [(13.7, -5.1), (-1.5, -5.1)], linewidth = 0.1, linecolor='red')
p += Line(points = [(-1.5, -5.1), (-1.5, -6.3)], linewidth = 0.1, linecolor='red')
p += Line(points = [(-1.5, -6.3),(-0.8, -6.3)], linewidth = 0.1, endstyle='>', linecolor='red')
p += Line(points = [(13, -11), (13.7, -11)], linewidth = 0.1, linecolor='red')
p += Line(points = [(13.7, -11), (13.7, -13.9)], linewidth = 0.1, linecolor='red')
p += Line(points = [(13.7, -13.9), (-1.5, -13.9)], linewidth = 0.1, linecolor='red')
p += Line(points = [(-1.5, -13.9), (-1.5, -15.7)], linewidth = 0.1, linecolor='red')
p += Line(points = [(-1.5, -15.7), (-0.8, -15.7)], linewidth = 0.1, endstyle='>', linecolor='red')


p += Line(points = [(2.5, -7.22), (2.5, -8.22)], linewidth=0.1, linecolor='red')
p += Line(points = [(2.5, -8.22), (-0.1, -8.22)], linewidth=0.1, linecolor='red')
p += Line(points = [(-0.1, -8.22), (-0.1, -12.6)], linewidth=0.1, linecolor='red')
p += Line(points = [(-0.1, -12.6), (0.8, -12.6)], linewidth=0.1, endstyle='>', linecolor='red')
p += Line(points = [(11.9, -12.6), (13, -12.6)], linewidth=0.1, endstyle='>', linecolor='red')
p += Line(points = [(-0.1, -9.6), (0.45, -9.6)], endstyle='>', linewidth=0.1, linecolor='red')
p += Line(points = [(12.2, -9.6), (13, -9.6)], endstyle='>', linewidth=0.1, linecolor='red')

p += Rect(-0.8, -1.2, 13, -0.22, linecolor='red', linewidth=0.1, name='b1')
p += Rect(-0.8, -4.2, 13, -3.22, linecolor='red', linewidth=0.1, name='b2')
p += Rect(-0.8, -13.6, 13, -5.8, linecolor='red', linewidth=0.1, name='b3')
p += Rect(0.8, -7.22, 3.5, -6.22, linecolor='red', linewidth=0.1, name='b4')
p += Rect(0.45, -10.2, 12.2, -9.22, linecolor='red', linewidth=0.1, name='b5')
p += Rect(-0.8, -16.1, 13, -15.1, linecolor='red', linewidth=0.1, name='b6')
p += Rect(0.8, -13.2, 12, -12.2, linecolor='red', linewidth=0.1, name='b7') 

code(p, M, x=0, y=0, height=1.5, width=0.33, border_linewidth=0.01, innersep=0.8)

print(p)
\end{python}
\newpage\EMPHASIZE{Multiplication game: Part 2}

Recall our multiplication game that tests if the user can multiply 97
and 94. Here's an execution of the program:
\begin{console}[commandchars=\~\@\$]
What is the product of 97 and 94? ~textbf@1$ 
\end{console}
Here's another:
\begin{console}[commandchars=\~\@\$]
What is the product of 97 and 94? ~textbf@9118$
You smart dawg!
\end{console}

Here's the pseudocode:
\begin{align*}
& \texttt{Declare integer variable guess}\\
& \texttt{Print a prompt string to user}\\
& \texttt{Prompt user for integer value for guess}\\
& \texttt{If guess is 9118}\\
& \tab[3em]{\texttt{print congratulatory message}}\\
\end{align*}

Now improve the program so that it does the following:
\begin{align*}
& \texttt{Declare integer variable guess}\\
& \texttt{Print a prompt string to user}\\
& \texttt{Prompt user for integer value for guess}\\
& \texttt{If guess is 9118}\\
& \tab[3em]{\texttt{print congratulatory message}}\\
& \textbf{\texttt{Otherwise}}\\
& \textbf{\tab[3em]{\texttt{print the correct answer}}}\\
\end{align*}
Here's an execution:\\
\begin{console}[commandchars=\~\@\$]
What is the product of 97 and 94? ~textbf@1$
Nope ... it's 9118.
\end{console}
Here's another:\\
\begin{console}[commandchars=\~\@\$]
What is the product of 97 and 94? ~textbf@9118$
You smart dawg!
\end{console}

\newpage\EMPHASIZE{Multiplication game: Part 3}

We're going to sell our multiplication game. But no one
is going to buy it if all it does is to ask the same question again and
again!

Modify your program so that the program prompts the user for the product
of two integers between 90 and 99. The integers should be randomly
generated.

The pseudocode becomes:
\begin{align*}
&\textbf{\texttt{Generate two random integers between 90 and 99}}\\
&\tab[3em]{\texttt{\textbf{and give the values to variables x and y}}}\\
&\textbf{\texttt{Print a prompt string to user to guess the}}\\
&\tab[3em]{\texttt{\textbf{product of x and y}}}\\\\
&\texttt{Declare integer variable guess}\\
&\texttt{Prompt user for integer value for guess}\\\\
&\texttt{If guess is \textbf{the product of x and y}}\\
&\tab[3em]{\texttt{print congratulatory message}}\\
&\texttt{Otherwise}\\
&\tab[3em]{\texttt{print \textbf{the product of x and y}}}\\
\end{align*}
Note the value of the product of x and y occurs twice. We can compute
the product just once and store it in a variable:
\begin{align*}
&{\texttt{Generate two random integers between 90 and 99}}\\
&\tab[3em]{\texttt{{and give the values to variables x and y}}}\\
&\textbf{\texttt{Print a prompt string to user to guess the}}\\
&\tab[3em]{\texttt{\textbf{product of x and y}}}\\\\
&\texttt{Declare integer variable guess}\\
&\texttt{Prompt user for integer value for guess}\\\\
&\texttt{If guess is \textbf{answer}}\\
&\tab[3em]{\texttt{print congratulatory message}}\\
&\texttt{Otherwise}\\
&\tab[3em]{\texttt{print \textbf{answer}}}
\end{align*}
To test your program you need to know the answer. So just get the
program to print the answer temporarily before prompting the user. You
can get rid of revealing the answer when you have fully tested your
code.

Here's an execution of the program:\\
\begin{console}[commandchars=\~\@\$]
What is the product of 91 and 94? (answer: 8554) ~textbf@1$
Nope ... it's 8554
\end{console}

Here's another execution of the same program:\\
\begin{console}[commandchars=\~\@\$]
What is the product of 96 and 94? (answer: 9024) ~textbf@9024$
You smart dawg!
\end{console}
Of course after it works you get rid of the \texttt{(answer: ...)} output
and the execution becomes:

\begin{console}[commandchars=\~\@\$]
What is the product of 91 and 94? (answer: 8554) ~textbf@1$
Nope ... it's 8554
\end{console}
\begin{console}[commandchars=\~\@\$]
What is the product of 96 and 94? (answer: 9024) ~textbf@9024$
You smart dawg!
\end{console}

\newpage\EMPHASIZE{\texttt{if-else} blocks}

It should not be too surprising that you can execute blocks for if-else.
You can have a block controlled by the if-part, or a block controlled by
the else-part, or both.

\begin{console}
std::cout << "Head Surgery Cost Planner \n"
          << "First 3: \$100 each. \n"
          << "After that: \$2 each. \n"
          << "Less than 3: extra 500 charge"
          << std::endl;

int extraHeads = 0;
int cost = 0;
std::cout  "How many extra heads do you want? ";
std::cin >> extraHeads;
if (extraHeads <= 3)
{
        cost = extraHeads * 100 + 500;
        std::cout << "Please go to Cheapskate Room."
                  << std::endl;
}
else
{
        cost = 3 * 100 + (extraHeads - 3) * 2;
        std::cout << "Please go to Deluxe Room."
                  << std::endl;
}
\end{console}
\begin{ex}
Once you see code like the above you immediately ask
yourself this question: How many constants do you see in the above
program? (I can see four). Rewrite it with constants instead of
hard-coding integer values.
\end{ex}
\begin{ex}
Write a program that computes the area of either a
circle or a right-angle triangle. Recall that you can declare character
variables. It turns out that you can compare character values too, using
the \texttt{==} operator. The type for the character values is
\texttt{char}. Here's a code skeleton for you:
\begin{console}
std::cout << "Area Calculator!!! \n";
std::cout << "I can do circles or triangles! \n"
          << "Option (c or t): ";
char >> option;
std::cin >> option;
if (option == 'c')
{
        // Prompt the user for radius and display the
        // area of the circle with the given radius.
}
else    // if it's not 'c', assume it is 't'
{
        // Prompt the user for the base and height of
        // the right-angled triangle and display the
        // area.
}
\end{console}
\end{ex}

\newpage\EMPHASIZE{Coding style for \texttt{if} and \texttt{if}-\texttt{else}}

\textbf{ONE SPACE AFTER if:}
BAD (but practiced by some)
\begin{console}
if(x < 0)
     foo = 1;  
\end{console}

GOOD
\begin{console}
if (x < 0)
   foo = 1;  
\end{console}

\textbf{ONE-LINE if:}

It's OK to write a one-line if statement if the body is
a short statement and not a block and it improves readability.

OK BUT YUCKY:
\begin{console}
x = 0;

if (x < 0)
    y = 0; 
\end{console}

BETTER
\begin{console}
x = 0;
if (x < 0) y = 0; 
\end{console}

\newpage\EMPHASIZE{Maximum/minimum computation}

Trace this (very very very important program by hand). Understand what
it does. Finally rewrite it using the one-line if format.\\
\begin{console}
int w = 1, x = 3, y = 0, z = 5;
int max;
max = w;
if (max < x)
   max = x;
if (max < y)
   max = y;
if (max < z)
   max = z; 
\end{console}

Note that you can also use the bubblesort algorithm to compute the
maximum value in w, x, y, z. However the above maximum computation
algorithm does not require swapping values (the values in w, x, y, z are
not changed) and therefore it uses less computation.

\begin{ex}
Write a program that prompts the user for 6 integer
values, prints the 6 values, and then prints the maximum of the 6
values.
\end{ex}
\begin{ex} Refer to the previous exercise. What happens when you
change all the $<$ to the $>$ operator? (This is also very very very important).
\end{ex}

\newpage\EMPHASIZE{Coding style for blocks}

\textbf{ALIGN BLOCK DELIMITERS TO HEADER:}

BAD (but used by some and is common in Java):
\begin{console}
int main() {
    return 0;
}  
\end{console}
and\\
\begin{console}
if (x < 0) {
   foo = 42;
   bar = 43;
} 
\end{console}

HORRIFYING:\\
\begin{console}
if (x < 0)
   {
   foo = 42;
   bar = 43;
   } 
\end{console}

ABOMINABLE:
\begin{console}
if (x < 0)
   {
        foo = 42;
        bar = 43;
   } 
\end{console}

GOOD:
\begin{console}
int main()
{
    return 0;
}  
\end{console}

and
\begin{console}
if (x < 0)
{
    foo = 42;
    bar = 43;
} 
\end{console}

The same applies to if-else:

BAD
\begin{console}
if (x < 0) {
    foo = 42;
    bar = 43;
}
else {
    foo = 43;
    bar = 42;
}
\end{console}
GOOD
\begin{console}
if (x < 0)
{  
    foo = 42;
    bar = 43;
}
else
{       
    foo = 43;
    bar = 42;
}
\end{console}

\textbf{ALWAYS USE BLOCKS IF NOT ONE-LINERS:}

C/C++ programmers tend to use blocks even when the block has only one
statement except when using the one-line if style. This creates a
unified look and prevents difficult-to-find bugs caused by \lq\lq dangling
else'' (see later).

OK BUT NOT COMMON:
\begin{console}
if (x < 0)
   foo = 42;
else
   foo = 24; 
\end{console}

COMMON:
\begin{console}
if (x < 0)
{
    foo = 42;
}
else
{
    foo = 42;
}
\end{console}
\newpage\EMPHASIZE{Boolean expressions again}

We started with boolean expressions such as

\[x > 0\]

and went on to expressions such as

\[x > y\]

and then to

\[x * x + y * y != 0\]

and finally to

\[\texttt{a * a + b * b  c * c + d * d}\]

i.e.
\begin{center}
\EMPHASIZE{\texttt{[expr1] [boolop] [expr2]}}
\end{center}
where \texttt{[expr1]} and \texttt{[expr2]} are boolean expressions
and \texttt{[boolop]} is a binary boolean operator accepting two
numeric values. Let's recall a few more binary operators.

First of all let's not forget that we also have the unary ! operator. The following prints x if \textbf{it is not true that x is 0}.
\begin{console}[commandchars=\~\@\$]
int x = 0;
std::cin >> x;
if (~textbf@!(x == 0)$)
   std::cout << x << std::endl; 
\end{console}

\begin{ex}
Rewrite the above program so that the ! operator is
not used. Your resulting program therefore has to evaluate one boolean
operator and not two.
\end{ex}
\begin{ex}
Simplify the boolean expression in the program so
that the program behaves the same after your modification:
\begin{console}
int x = 0;
std::cin >> x;
if (!(x <= 42) || !(x >= 42))
   std::cout << x << std::endl;
\end{console}
\end{ex}

But note you should not simplify expressions (boolean or numeric) if by
doing so it makes your program harder to read. Furthermore, modern-day
compilers are actually smart enough to simplify it for you
automatically!

Of course we also have the boolean operators \texttt{\&\&} and
\texttt{\textbar\textbar}. So we can have the following boolean
expression:
\begin{center}
$(x < y)$   \&\&  $(y < z)$
\end{center}
Note that \texttt{(x < y)} and \texttt{(y < z)} are
boolean expressions. So in general we can have
\begin{center}
\EMPHASIZE{\texttt{[boolexpr1] [boolop] [boolexpr2]}}
\end{center}
where \texttt{[boolexpr1]} and \texttt{[boolexpr2]} are boolean
expressions and \texttt{[boolop]} is either \&\& or \textbar\textbar.

This should be a DIY review:

\begin{ex}
Complete the truth table for \&\&:

\begin{align*}
& \text{true \&\& true is \_\_\_\_\_}\\
& \text{true \&\& false is \_\_\_\_\_}\\
& \text{false \&\& true is \_\_\_\_\_}\\
& \text{false \&\& false is \_\_\_\_\_}\\
\end{align*}
\end{ex}

\begin{ex}
Complete the truth table for \textbar\textbar:

\begin{align*}
& \text{true \textbar\textbar true is \_\_\_\_\_}\\
& \text{true \textbar\textbar false is \_\_\_\_\_}\\
& \text{false \textbar\textbar true is \_\_\_\_\_}\\
& \text{false \textbar\textbar false is \_\_\_\_\_}\\
\end{align*}
\end{ex}
You should check with your previous notes.

\begin{ex}
You qualify for free head surgery if you have one
head, less than three arms, more fingers on your left than you right
hand, and finally either you are from Earth or the product of your
highest level reached on Pacman and Galaxian is less than 6 (obviously
you need an extra head in that case ...) Of course if you have not
played Pacman, your high level is 0; likewise for Galaxian. Complete
this program:
\begin{console}
int numHeads = 0;
int numArms = 0;
int numLeftFingers = 0;
int numRightFingers = 0;
bool earthling = true;
int pacManLevel = 0;
int galaxianLevel = 0;

// prompt for values for all variables
// For boolean variable enter 1 for true and 0 for false

if (                             )
std::cout << "You qualify for our free head surgery!"
          << std::endl;
else
std::cout << "Try again at newheads.com" << std::endl;
\end{console}
\end{ex}
You should create some test cases by hand and then test your code
against your test cases.

\newpage\EMPHASIZE{Nested \texttt{if}-\texttt{else}}

Now the plot thickens. Since we can put any statement inside an \texttt{if} or an \texttt{else}, and \texttt{if} and \texttt{if}-\texttt{else} are themselves statements, that means that we can nest if and if-else statements.

That's mind-boggling. Let's have an example.

Run this with input 1. Run it again with input 2. Repeat that with 3.
Finally try it with -1.
\begin{console}
int numHeads = 0;
std::cout << "How many heads do you have? " << std::endl;
std::cout << numHeads;

if (numHeads == 1)
{
    std::cout << "Let me introduce you to our surgeons."
              << std::endl;
}
else
{
    if (numHeads == 2)
    {
        std::cout << "Are you Zaphod?" << std::endl;
    }
    else
    {
        std::cout << "Hmm ... neither 1 nor 2 ..."
                  << std::endl;
    }
}
\end{console}

\begin{ex}
Draw a picture showing the flow of execution of the
above code segment.
\end{ex}
Here's another example. Run this with inputs 1, 2, 3,
-1.

\begin{console}[commandchars=\~\@\$]
int numHeads = 0;
std::cout << "How many heads do you have? ");
std::cin >> numHeads;
~textbf@if (numHeads < 1)$
~textbf@{$
   ~textbf@std::cout << "Huh?" << std::endl;$
~textbf@}$
~textbf@else$
~textbf@{$
   if (numHeads == 1)
   {
      std::cout << "Let me introduce you to our "
                << "surgeons." << std::endl;
   }
   else
   {
        if (numHeads == 2)
        {
            std::cout << "Are you Zaphod?");
        }
        else
        {
            std::cout << "You have way too many."
                      << std::endl;
        }
   }
~textbf@}$
\end{console}


\begin{ex}
What is the output when x has value 0.
\begin{console}
if (x < 5)
{
    std::cout << "1" << std::endl;
}
else
{
    if (x == 0)
    {
        std::cout << "2" << std::endl;
    }
    else
    {
        if (x > 42)
        {
            std::cout << "3" << std::endl;
        }
    }
}
\end{console}
\end{ex}
By the way look at this program:
\begin{console}
if (score < 100)
{
    std::cout << "lousy gamer" << std::endl;
}
else
{
    if (100 <= score && score < 200)
    {
        std::cout << "not bad" << std::endl;
    }
    else
    {
        if (200 <= score)
        {
            std::cout << "great!" << std::endl;
        }
     }
}
\end{console}
Do you see why the above is the same as:
\begin{console}[commandchars=\~\@\$]
if (score < 100)
{
    std::cout << "lousy gamer" << std::endl;
}
else
{
    ~textbf@if (score < 200)$
    {
        std::cout << "not bad" << std::endl;
    }
    else
    {
        if (200 <= score)
        {
            std::cout << "great!" << std::endl;
        }
     }
}
\end{console}

\begin{ex}
Write a program that prompts the user for his/her
age. If the age is less than 10, print \lq\lq read the hobbit'', if
it's between 11 and 15, print \lq\lq read lord of the ring'',
if it's 16, print \lq\lq read hitchhiker's
guide to the galaxy'', and otherwise, print \lq\lq read chica chica boom
boom''.
\end{ex}
\begin{ex}
Write a program that converts a numeric grade to a
letter grade. The program prompts the user for a double, and if the
double is less than 60, it prints 'F; if
it is at least 60 but less than 70, it prints
'D;if it is at least 70 but less than
80, it prints 'C;if it is at least 80
but less than 90, it prints 'B; and if
it's at least 90, it prints
'A.
\end{ex}

\newpage\EMPHASIZE{The dangling else problem}

Here's a trick question (and it's another reason why C/C++/Java programmers use { } even when the block has only one statement). So ...
\begin{center}
\EMPHASIZE{PAY ATTENTION}
\end{center}
First figure out the output (without a compiler) when x has a value of
0.

\begin{console}
if (x  0)
   if (x == -2) std::cout << "1" << std::endl;
else
   std::cout << "2" << std::endl; 
\end{console}
Now run the program.

Mamamia ... ?!?

This is called the \lq\lq dangling else'' problem.

What actually happens is that an \texttt{else} always follows the closest
\texttt{if}. This means that the above code is better indented this way:
\begin{console}
if (x  0)
   if (x == -2) std::cout << "1" << std::endl;
   else
       std::cout << "2" << std::endl; 
\end{console}

Of course the C++ compiler doesn't care about
whitespaces. However this version of indentation makes it easier for
human beings to follow the logic.

Now if what I intended was actually something like the previous version,
then I would have to do this:
\begin{console}
if (x  0)
{
   if (x == -2) std::cout << "1" << std::endl;
}
else
    std::cout << "2" << std::endl; 
\end{console}
In this case, the closest if-part that the else-part can attach to is
the if-part on the first line since the else-part cannot \lq\lq go inside''
the block.

This is the reason why it's a good practice to ALWAYS
use blocks even when the if-part or the else-part has only one line to
execute. It prevents the misleading dangling else problem. So if I write
this:
\begin{console}
if (x  0)
{
   if (x == -2)
   {
       std::cout << "1" << std::endl;
   }
}
else
{
     std::cout << "2" << std::endl;
}
\end{console}

there will be no confusion.

\newpage\EMPHASIZE{Coding style for nested \texttt{if}-\texttt{else}}

NOT SO GOOD:\\
\begin{console}
if (x < 5)
{
    foo = 42;
}
else
{
     if (x < 8)
     {
         foo = 43;
     }
     else
     {
         if (x == 9)
         {
             foo = 44;
         }
         else
         {
             foo = 45;
         }
     }
}
\end{console}
GOOD:\\
\begin{console}
if (x < 5)
{
    foo = 42;
}
else if (x < 8)
{
    foo = 43;
}
else if (x == 9)
{
    foo = 44;
}
else
{
    foo = 45;
}
\end{console}

\begin{ex}
Rewrite your previous program:
\begin{console}

int numHeads = 0;
std::cout << "How many heads do you have? ");
std::cin >> numHeads;
if (numHeads < 1)
{
   std::cout << "Huh?" << std::endl;
}
else
{
   if (numHeads == 1)
   {
      std::cout << "Let me introduce you to our "
                << "surgeons." << std::endl;
   }
   else
   {
        if (numHeads == 2)
        {
            std::cout << "Are you Zaphod?");
        }
        else
        {
            std::cout << "You have way too many."
                      << std::endl;
        }
   }
}
\end{console}
using the above format.
\end{ex}

\newpage\EMPHASIZE{Multiplication game: Part 4}

Here comes one more improvement to our multiplication game. We're going to give the user a second chance. Furthermore we'll give a hint. We will tell him/her is his/her answer is too high or too low. If the user gets the correct answer the first time, we'll give 2 points. If the user gets it right the second time, we'll give 1 point. Otherwise we'll give zero. (What else can you give anyway?)

Here's the pseudocode:
\begin{align*}
&\texttt{Generate two random integers between 90 and 99}\\
&\tab[3em]{\texttt{and give the values to variables x and y}}\\
&\texttt{Store the product of x and y in variable answer}\\
&\texttt{Print a prompt string to user to guess the}\\
&\tab[3em]{\texttt{product of x and y}}\\\\
&\texttt{\textbf{Declare integer variable score and initialize it}}\\
&\tab[3em]{\textbf{\texttt{to 0}}}\\\\
&\texttt{Declare integer variable guess}\\
&\texttt{Prompt user for integer value for guess}\\\\
&\texttt{If guess is answer}\\
&\tab[3em]{\texttt{Print congratulatory message}}\\
&\tab[3em]{\texttt{score = 2}}\\
&\textbf{\texttt{Otherwise if guess is less than the answer:}}\\
&\tab[3em]{\textbf{\texttt{Tell user the guess is too low}}}\\
&\tab[3em]{\textbf{\texttt{Print a prompt string to user to guess}}}\\
&\tab[6em]{\textbf{\texttt{the product of x and y}}}\\
&\tab[3em]{\textbf{\texttt{If guess is answer}}}\\
&\tab[6em]{\textbf{\texttt{print congratulatory message}}}\\
&\tab[6em]{\textbf{\texttt{score = 1}}}\\
&\tab[3em]{\textbf{\texttt{Otherwise}}}\\
&\tab[6em]{\textbf{\texttt{print answer}}}\\
&\textbf{\texttt{Otherwise if guess is greater than the answer:}}\\
&\tab[3em]{\textbf{\texttt{Tell user the guess is too high}}}\\
&\tab[3em]{\textbf{\texttt{Print a prompt string to user to guess}}}\\
&\tab[6em]{\textbf{\texttt{the product of x and y}}}\\
&\tab[3em]{\textbf{\texttt{If guess is answer}}}\\
&\tab[6em]{\textbf{\texttt{print congratulatory message}}}\\
&\tab[3em]{\textbf{\texttt{score = 1}}}\\
&\tab[3em]{\textbf{\texttt{Otherwise}}}\\
&\tab[6em]{\textbf{\texttt{print answer}}}\\\\
&\texttt{Print user's score}\\
\end{align*}
Here are several executions to give you a feel for what the program
should do:

Case: correct\\
\begin{console}[commandchars=\~\@\$]
What is the product of 91 and 94? (answer: 8554) ~textbf@8554$
You smart dawg!
Score: 2 
\end{console}

Case: low-low\\
\begin{console}[commandchars=\~\@\$]
What is the product of 91 and 94? (answer: 8554) ~textbf@1$
Too low!
What is the product of 91 and 94? (answer: 8554) ~textbf@1$
Nope ... it's 8554
Score: 0 
\end{console}

Case: low-correct\\
\begin{console}[commandchars=\~\@\$]
What is the product of 91 and 94? (answer: 8554) ~textbf@1$
Too low!
What is the product of 91 and 94? (answer: 8554) ~textbf@8554$
You smart dawg!
Score: 1 
\end{console}

Case: low-high\\
\begin{console}[commandchars=\~\@\$]
What is the product of 91 and 94? (answer: 8554) ~textbf@1$
Too low!
What is the product of 91 and 94? (answer: 8554) ~textbf@9000$
Nope ... it's 8554
Score: 0
\end{console}

Case: high-low\\
\begin{console}[commandchars=\~\@\$]
What is the product of 91 and 94? (answer: 8554) ~textbf@9000$
Too high!
What is the product of 91 and 94? (answer: 8554) ~textbf@1$
Nope ... it's 8554
Score: 0
\end{console}

Case: high-correct\\
\begin{console}[commandchars=\~\@\$]
What is the product of 91 and 94? (answer: 8554) ~textbf@9000$
Too high!
What is the product of 91 and 94? (answer: 8554) ~textbf@8554$
You smart dawg!
Score: 1
\end{console}


\newpage\EMPHASIZE{Cleanup -- refactoring}

In writing software, even when you're done, you should
look at your code to see if you can improve on it. You do not want to
change the behavior of the code. Rather you want to reorganize the code
to make it easier to read or to make it more efficient. Such an activity
is called \EMPHASIZE{refactoring}.

This is something that all problem-solving processes involve, not just
software development. In particular, this occurs a lot in fundamental
research as well. For instance mathematicians always rewrite their
proofs to improve the readability. Sometimes mathematicians will even
derive different proofs of the same result in order to see things in a
totally different way. Anyway, let's get back to
programming.

You realized that there is a lot of duplicate code. There is a lot of
duplication when the program gives the user a second try:

\begin{align*}
&\texttt{Generate two random integers between 90 and 99}\\
&\tab[3em]{\texttt{and give the values to variables x and y}}\\
&\texttt{Store the product of x and y in variable answer}\\
&\texttt{Print a prompt string to user to guess the}\\
&\tab[3em]{\texttt{product of x and y}}\\\\
&\texttt{Declare integer variable score and initialize it}\\
&\tab[3em]{\texttt{to 0}}\\\\
&\texttt{Declare integer variable guess}\\
&\texttt{Prompt user for integer value for guess}\\\\
&\texttt{If guess is answer}\\
&\tab[3em]{\texttt{Print congratulatory message}}\\
&\tab[3em]{\texttt{score = 2}}\\
&\texttt{Otherwise if guess is less than the answer:}\\
&\tab[3em]{\texttt{Tell user the guess is too low}}\\
&\tab[3em]{\texttt{Print a prompt string to user to guess}}\\
&\tab[6em]{\texttt{the product of x and y}}\\
&\tab[3em]{\texttt{If guess is answer}}\\
&\tab[6em]{\texttt{print congratulatory message}}\\
&\tab[6em]{\texttt{score = 1}}\\
&\tab[3em]{\texttt{Otherwise}}\\
&\tab[6em]{\texttt{print answer}}\\
&\texttt{Otherwise if guess is greater than the answer:}\\
&\tab[3em]{\texttt{Tell user the guess is too high}}\\
&\tab[3em]{\texttt{Print a prompt string to user to guess}}\\
&\tab[6em]{\texttt{the product of x and y}}\\
&\tab[3em]{\texttt{If guess is answer}}\\
&\tab[6em]{\texttt{print congratulatory message}}\\
&\tab[3em]{\texttt{score = 1}}\\
&\tab[3em]{\texttt{Otherwise}}\\
&\tab[6em]{\texttt{print answer}}\\\\
&\texttt{Print user's score}\\
\end{align*}

Not everything is similar between the two chunks of code. But you can
see that the similarities is around this spot:\\
\begin{align*}
&\texttt{If guess is answer}\\
&\tab[3em]{\texttt{print congratulatory message}}\\
&\tab[3em]{\texttt{score = 2}}\\
&\texttt{Otherwise if guess is less than the answer:}\\
&\tab[3em]{\texttt{Tell user the guess is too low}}\\
&\tab[3em]{\texttt{\textbf{Print a prompt string to user to guess}}}\\
&\tab[6em]{\texttt{\textbf{the product of x and y}}}\\
&\tab[3em]\texttt{\textbf{If guess is answer}}\\
&\tab[6em]{\texttt{\textbf{print congratulatory message}}}\\
&\tab[6em]{\texttt{\textbf{score = 1}}}\\
&\tab[3em]{\texttt{\textbf{Otherwise}}}\\
&\tab[6em]{\texttt{\textbf{print answer}}}\\
&\texttt{Otherwise if guess is greater than the answer:}\\
&\tab[3em]{\texttt{Tell the user the guess is too low}}\\
&\tab[3em]{\texttt{\textbf{Print a prompt string to user to guess}}}\\
&\tab[6em]{\texttt{\textbf{the product of x and y}}}\\
&\tab[3em]{\texttt{\textbf{If guess is answer}}}\\
&\tab[6em]{\texttt{\textbf{print congratulatory message}}}\\
&\tab[6em]{\texttt{\textbf{score = 1}}}\\
&\tab[3em]{\texttt{\textbf{Otherwise}}}\\
&\tab[6em]{\texttt{\textbf{print answer}}}\\
\end{align*}
We want to write one chunk of code and not two. To combine the chunks
(they reside under two different boolean conditions right now) we need
to have a common condition for both -- and that's when
the first guess is incorrect:
\begin{align*}
& \texttt{If guess is answer}\\
& \tab[3em]{\texttt{Print congratulatory message}}\\
& \tab[3em]{\texttt{score = 2}}\\
& \texttt{Otherwise}\\
& \tab[3em]{\texttt{\textbf{If guess is less than the answer:}}}\\
& \tab[3em]{\texttt{\textbf{Tell user the guess is too low}}}\\
& \tab[3em]{\texttt{\textbf{Otherwise}}}\\
& \tab[6em]{\texttt{\textbf{Tell user the guess is too high}}}\\
& \tab[3em]{\texttt{\textbf{Print a prompt string to user to guess}}}\\
& \tab[6em]{\texttt{\textbf{the product of x and y}}}\\
& \tab[3em]{\texttt{\textbf{If guess is answer}}}\\
& \tab[6em]{\texttt{\textbf{print congratulatory message}}}\\
& \tab[6em]{\texttt{\textbf{score = 1}}}\\
& \tab[3em]{\texttt{\textbf{Otherwise}}}\\
& \tab[6em]{\texttt{\textbf{print answer}}}\\
& \texttt{Print user's score}\\
\end{align*}
Now using this pseudocode, clean up your program and see how many lines
of code shorter your program gets.

\newpage\EMPHASIZE{Find computation}

Suppose you're a bunch of integer values in variables,
say
\begin{center}
\texttt{a}, \texttt{b}, \texttt{c}, \texttt{d}
\end{center}
and you're interested in who has a particular value. If
the target value is in a, you want to print 0. If it's
in b, you want to print 1, etc. In other words, we think of a has having
position 0 and if the target value is found in a, we think of the target
at position 0. I will save the position in the variable \texttt{index}.
The code would look like this:\\
\begin{console}
if (target == a)
{
    index = 0;
}
else if (target == b)
{
    index = 1;
}
else if (target == c)
{
    index = 2;
}
else if (target == d)
{
    index = 3;
}
std::cout << index << '\n';
\end{console}
If the target is not found in a, b, c, d, we will set \texttt{index} to -1:\\
\begin{console}
if (target == a)
{
    index = 0;
}
else if (target == b)
{
    index = 1;
}
else if (target == c)
{
    index = 2;
}
else if (target == d)
{
    index = 3;
}
else
{
    index = -1;
}
std::cout << index << '\n';
\end{console}

\begin{ex}
Complete the program by prompting the user for
\texttt{a}, \texttt{b}, \texttt{c}, \texttt{d} and target and print
\texttt{index}.
\end{ex}
\begin{ex}
Do the same as above but prompt the user for 5
integer values \texttt{a}, \texttt{b}, \texttt{c}, \texttt{d}, \texttt{e}.
\end{ex}
\begin{ex}
Note that the above finds the position of a value by
searching from the first variable to the last (\texttt{a} to \texttt{d}).
What if you search backwards? For instance if the target value is found
in both \texttt{a} and \texttt{d}, your program should print 3 and not 0.
\end{ex}

Make sure you understand and remember this algorithm.

\newpage\EMPHASIZE{Count computation}

Suppose you have 4 integer variables (say \texttt{a}, \texttt{b}, \texttt{c},
\texttt{d}) and you want to count the number of times a value (say in
\texttt{target}) occurs in these integer variables. The pseudocode would
look like this:\\
\begin{console}
count = 0
if target == a:
   increment count by 1
if target == b:
   increment count by 1
if target == c:
   increment count by 1
if target == d:
   increment count by 1
print count 
\end{console}

\begin{ex}
Write a program that prompts the user for 4 integers,
stores them in variables, \texttt{a}, \texttt{b}, \texttt{c}, \texttt{d}. The
program then prompts the user for an integer value and stores it in
\texttt{target}. Convert the above pseudocode into C++ and print
\texttt{count}.
\end{ex}

Make sure you understand and remember this algorithm.

\newpage\EMPHASIZE{Typecast between \texttt{bool} and \texttt{int}s}

And don't forget that, when needed, C++ will
automatically type cast boolean values to integers by casting the value
true to 1 and false to 0. C++ will also can also type cast numeric
values (ints, doubles, floats) to boolean values by casting nonzero
values to true and zero to false:

\begin{align*}
&\texttt{bool} \implies &\texttt{int}\\
&\texttt{true} &1\\
&\texttt{false} &0\\\\
&\text{numeric (int/double/float)} \implies &\texttt{bool}\\
&\text{nonzero (example: 1, 2, 3)} &\texttt{true}\\
&\text{zero (example: 0, 0.0)} &\texttt{false}\\
\end{align*}

Try this:\\
\begin{console}
if (1)
std::cout << "i'm the queen of england"
          << std::endl; 
\end{console}

Change 1 to 4 and run the program again.

(The above is not a random example. It's important
because we're going into loops very soon.)

\begin{ex}
What is the boolean value of 1 \&\& 2? What about 1 \&\& 0? Do it \lq\lq by hand''. Next verify your computation by running this:\\
\begin{console}
std::cout << (1 \&\& 2) << std::endl;
std::cout << (1 \&\& 0) << std::endl; 
\end{console}
\end{ex}

I also warn you again that type casting does not change the value of a
variable:\\
\begin{console}
int x = 42;
std::cout << (x \&\& 1) << std::endl;
std::cout << x << std::endl; 
\end{console}

(The value of \texttt{x} is type cast to \texttt{true}. \texttt{x} is still 42.)

This is really the same as calling the \texttt{sqrt()} (square root) function with a variable. The value of the variable is not changed.
\begin{console}
double x = 2.0;
std::cout << x << std::endl;
std::cout << sqrt(x) << std::endl;
std::cout << x << std::endl; 
\end{console}
\newpage\EMPHASIZE{Assignment based on conditions}

Here's a trick to simplify an assignment via an
\texttt{if}-\texttt{else} statement. Suppose you have this program:\\
\begin{console}
bool newMember = true;
double loanRate = 0.0;

if (newMember)
   loanRate = 0.01;
else
   loanRate = 0.20;

// Yeah that's what credit cards companies do ... 
\end{console}

You can rewrite this as:
\begin{console}
bool newMember = true;
double loanRate = 0.01;
if (!newMember)
   loanRate = 0.20; 
\end{console}

Yet another way to do this is:
\begin{console}
bool newMember = true;
double loanRate = newMember * 0.01
                  + (!newMember) * 0.20; 
\end{console}

There is however a \EMPHASIZE{problem} with this technique and some disapprove of it. That is, you're using a boolean value (true or false) as a numeric value (1 or 0). Some people believes that automatic type casting like this is dangerous and misleading and that \EMPHASIZE{types should be kept as separate as possible}.

To make such people happy (example: your tech leader / manager might be one) and also not to mislead the reader, you should always \EMPHASIZE{explicitly type cast}. For instance above should be written:\\
\begin{console}
bool newMember = true;
double loanRate = int(newMember) * 0.01
                  + int(!newMember) * 0.20; 
\end{console}

\begin{ex}
Write a program that gives the variable
\texttt{heartAttackRate} 0.01, 0.02, 0.03, and 0.94 depending on whether
\texttt{numHeads} is 1, 2, 3 or at least 4 (respectively). Complete this:
\begin{console}
int numHeads = 0;
std::cin >> numHeads;
double heartAttackRate = ___________________________
std::cout << heartAttackRate << std::endl;}  
\end{console}
\end{ex}
\newpage\EMPHASIZE{The ternary operator}

So far our operators accept one value, for example:
\begin{align*}
&\text{$-$y}\\
&\text{!b}\\
\end{align*}
or two values, for example:
\begin{align*}
& \text{x + y}\\
& \text{b1 \&\& b2}\\
\end{align*}
There is a curious operator that accepts \texttt{\textbf{three}}. Try this
program:
\begin{console}
int x = 5;
std::cout << (x == 5 ? 42 : 0) << std::endl; 
\end{console}

Run this with different values for variable x.

Get the point of the \texttt{(?:)} operator yet? The format looks like
this:
\begin{center}
\EMPHASIZE{(\texttt{[bool expr} ? \texttt{[expr1} : \texttt{[expr2})}
\end{center}
Basically, if the \texttt{[bool expr} (a boolean expression)
evaluates to \texttt{true}, C++ will evaluate \texttt{[expr1} and give
you its value; otherwise it gives you the value from \texttt{[expr2}.

Here's another example. First try to guess what the
program does. Next run it to verify.
\begin{console}[commandchars=\~\@\$]
int x = 0, y = 1, z = 2;

~textbf@int a = (x + y  z ? x : y + z);$
std::cout << a << std::endl;
\end{console}

Do you see that it does the same thing as this:
\begin{console}[commandchars=\~\@\$]
int x = 0, y = 1, z = 2;

int a = 0;
~textbf@if (x + y < z)$
~textbf@{$
    ~textbf@a = x;$
~textbf@}$
~textbf@else$
~textbf@{$
    ~textbf@a = y + z;$
~textbf@}$
std::cout << a << std::endl; 
\end{console}

Here's another example. Try this die game:
\begin{console}
int die_roll = 1 + rand() % 6 ;
std::cout << "value of die roll: " <<
          die_roll << '\n';
std::cout << "You " 
          << (die\_roll == 6 ? "win!" : "lose")
          << '\n'; 
\end{console}
Get it?

\begin{ex}
Write a dice game. Roll two dice. If the dice both
give you the same number, print \lq\lq win''. Otherwise your program prints
\lq\lq lose''. Your program should also print the values of the dice roll.
Use the ternary operator.
\end{ex}

\begin{ex}
Write a dice-coin game. First, you roll the dice. If
the dice values are the same you gain \$1.50 and the game ends.
Otherwise you pay \$1. However you have a second chance: you toss a
coin. If you get a head (use random integer value of 0) you gain \$1,
otherwise (i.e., for a tail), you gain \$0.50. Your program prints all
the dice values and the result of the coin toss and finally your gain
(which can be positive or negative). Run this program 10 times. What is
you average gain? Use the ternary operator whenever possible.
\end{ex}

\begin{ex}
Rewrite the following code fragment so that it's
cleaner
\begin{console}
int x, y;
std::cin >> x >> y;
if (x >= 42)
{
    std::cout << x << ' ';
    if (y < 10)
    {
        std::cout << y << ' ';
    }
    else
    {
        std::cout << '-' << ' ';
    }
}
else
{
     std::cout << '*' << ' ';
     if (y < 10)
     {
        std::cout << y << ' ';
     }
     else
     {
        std::cout << '-' << ' ';
     }
}
\end{console}
\end{ex}

\newpage\EMPHASIZE{Summary}

The if and if-else statement looks like these:
\begin{align*}
&\text{if \texttt{([bool expr])}}\\
&\tab[3em]{\texttt{[stmt]}}\\\\
&\text{if \texttt{([bool expr])}}\\
&\tab[3em]{\texttt{[stmt1]}}\\
&\texttt{else}\\
&\tab[3em]{\texttt{[stmt2]}}\\
\end{align*}

where \texttt{[bool expr]} is a boolean expression and
\texttt{[stmt, [stmt1]}, and \texttt{[stmt2]} are either
statements or blocks of statements.

The else statement will always be associated with the closest if
statement. In other words
\begin{console}
if (x < 0)
   if (x == -2) std::cout << "1" << std::endl;
else
      std::cout << "2" << std::endl;
\end{console}

is better written this way:
\begin{console}
if (x < 0)
   if (x == -2)
       std::cout << "1" << std::endl;
   else
       std::cout << "2" << std::endl;
\end{console}

The \texttt{rand()} function returns a \lq\lq random'' integer between 0 and
\texttt{RAND\_MAX}. Number. The \texttt{srand()} function \lq\lq seeds'' the
\texttt{rand()} function. You might need to \lq\lq \texttt{\#<include
 cstdlib>}'' to use the \texttt{srand()} and
\texttt{rand()} functions. One way to seed rand() is to call
\begin{center}
\texttt{srand((unsigned) time(0))}
\end{center}
in which case you need to \lq\lq \texttt{\#<include  ctime>}''.
\begin{center}
\texttt{double(rand()) / RAND\_MAX}
\end{center}
will generate \lq\lq random'' doubles between 0 and 1. To generate a random
integer between a and b (two integers with a = b), you can use
\begin{center}
\texttt{int(double(rand()) / RAND\_MAX * (b - a)) + a}
\end{center}
or
\begin{center}
\texttt{rand() \% (b - a + 1) + a}
\end{center}
(The second method is not as general nor as random as the first. For
instance you cannot use it to generate random number between 0 and
1000000 in MS .NET STUDIO).

The following code segment swaps the values in \texttt{a} and \texttt{b}
(and \texttt{t} has the value of \texttt{a}):
\begin{align*}
&\text{t = a;} \tab[3em]{\text{a = b;}} \tab[3em]{\text{b = t;}}\\
\end{align*}
Using the \lq\lq swapping trick'', you can always ensure that a pair of
variables are in ascending (or descending order):

\tab[3em]{if (a $>$ b)}\\
\tab[3em]{\{}\\
\tab[6em]{t = a;}\\
\tab[6em]{a = b;}\\
\tab[6em]{b = t;}\\
\tab[3em]{\}}\\

Given for instance four variables \texttt{a}, \texttt{b}, \texttt{c}, and
\texttt{d}, you can apply the above to the pairs \texttt{a},\texttt{b} and
\texttt{b},\texttt{c} and \texttt{c},\texttt{d} to ensure that the largest value
among \texttt{a}, \texttt{b}, \texttt{c}, \texttt{d} is in \texttt{d:}

\tab[3em]{if (a > b) \{ swap values of a and b \}}\\
\tab[3em]{if (b > c) \{ swap values of b and c \}}\\
\tab[3em]{if (c > d) \{ swap values of c and d \}}\\

This is called one pass of the sorting process. You can then apply the
process to a, b, c for a second pass, and then to a, b for a third pass.
This will sort the values of \texttt{a}, \texttt{b}, \texttt{c}, \texttt{d} into
ascending order.

Just as there is automatic type casting from int to double, there is
also automatic type type casting between bool and int or double:

\begin{align*}
&\texttt{bool} \implies &\texttt{int}\\
&\texttt{true} &1\\
&\texttt{false} &0\\\\
&\text{numeric (int/double/float)} \implies &\texttt{bool}\\
&\text{nonzero (example: 1, 2, 3)} &\texttt{true}\\
&\text{zero (example: 0, 0.0)} &\texttt{false}\\
\end{align*}

For instance the following is a valid C++ statement:
\tab[3em]{if (1)}
\tab[6em]{std::cout << "that's all folks";}

The ternary operator looks like this:
\begin{center}
(\texttt{[bool expr} ? \texttt{[expr1} : \texttt{[expr2})
\end{center}
This whole expression evaluates to \texttt{[expr1]} if \texttt{[bool
expr]} is true; otherwise it evaluates to \texttt{[expr2]}.

\newpage\EMPHASIZE{Repetition code and breaking deeply nested code and deep expressions}

(There are some solutions are the end of this pdf.)

Here's one way to compute sum from 1 to 5 is
\begin{console}
int s = 1 + 2 + 3 + 4 + 5; 
\end{console}

Another way to do this is to do this:
\begin{console}
int s = 0;
s = s + 1;
s = s + 2;
s = s + 3;
s = s + 4;
s = s + 5; 
\end{console}

And to make all repetition code exactly the same, you do this:
\begin{console}
int i = 1;
int s = 0;
s = s + i;
i = i + 1;
s = s + i;
i = i + 1;
s = s + i;
i = i + 1;
s = s + i;
i = i + 1;
s = s + i;
i = i + 1; 
\end{console}

You have already seen this before.

The reason why you want to think/write your code using repeating code is
because later we can use loop controls to tell C++ to repeat a block of
code by giving the loop structure just one block of the code.

\begin{ex}
Compute the sum of squares from 1 to 25, i.e., s =
1*1 + 2*2 + 3*3 + 4*4 + 5*5 using the same idea as above.
\end{ex}
\begin{ex}
Get an integer n from the user and then compute the
sum of the rightmost 4 digits of n. Do this with repetition code.
\end{ex}
\newpage\EMPHASIZE{Maximum/minimum computation}

Recall I have already talked about the max/min computation. There are
two ways of doing it.

Here's the max computation that you have already seen:
\begin{console}
int w = 1, x = 3, y = 0, z = 5;
int max;

max = w;
if (max < x)
   max = x;
if (max < y)
   max = y;
if (max < z)
   max = z; 
\end{console}

Notice that other than the first statement, the rest of the code is more
or less a repetition of the same kind of code:
\begin{console}
max = w;
if (max < [variable])
   max = [variable]; 
\end{console}

There's another \EMPHASIZE{TERRIBLE} way to do the above:
\begin{console}
int w = 1, x = 3, y = 0, z = 5;
if (w >= x && w >= y && w >= z)
    max = w;
else
{
     if (x >= w && x >= y && x >= z)
         max = x;
     else
     {
        if (y >= w && y >= x && y >= z)
            max = y;
        else
            max = z;
      }
}
\end{console}

Of course you can try to make it \lq\lq neater'':
\begin{console}
int w = 1, x = 3, y = 0, z = 5;

if (w >= x && w >= y && w >= z)
    max = w;
else if (x >= w && x >= y && x >= z)
    max = x;
else if (y >= w && y >= x && y >= z)
    max = y;
else
    max = z;
\end{console}

But you are computing way too many boolean conditions. If z is the
maximum value, how many boolean operators are you evaluating? Compare
this to the first max computation.

Secondly, and this is probably even more important:

\begin{ex}
Suppose you need to add another variable to your w,
x, y, z for max computation:
\begin{console}
int w = 1, x = 3, y = 0, z = 5, a = 7;
int max;

// ... max computation ... 
\end{console}
\end{ex}
Complete this using the first method and then using the second method.
Do I need to explain anymore that the first method is way better?

Part of the problem is that the boolean expression in
\begin{console}
if (w >= x && w >= y && w >= z)
    max = w;  
\end{console}
depends on a huge number of variables.

The earlier better solution is to consider one variable at a time.

In general if the boolean is made up of expressions which \EMPHASIZE{do not depend on each other}, it's usually best to process them \EMPHASIZE{separately}.

\newpage\EMPHASIZE{Count computation}

Here's the pseudocode for the count computation again:
\begin{console}
count = 0
if target == a:
   increment count by 1
if target == b:
   increment count by 1
if target == c:
   increment count by 1
if target == d:
   increment count by 1
print count 
\end{console}
Again, you see repetition of code.

Another way to do the above, a \EMPHASIZE{TERRIBLE} way, is to do this:
\begin{console}
count = 0
if target != a && target != b && target != c && target != d
   count = 0
else if target == a && target != b && target != c && target != d
   count 1
else if target != a && target == b && target != c && target != d
   count 1
else if target != a && target != b && target == c && target != d
   count 1
else if target != a && target != b && target == c && target != d
   count 1
else if target != a && target != b && target != c && target == d
   count 1
else if target == a && target == b && target != c && target != d
   count 2
.... 
\end{console}

I don't even want to complete this!!! This is clearly a really TERRIBLE
algorithm. There is a total of $2^4$ = 16 boolean
expressions. (Why?) YIKES!

And furthermore, if I add another variable e to the above, I would have
to change a lot of code, as well as adding some more code.

\begin{ex}
Get integer \texttt{x}, \texttt{y} from the user and
print \texttt{x}, \texttt{y}, except that if \texttt{x }is negative you print
\texttt{0} instead of \texttt{x} and if \texttt{y} is negative you print
\texttt{0} instead of \texttt{y}.
\end{ex}
Here's a test case
\begin{console}[commandchars=\~\@\$]
~textbf@2 3$
2 3 
\end{console}

Here's another test case
\begin{console}[commandchars=\~\@\$]
~textbf@-1 3$
0 3 
\end{console}

and another test:
\begin{console}[commandchars=\~\@\$]
~textbf@2 -2$
2 0 
\end{console}

and finally

\begin{console}[commandchars=\~\@\$]
~textbf@-5 -2$
0 0 
\end{console}

You can write your program with boolean conditions where each boolean
condition involves \EMPHASIZE{both} \texttt{x} and \texttt{y}. But instead of
that, write your program so that you have boolean expressions where each
boolean expression involves only \EMPHASIZE{one} variable.

\newpage\EMPHASIZE{Multiplication game: Part 4}

Here's the pseudocode:
\begin{align*}
& \textbf{\texttt{Generate two random integers between 90 and 99}}\\
& \tab[3em]{\texttt{and give the values to variables x and y}}\\
& \textbf{\texttt{Store the product of x and y in variable answer}}\\
& \textbf{\texttt{Print a prompt string to user to guess the}}\\
& \textbf{\tab[3em]{\texttt{product of x and y}}}\\\\
& \texttt{\textbf{Declare integer variable score and initialize it}}\\
& \tab[3em]{\textbf{\texttt{to 0}}}\\
& \textbf{\texttt{Declare integer variable guess}}\\
& \texttt{\textbf{Prompt user for integer value for guess}}\\\\
& \texttt{\textbf{If guess is answer}}\\
& \tab[3em]{\texttt{\textbf{Print congratulatory message}}}\\
& \tab[3em]{\texttt{\textbf{score = 2}}}\\
& \texttt{\textbf{Otherwise if guess is less than the answer:}}\\
& \tab[3em]{\texttt{\textbf{Tell user the guess is too low}}}\\
& \tab[3em]{\texttt{\textbf{Print a prompt string to user to guess}}}\\
& \tab[6em]{\texttt{\textbf{the product of x and y}}}\\
& \tab[3em]{\texttt{\textbf{If guess is answer}}}\\
& \tab[6em]{\texttt{\textbf{print congratulatory message}}}\\
& \tab[6em]{\texttt{\textbf{score = 1}}}\\
& \tab[3em]{\texttt{\textbf{Otherwise}}}\\
& \tab[6em]{\texttt{\textbf{print answer}}}\\
& \texttt{\textbf{Otherwise if guess is greater than the answer:}}\\
& \tab[3em]{\texttt{\textbf{Tell user the guess is too low}}}\\
& \tab[3em]{\texttt{\textbf{Print a prompt string to user to guess}}}\\
& \tab[6em]{\texttt{\textbf{the product of x and y}}}\\
& \tab[3em]{\texttt{\textbf{If guess is answer}}}\\
& \tab[6em]{\texttt{\textbf{print congratulatory message}}}\\
& \tab[6em]{\texttt{\textbf{score = 1}}}\\
& \tab[3em]{\texttt{\textbf{Otherwise}}}\\
& \tab[6em]{\texttt{\textbf{print answer}}}\\\\
& \texttt{\textbf{Print user's score}}\\
\end{align*}

Sometimes, you have deeply nested code. What if the above, where you
give the user at most 2 chances to answer a question, if changed to
allowing the user to have \EMPHASIZE{3} chances or even \EMPHASIZE{4} chances?
If you use the above method, you would have a very deeply nested code
structure.

Another way to allow the user 3 chances is to avoid deeply nested code
as follows. First, since you do not want to nest the 3 cases, you want
something like this:

\begin{align*}
&\texttt{ask user for an answer}\\
&\texttt{ask user for an answer}\\
&\texttt{ask user for an answer}\\
\end{align*}

But of course you want the second \lq\lq ask user for an answer'' to know if
the first \lq\lq ask user for an answer'' gave rise to a correct answer or
not.

\begin{align*}
&\texttt{ask user for an answer}\\
&\texttt{if first answer is not correct:}\\
&\tab[3em]{\texttt{ask user for an answer}}\\
&\texttt{ask user for an answer}\\
\end{align*}

Likewise the third \lq\lq ask user for an answer'' also need to know if a
correct answer was given. So instead of \lq\lq first answer is not correct'',
we probably want \lq\lq \,\lq\lq answer is not correct'' that can be used or the second and third \lq\lq answer user for an answer''.

\begin{align*}
&\texttt{ask user for an answer}
&\texttt{if answer is not correct}
&\tab[3em]{\texttt{ask user for an answer}}
&\texttt{if answer is not correct}
&\tab[3em]{\texttt{ask user for an answer}}
\end{align*}

Let's make \lq\lq answer is not correct'' into a boolean variable:
\begin{align*}
&\texttt{bool answer\_is\_correct}\\\\
&\texttt{ask user for an answer}\\
&\texttt{if answer from user is correct,}\\
&\tab[3em]{\texttt{answer\_is\_correct = true}}\\\\
&\texttt{if !answer\_is\_correct:}\\
&\tab[3em]{\texttt{ask user for an answer}}\\
&\tab[3em]{\texttt{if answer from user is correct,}}\\
&\tab[6em]{\texttt{answer\_is\_correct = true}}\\\\
&\texttt{if !answer\_is\_correct:}\\
&\tab[3em]{\texttt{ask user for an answer}}\\
&\tab[3em]{\texttt{if answer from user is correct,}}\\
&\tab[6em]{\texttt{answer\_is\_correct = true}}\\\\
\end{align*}

You want to think of \texttt{answer\_is\_correct} as a
\EMPHASIZE{communication device} from the first \lq\lq answer user for an
answer'' with the second and third, and also from the second to the
third. For this example, the repeated blocks of code are \EMPHASIZE{not
completely independent}. Other than the first block, subsequent blocks
need to know if the user has given a correct answer.

Get it?

\begin{ex}
Write the multiplication game that allows the user to
have at most 3 tries.
\end{ex}

\begin{ex}
Get an integer n from the user and then compute the
sum of the rightmost 4 digits of n. Once a digit 0 is added, you should
stop the summation. Do this with repetition code. Here's a test case
\end{ex}
\begin{console}[commandchars=\~\@\$]
~textbf@1534315$
13 
\end{console}

Here's another:
\begin{console}[commandchars=\~\@\$]
~textbf@1534015$
6 
\end{console}

(after adding \texttt{5} and \texttt{1}, on seeing a \texttt{0}, the summation
stops. Therefore the sum is 6) and another

\begin{console}[commandchars=\~\@\$]
~textbf@1534205$
5 
\end{console}


\newpage\EMPHASIZE{Solutions}

%\begin{ex}
Compute the sum of squares from 1 to 25, i.e., s =
1*1 + 2*2 + 3*3 + 4*4 + 5*5 using the same idea as above.

\protect\hypertarget{anchor}Solution.

\begin{console}
\#include <iostream>

int main()
{
        int s = 0;
        int i = 1;

        s = s + i;
        i = i + 1;

        s = s + i;
        i = i + 1;

        s = s + i;
        i = i + 1;

        s = s + i;
        i = i + 1;

        s = s + i;
        i = i + 1;

        std::cout << s << '\n';

        return 0;
} 
\end{console}

%% %\begin{ex}
Get an integer n from the user and then compute the
sum of the leftmost 4 digits of n. Do this with repetition code.

\protect\hypertarget{anchor-1}Solution.


%% \#include  iostream>

%% int main()

%% \{

%% int n;

%% std::cin >> n;

%% int s = 0;

%% s = s + n \% 10;

%% n = n / 10;

%% s = s + n \% 10;

%% n = n / 10;

%% s = s + n \% 10;

%% n = n / 10;

%% s = s + n \% 10;

%% n = n / 10;

%% std::cout  s 
%%  n;

%% return 0;

%% } 


%% %\begin{ex} Get integer \texttt{x}, \texttt{y} from the user and
%% print \texttt{x}, \texttt{y}, except that if \texttt{x }is negative you print
%% \texttt{0} instead of \texttt{x} and if \texttt{y} is negative you print
%% \texttt{0} instead of \texttt{y}. Here's a test case


%% 2 3

%% 2 3 


%% Here's another test case


%% -1 3

%% 0 3 


%% and another test:


%% 2 -2

%% 2 0 


%% and finally


%% -5 -2

%% 0 0 


%% You can write your program with boolean conditions where each boolean
%% condition involves both \texttt{x} and \texttt{y}. But instead of that,
%% write your program so that you have boolean expressions where each
%% boolean expression involves only one variable.

%% \protect\hypertarget{anchor-2}Solution.


%% \#include  iostream>

%% int main()

%% \{

%% int x, y;

%% std::cin >> x >> y;

%% if (x  0)

%% \{

%% x = 0;

%% }

%% std::cout  x  
%% ;

%% if (y  0)

%% \{

%% y = 0;

%% }

%% std::cout  y  
%% ;

%% return 0;

%% } 


%% %\begin{ex}   
%% Get an integer n from the user and then compute the
%% sum of the rightmost 4 digits of n. Once a digit 0 is added, you should
%% stop the summation. Do this with repetition code. Here's a test case
%% %\end{ex}

%% \textbf{1534315}

%% 13 


%% Here's another:


%% \textbf{1534015}

%% 6 


%% (after adding \texttt{5} and \texttt{1}, on seeing a \texttt{0}, the summation
%% stops. Therefore the sum is 6) and another


%% \textbf{1534205}

%% 5 


%% Here's the idea. First here's the code to sum the 4 rightmost digits:


%% \#include  iostream>

%% int main()

%% \{

%% int n;

%% std::cin >> n;

%% int s = 0;

%% s = s + n \% 10;

%% n = n / 10;

%% s = s + n \% 10;

%% n = n / 10;

%% s = s + n \% 10;

%% n = n / 10;

%% s = s + n \% 10;

%% n = n / 10;

%% std::cout  s 
%%  n;

%% return 0;

%% } 


%% Each block needs to know if a zero was encountered. So \ldots


%% \#include  iostream>

%% int main()

%% \{

%% int n;

%% std::cin >> n;

%% int s = 0;

%% bool zero\_not\_found = true;

%% if (zero\_not\_found)

%% \{

%% s = s + n \% 10;

%% n = n / 10;

%% }

%% if (zero\_not\_found)

%% \{

%% s = s + n \% 10;

%% n = n / 10;

%% }

%% if (zero\_not\_found)

%% \{

%% s = s + n \% 10;

%% n = n / 10;

%% }

%% if (zero\_not\_found)

%% \{

%% s = s + n \% 10;

%% n = n / 10;

%% }

%% std::cout  s                  
%%  n;

%% return 0;

%% } 


%% Get it? Think about what will happen if you don't use this communication
%% device \texttt{zero\_not\_found}. You will most likely have a deeply
%% nested if-else structure in your code:


%% if (n \% 10 != 0) // 1st digit != 0

%% \{

%% s = s + n \% 10;

%% n = n / 10;

%% if (n \% 10 != 0) // 2nd digit != 0

%% \{

%% s = s + n \% 10;

%% n = n / 10;

%% if (n \% 10 != 0) // 3rd digit != 0

%% \{

%% s = s + n \% 10;

%% n = n / 10;

%% if (n \% 10 != 0) // 4th digit != 0

%% \{

%% s = s + n \% 10;

%% n = n / 10;

%% }

%% Later when I talk about loops and all the repeating blocks of code are
%% placed in a loop structure, you'll see that your can control a loop to
%% make it stop \lq\lq prematurely''.

%% Exercise

%% You have more than enough exercises in these notes already. Make sure
%% you go over all of them on your own.

%% Some Mental Math (DIY)

%% This section has nothing to do with programming. It's
%% just for fun.

%% Suppose I told you that it's possible to multiply 98 and
%% 97 very quickly without paper and pencil or calculators or C++. Would
%% you believe me? It does require some practice, but there is a way to
%% multiply two values a little less than 100 very quickly.

%% Let me show you how with the 98 x 97 example. You subtract the numbers
%% from 100. So 100 -- 98 = 2 and 100 -- 97 = 3. Write this down on a piece
%% of paper:

%% 98 97

%% 2 3

%% Now look at 98 and 3. Compute 98 -- 3. This is 95. You will need this
%% number. Note that 97 -- 2 is also 95. So there are two different ways of
%% getting 95 with the two diagonals. Write this down:

%% 98 97 \textbf{95}

%% 2 3

%% Now look at the 2 and 3. Multiply them together. You get 6. Write this
%% down:

%% 98 97 95\textbf{06}

%% 2 3

%% That's it. Here's another example: 96 x
%% 95. First you have:

%% 96 95

%% 4 5

%% \hfill\break
%% Next you get

%% 96 95 \textbf{91}

%% 4 5

%% and finally

%% 96 95 91\textbf{20}

%% 4 5

%% The answer is 9120. With some practice you will be able to do the
%% computation in your head. (Using algebra, you can actually prove that
%% the method does work.) So now you can show it off to your math teacher.

