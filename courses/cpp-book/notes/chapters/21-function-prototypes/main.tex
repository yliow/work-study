% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\author{}
\date{}

\begin{document}

Objectives

\begin{itemize}
\tightlist
\item
  Write function prototypes
\item
  Write header files and build a multifile project
\end{itemize}

Function Prototypes

\textbf{Exercise.} What\textquotesingle s wrong with the program. You
have 2 seconds.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\begin{quote}
\#include \textless iostream\textgreater{}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
int main()
\end{quote}

\begin{quote}
\{
\end{quote}

\begin{quote}
f(1);
\end{quote}

\begin{quote}
return 0;
\end{quote}

\begin{quote}
\}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
void f(int x)
\end{quote}

\begin{quote}
\{
\end{quote}

\begin{quote}
std::cout \textless\textless{} x \textless\textless{} std::endl;
\end{quote}

\begin{quote}
\}
\end{quote} \\
\end{longtable}

Correct it. Verify with C++.

Now try this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\begin{quote}
\#include \textless iostream\textgreater{}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
void f(int);
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
int main()
\end{quote}

\begin{quote}
\{
\end{quote}

\begin{quote}
f(1);
\end{quote}

\begin{quote}
return 0;
\end{quote}

\begin{quote}
\}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
\end{quote}

\begin{quote}
void f(int x)
\end{quote}

\begin{quote}
\{
\end{quote}

\begin{quote}
std::cout \textless\textless{} x \textless\textless{} std::endl;
\end{quote}

\begin{quote}
return;
\end{quote}

\begin{quote}
\}
\end{quote} \\
\end{longtable}

A \textbf{function prototype} basically tells C++ that the function does
exist. The information contained in a function prototype includes:

\begin{itemize}
\tightlist
\item
  \textbf{name} of the function
\item
  the \textbf{return type} and
\item
  the \textbf{types of the parameters}.
\end{itemize}

The function prototype is the minimal amount of information needed to
get your C++ compiler to work with your C++ file.

Why?

Well C++ needs to compile \emph{main()} to work which means from the
side of \emph{main()}, the \emph{main()} function needs to know what to
push onto the stack to communication with \emph{f()} and also what value
(if any) is expected from the return of calling \emph{f()}. As far as
\emph{main()} is concerned, all \emph{main()} needs is the
``communication infrastructure'' of \emph{f()}. \emph{main()}
doesn\textquotesingle t need to know how \emph{f()} carries out its
duty. We\textquotesingle ll come back to this again later.

The format of a function prototype is exactly the same as the header of
a function except for the following:

\begin{itemize}
\tightlist
\item
  a function prototype must end with a semicolon
\item
  the parameter names can be left out. (You can retain them if you
  wish).
\end{itemize}

Here\textquotesingle s another example. First the program without
prototype:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int sum(int start, int end, int step)

\{

int sum = 0;

if (step \textgreater{} 0)

\{

for (int i = start; i \textless= end; i += step)

\{

sum += i;

\}

\}

else if (step \textless{} 0)

\{

for (int i = start; i \textgreater= end; i += step)

\{

sum += i;

\vtop{\hbox{\strut  \}}\hbox{\strut  \}}}

\vtop{\hbox{\strut  return sum;}\hbox{\strut \}}}

\vtop{\hbox{\strut int main()}\hbox{\strut \{}}

std::cout \textless\textless{} sum(1, 10, 1) \textless\textless{}
std::endl;

std::cout \textless\textless{} sum(2, 10, 4) \textless\textless{}
std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

And now the program with prototype:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int sum(int, int, int);

\vtop{\hbox{\strut int main()}\hbox{\strut \{}}

std::cout \textless\textless{} sum(1, 10, 1) \textless\textless{}
std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}}

int sum(int start, int end, int step)

\{

int sum = 0;

if (step \textgreater{} 0)

\{

for (int i = start; i \textless= end; i += step)

\{

sum += i;

\}

\}

else if (step \textless{} 0)

\{

for (int i = start; i \textgreater= end; i += step)

\{

sum += i;

\vtop{\hbox{\strut  \}}\hbox{\strut  \}}}

\vtop{\hbox{\strut  return sum;}\hbox{\strut \}}} \\
\end{longtable}

Exercise. Write a function prototype for the given function. Run the
program to make sure it works.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// put prototype of isNiceNumber() here

int main()

\{

std::cout \textless\textless{} isNiceNumber(1) \textless\textless{}
std::endl;

\vtop{\hbox{\strut  std::cout \textless\textless{} isNiceNumber(42)
\textless\textless{} std::end;}\hbox{\strut \}}}

bool isNiceNumber(int x)

\{

\vtop{\hbox{\strut  return (x == 42);}\hbox{\strut \}}} \\
\end{longtable}

Exercise. Write a function prototype for the given function. Run the
program to make sure it works.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// put prototype for predictGoogleStockPrice here

int main()

\{

std::cout \textless\textless{} predictGoogleStockPrice(1, 1, 2008)

\textless\textless{} \textquotesingle\textbackslash n\textquotesingle{}

\textless\textless{} "don\textquotesingle t count on it ..."

\textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}}

int predictGoogleStockPrice(int mth, int day, int yr)

\{

if (yr \textgreater= 2004)

\{

return 450 * (yr -- 2004)

\vtop{\hbox{\strut  + (mth \% 2) * (day -- 2);}\hbox{\strut  \}}}

else

\{

\vtop{\hbox{\strut  return 0;}\hbox{\strut  \}}\hbox{\strut \}}} \\
\end{longtable}

Exercise. Write a function that accepts an array x of integers and an
integer i, computes and returns the sum of values in an array from index
position 0 to index position i.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// put prototype here

int main()

\{

int x{[}10{]} = \{0, 2, 4, 6, 8, 1, 3, 5, 7, 9\};

for (int i = 0; i \textless{} 10; i++)

\{

\vtop{\hbox{\strut  std::cout \textless\textless{} sum(x,
i);}\hbox{\strut  \}}}

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}}

// put function definition (actual function) here \\
\end{longtable}

Now you might ask: ``Why bother? Why not just put the function
\emph{f()} before \emph{main()}?''

There are two reasons.

First read this program and figure out what the program is trying to do:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\#include \textless iostream\textgreater{}

void f(int x)

\{

std::cout \textless\textless{} "in f() ..." \textless\textless{}
std::endl;

if (x \textgreater{} 0) g(x -- 1);

\vtop{\hbox{\strut  return;}\hbox{\strut \}}}

void g(int x)

\{

std::cout \textless\textless{} "in g() ..." \textless\textless{}
std::endl;

if (x \textgreater{} 0) f(x -- 1);

\vtop{\hbox{\strut  return;}\hbox{\strut \}}}

int main()

\{

f(5);

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

Next tell me why it won\textquotesingle t work. You have 5 seconds ...

And finally, tell me why moving functions around won\textquotesingle t
help!!! The point is that \emph{f()} and \emph{g()} calls each other!!!

Now try this ...

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\#include \textless iostream\textgreater{}

void g(int);

void f(int x)

\{

std::cout \textless\textless{} "in f() ... x = " \textless\textless{} x
\textless\textless{} std::endl;

if (x \textgreater{} 0) g(x -- 1);

\vtop{\hbox{\strut  return;}\hbox{\strut \}}}

void g(int x)

\{

std::cout \textless\textless{} "in g() ... x = " \textless\textless{} x
\textless\textless{} std::endl;

if (x \textgreater{} 0) f(x -- 1);

\vtop{\hbox{\strut  return;}\hbox{\strut \}}}

int main()

\{

f(5);

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

Do you see now that for this scenario, you \textbf{must} have a function
prototype to make this program work?

For the above situation, we say that \emph{f()} and \emph{g()} are
\textbf{mutually recursive}. A function say \emph{h()} can also call
itself; we say that \emph{h()} is \textbf{recursive}. I
don\textquotesingle t want to spend any more time on recursion since
there will be a set of notes for that later. The point here is to show
you that there are cases where you have to untangle function
dependencies using function prototypes.

Before I go on to the second reason, you should know that the standard
``layout'' of a C/C++ program looks like this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
... documentation (comments) ...

... \#includes ...

... global constants ...

... function prototypes ...

int main()

\{

...

\}

... function definitions ... \\
\end{longtable}

(There are other parts but we haven\textquotesingle t talked about them
yet.)

So our above program can be professionally (ahem ...) written like this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// This program demonstrates the use of prototypes

// with two mutually recursive functions.

\#include \textless iostream\textgreater{}

void g(int);

void f(int);

int main()

\{

f(5);

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}}

void f(int x)

\{

std::cout \textless\textless{} "in f() ... x = " \textless\textless{} x
\textless\textless{} std::endl;

if (x \textgreater{} 0) g(x -- 1);

\vtop{\hbox{\strut  return;}\hbox{\strut \}}}

void g(int x)

\{

std::cout \textless\textless{} "in g() ... x = " \textless\textless{} x
\textless\textless{} std::endl;

if (x \textgreater{} 0) f(x -- 1);

\vtop{\hbox{\strut  return;}\hbox{\strut \}}} \\
\end{longtable}

(Actually moving the function bodies below \emph{main()} is not that
crucial).

Once again in C/C++, a function, say \emph{func1()}, can call another,
say \emph{func2()}, if \emph{func1()} knows the ``communication
structure'' of \emph{func2()}. \emph{func1()} does not need the
definition or body of \emph{func2()}. And the communication structure is
made up of the types of the parameters of \emph{func2()} and the return
type of \emph{func2()}. That\textquotesingle s why I drew this picture
for you earlier showing the types of data passed in and the type of
value returned.

The function prototype of \emph{func2()} is sometimes called the
\textbf{interface} of \emph{func2()}. Why? Because that is how
\emph{func2()} interfaces with the outside world.

Exercise. Rewrite the following program using function prototypes and
moving the function bodies below \emph{main()} and making all constants
global to remove duplicate constants declarations.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\#include \textless iostream\textgreater{}

void printRules()

\{

const int MIN\_HEADS = 2;

const int MAX\_HEADS = 10;

std::cout \textless\textless{} "To join MENSA you need at least "

\textless\textless{} MIN\_HEADS \textless\textless{} " and at most "

\textless\textless{} MAX\_HEADS \textless\textless{} std::endl;

\vtop{\hbox{\strut  return;}\hbox{\strut \}}}

int getHeads()

\{

int heads;

std::cout \textless\textless{} "How many heads to you have? ";

std::cin \textgreater\textgreater{} heads;

\vtop{\hbox{\strut  return heads;}\hbox{\strut \}}}

bool passMinTest(int heads)

\{

const int MIN\_HEADS = 2;

if (heads \textless{} MIN\_HEADS)

\{

std::cout \textless\textless{} "Too few! Try again!"

\textless\textless{} std::endl;

\vtop{\hbox{\strut  return false;}\hbox{\strut  \}}}

else

\vtop{\hbox{\strut  return true;}\hbox{\strut \}}}

bool passMaxTest(int heads)

\{

const int MAX\_HEADS = 10;

if (heads \textgreater{} MAX\_HEADS)

\{

std::cout \textless\textless{} "Don\textquotesingle t show off! Try
again!"

\textless\textless{} std::endl;

\vtop{\hbox{\strut  return false;}\hbox{\strut  \}}}

else

\vtop{\hbox{\strut  return true;}\hbox{\strut \}}}

bool passTest(int x)

\{

\vtop{\hbox{\strut  return passMinTest(x) \&\&
passMaxTest(x);}\hbox{\strut \}}}

int main()

\{

int heads = 0;

printRules();

heads = getHeads();

while (!passTest(heads))

\{

\vtop{\hbox{\strut  heads = getHeads();}\hbox{\strut  \}}}

std::cout \textless\textless{} "OK. You can join MENSA."

\textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

Now for the second reason ...

Header Files and Multi-file Compilation

Remember the first week of class when I told you not to worry about

\#include \textless iostream\textgreater{}

and I told you we will come to it? Now\textquotesingle s the time. In
this section I\textquotesingle ll explain the purpose of this \#include
business. I\textquotesingle ll also explain, at a very high level, the
compilation and linking process that your compiler performs on your
program in order to produce a machine executable code. Your C++ files
are human readable; the machine (your PC/laptop/cellphone/etc) can only
understand machine code.

And there\textquotesingle s no better way to understand this \#include
business than to do an example.

First here\textquotesingle s a program:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

int max(int, int);

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}}

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

\vtop{\hbox{\strut  return y;}\hbox{\strut \}}} \\
\end{longtable}

Make sure it works.

Now create a new cpp file called \emph{mymath.cpp} that contains the
\emph{max()} function. (Follow the instructions given in class -- the
process depends very much on the software you use to write programs).

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: mymath.cpp

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

\vtop{\hbox{\strut  return y;}\hbox{\strut \}}} \\
\end{longtable}

Now remove the \emph{max()} function in \emph{testmax.cpp} -- do not
remove the function prototype. Altogether, now you have two cpp files:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

int max(int, int);

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

and

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: mymath.cpp

int max(int, int);

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

\vtop{\hbox{\strut  return y;}\hbox{\strut \}}} \\
\end{longtable}

Run your program and you\textquotesingle ll find that it works.

When I say ``compile and run your program'', the compiler software you
use actually performs (at least) two things to build a machine
executable code. Each cpp file (and you have two in this case) produces
an \textbf{object code}. In our example \emph{testmax.cpp} and
\emph{mymath.cpp} produce \emph{testmax.obj} and \emph{mymath.obj}. This
step is called \textbf{compilation}.

The next step involves combining both object code into a single machine
executable code, \emph{testmax.exe}.

You see the function prototype in \emph{testmax.cpp}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

int max(int, int);

int main()

... \\
\end{longtable}

tells \emph{main()} how to communicate with \emph{max()} - what types
and values should be sent to \emph{max()} and what type and value (if
any) is to be received. This is all built into \emph{testmax.obj}.
However \emph{testmax.obj} does not contain the logic to actually
execute \emph{max()} since the logic is in \emph{mymath.obj}.

The next thing the compiler software does is called \textbf{object code
linking}. It takes \emph{testmax.obj} and \emph{mymath.obj} and produces
\emph{testmax.exe}. Here\textquotesingle s a picture to help you:

When the computer runs the program, the file that is executed is
actually \emph{testmax.exe}.

Now I want to explain another step in the whole compilation process. And
this will explain the \#include business.

Now create a \textbf{header file} \emph{mymath.h} (follow the
instructions given in class -- the process depends very much on the
software you use to write programs). It includes some boilerplate code
and the function prototype from \emph{testmax.cpp}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\vtop{\hbox{\strut // Name: mymath.h}\hbox{\strut \#ifndef MYMATH\_H}}

\#define MYMATH\_H

int max(int, int);

\#endif \\
\end{longtable}

(remember to add a blank line at the end -- it\textquotesingle s
important!) and your cpp file containing \emph{main()} should now look
like this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

\#include "mymath.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

Do the same for \emph{mymath.cpp}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: mymath.cpp

\#include "mymath.h"

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

\vtop{\hbox{\strut  return y;}\hbox{\strut \}}} \\
\end{longtable}

Altogether you have now three files:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\vtop{\hbox{\strut // Name: mymath.h}\hbox{\strut \#ifndef MYMATH\_H}}

\#define MYMATH\_H

int max(int, int);

\#endif \\
\end{longtable}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

\#include "mymath.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: mymath.cpp

\#include "mymath.h"

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

\vtop{\hbox{\strut  return y;}\hbox{\strut \}}} \\
\end{longtable}

Run your program and make sure it works.

What\textquotesingle s the point of \emph{\#include "mymath.h"}?

When you compile your program, the compiler software copies all the
contents of the file \emph{mymath.h} (excluding the boilerplate code) to
the places where you have \emph{\#include "mymath.h"}.
I\textquotesingle m not going to explain the boilerplate code in bold:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\vtop{\hbox{\strut // Name: mymath.h}\hbox{\strut \textbf{\#ifndef
MYMATH\_H}}}

\#define MYMATH\_H

int max(int, int);

\#endif \\
\end{longtable}

All you need to know is that if you header file is named \emph{xyz.h},
then the boilerplate code should look like this:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\vtop{\hbox{\strut // Name: xyz.h}\hbox{\strut \textbf{\#ifndef
XYZ\_H}}}

\#define XYZ\_H

...

\#endif \\
\end{longtable}

This step is called \textbf{preprocessing. }For our example, after
preprocessing the \emph{testmax.cpp} file

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

\#include "mymath.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

it becomes the following in the memory of the compiler software (the
actual testmax.cpp file is \emph{\textbf{not}} changed).

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// testmax.cpp

\#include \textless iostream\textgreater{}

int max(int, int);

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

Anyway ... the compilation process is now actually made up of three
steps:

To learn more about issues like machine code (in the file
\emph{testmax.exe}) you need to take CISS360 (Assembly Language and
Computer Systems.)

\textbf{Exercise. }Add a \emph{min()} function to \emph{mymath.cpp}, add
a function prototype for \emph{min()} in \emph{mymath.h}. Finally modify
your \emph{main()} as follows:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
// testmax.cpp

\#include \textless iostream\textgreater{}

\#include "mymath.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

std::cout \textless\textless{} min(3, 5) \textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

Run the program.

So what have we done?

In our previous example I told you that a function prototype for
function \emph{func2()} is like its interface with the outside world. If
\emph{func1()} calls \emph{func2()} we have this picture:

For our current example, we placed our functions into a separate cpp
file called \emph{mymath.cpp} and put all the function prototypes of
functions in \emph{mymath.cpp} into \emph{mymath.h}. We can then call
the functions in \emph{mymath.cpp} from our main source file (say
it\textquotesingle s called testmax.cpp)

Of course any function in \emph{testmax.cpp} (not just \emph{main()})
can call the functions in \emph{mymath.cpp}.

We have basically broken up our original program into two cpp file. The
header file \emph{mymath.h} provides an interface for \emph{mymath.cpp}.

Why is that good?

Because if one day you need the \emph{max()} and \emph{min()} functions
in another project, say the main source file is called \emph{main2.cpp}
then you can copy \emph{mymath.cpp} and \emph{mymath.h} to the project
space of \emph{main2.cpp} and you have the functions in
\emph{mymath.cpp} available to \emph{main2.cpp}.

\textbf{Exercise.} Create a brand new project, copy \emph{mymath.cpp}
and \emph{mymath.h} to the new project folder. Add these files to your
project. Create a \emph{main()} that calls \emph{min()} and
\emph{max()}.

OK. Let\textquotesingle s step back and take a look at what
we\textquotesingle ve done. Previously we ``re-use'' the code for
\emph{max()} and \emph{min()} by creating a function from chunks of
code. This reduces code duplication.

But this is code reduction for \textbf{one single cpp file}.

To make the functions \textbf{more re-usable}, we took those out and put
them into a new cpp file. We need a header file too.

This allows us to re-use code easily for two totally separate programs.

(Actually you don\textquotesingle t even need to copy \emph{mymath.cpp}
and \emph{mymath.h} to the new project. You can have one single copy of
\emph{mymath.h} and \emph{mymath.cpp} but I don\textquotesingle t want
to go into that for CISS240.)

OK but what about

\#include \textless iostream\textgreater{}

For header files for C++ standard cpp files you should write

\#include \textless iostream\textgreater{}

which is actually the same as

\#include "iostream.h"

So in other words

\#include \textless...\textgreater{} // for C++ standard header files

\#include "..." // for your header files

And remember that when you use \textless...\textgreater{} you do not
have the .h part of the header filename.

You might say, ``Well why doesn\textquotesingle t the compiler just
search for the function I\textquotesingle m calling? Just scan the hard
disk for all cpp and header files and look for the function.''

True.

But compilers don\textquotesingle t work that way because it could
potentially take half an hour before the compiler reports an error that
the function can\textquotesingle t be found on your hard drive!!! Your
hard drive is pretty huge, you know. For a really huge hard drive it
might take even more time.

Exercise.\textbf{ }Here\textquotesingle s a previous program. Move all
the function bodies to \emph{heads.cpp} and create a header file (pun?)
\emph{heads.h}. Run your program and make sure it works. The global
constants should be in the header file.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\#include \textless iostream\textgreater{}

void printRules()

\{

const int MIN\_HEADS = 2;

const int MAX\_HEADS = 10;

std::cout \textless\textless{} "To join MENSA you must have at "

\textless\textless{} "least " \textless\textless{} MIN\_HEADS

\textless\textless{} " and at most "

\textless\textless{} MAX\_HEADS \textless\textless{} std::endl;

\vtop{\hbox{\strut  return;}\hbox{\strut \}}}

int getHeads()

\{

int heads;

std::cout \textless\textless{} "How many heads to you have? ";

std::cin \textgreater\textgreater{} heads;

\vtop{\hbox{\strut  return heads;}\hbox{\strut \}}}

bool passMinTest(int heads)

\{

const int MIN\_HEADS = 2;

if (heads \textless{} MIN\_HEADS)

\{

std::cout \textless\textless{} "Too few! Try again!"

\textless\textless{} std::endl;

\vtop{\hbox{\strut  return false;}\hbox{\strut  \}}}

else

\vtop{\hbox{\strut  return true;}\hbox{\strut \}}}

bool passMaxTest(int heads)

\{

const int MAX\_HEADS = 10;

if (heads \textgreater{} MAX\_HEADS)

\{

std::cout \textless\textless{} "Don\textquotesingle t show off! Try
again!"

\textless\textless{} std::endl;

\vtop{\hbox{\strut  return false;}\hbox{\strut  \}}}

else

\vtop{\hbox{\strut  return true;}\hbox{\strut \}}}

bool passTest(int x)

\{

\vtop{\hbox{\strut  return passMinTest(x) \&\&
passMaxTest(x);}\hbox{\strut \}}}

int main()

\{

int heads = 0;

printRules();

heads = getHeads();

while (!passTest(heads))

\{

\vtop{\hbox{\strut  heads = getHeads();}\hbox{\strut  \}}}

std::cout \textless\textless{} "OK. You can join MENSA."

\textless\textless{} std::endl;

\vtop{\hbox{\strut  return 0;}\hbox{\strut \}}} \\
\end{longtable}

``Why do I sometimes see Parameter Names for Function Prototypes?''

I already told you that function prototypes only need the name of the
functions and the various types: the parameter types and return types.

However sometimes you see parameter names. For instance instead of this
prototype:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int getSalary(int, int); \\
\end{longtable}

you might have this:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int getSalary(int employeeId, int overtime); \\
\end{longtable}

The reason for giving parametric names in function prototypes even
though they are ignored by C++ is that they make the function prototype
\textbf{easier to read and use}. This is especially the case where the
prototype has many parameters of the same type. For instance this

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int getSalary(int employeeId, int overtime); \\
\end{longtable}

is more useful than this:

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int getSalary(int, int);  \\
\end{longtable}

Giving parameter names also allows the programmer to document the
function:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

// The getSalary() function accepts \textbf{employeeId} and

// \textbf{overtime} (in number of minutes) and returns the

// salary (in cents). Note that a valid \textbf{employeeId}

// ranges from 10000 to 99999.

// If the \textbf{employeeId} is not valid or if the \textbf{overtime}

// is negative the return value is -1.

//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

int getSalary(int employeeId, int overtime); \\
\end{longtable}

Exercise: integer array library

Write an integer array library that has files \emph{IntArray.h} and
\emph{IntArray.cpp }that has the following features.

array\_init(x, x\_len, val, n)

copy integer val into x from index 0 to index n -- 1 and set x\_len to
n.

array\_assign(x, x\_len, y, y\_start, y\_end)

copy y from index y\_start to y\_end -- 1 to x starting at index 0.
x\_len is set accordingly.

array\_concat(x, x\_len, y, y\_start, y\_end)

concatenate the subarray of y from index y\_start to y\_end -- 1 to x
beginning at index x\_len. x\_len is changed accordingly.

array\_isequal(x, x\_start, x\_end, y, y\_start, y\_end)

return true if and only if x from index x\_start to x\_end -- 1 is the
same as y from index y\_start to y\_end -- 1.

array\_replace(x, x\_start, x\_end, source, target)

replace all occurrences of integer source in x from index start to end
-- 1 with integer target.

array\_count(x, x\_start, x\_end, target)

returns the number of times integer target occurs in x from index
x\_start to x\_end -- 1.

array\_max(x, x\_start, x\_end)

return maximum value of x from index x\_start to x\_end -- 1.

array\_min(x, x\_start, x\_end)

return minimum value of x from index x\_start to x\_end -- 1.

array\_max\_index(x, x\_start, x\_end)

return index of maximum value of x from index x\_start to x\_end -- 1.

array\_min\_index(x, x\_start, x\_end)

return index of minimum value of x from index x\_start to x\_end -- 1.

array\_isascending(x, x\_start, x\_end)

return true if and only if x from index x\_start to x\_end -- 1 is
sorted in ascending order.

array\_bubblesort(x, x\_start, x\_end)

perform bubblesort on x from index x\_start to x\_end -- 1.

array\_linearsearch(x, x\_start, x\_end, target)

perform linear search on x from index x\_start to x\_end -- 1 searching
for integer target and return its index in x.

array\_binarysearch(x, x\_start, x\_end, target)

perform binarysearch on x from index x\_start to x\_end -- 1 searching
for integer target and return its index in x.

Exercise: C-string library

Look at the chapter 18 Characters and C-strings. There are a bunch of
useful C-string functions in the C-string library. Implement your own
C-string library in files \emph{mystring.h} and \emph{mystring.cpp}.

strlen(s)

returns the string length of C-string s

strcpy(s, t)

copy string t to s

strclear(s)

after calling this function s becomes "". This is the same as strcpy(s,
"").

strcat(s, t)

concatenate t to s

strcmp(s, t)

returns 0 if C-strings s and t are the same strings

strreplace(s, source, target)

replace all occurrences of character source by character target. For
instance if s is "hello world", after calling strreplace(s,
\textquotesingle l\textquotesingle, \textquotesingle m\textquotesingle),
s becomes "hemmo wormd".

strleftstrip(s)

remove all whitespace characters (\textquotesingle{} \textquotesingle,
\textquotesingle\textbackslash n\textquotesingle,
\textquotesingle\textbackslash t\textquotesingle) on the left of s. For
instance if s is " abc ", after calling strleftstrip(s), s becomes "abc
".

strrightstrip(s)

remove all whitespace characters (\textquotesingle{} \textquotesingle,
\textquotesingle\textbackslash n\textquotesingle,
\textquotesingle\textbackslash t\textquotesingle) on the right of s. For
instance if s is " abc ", after calling strrightstrip(s), s becomes "
abc".

There are actually a lot more C-string functions that comes with your
C/C++ compiler.

Summary\\

A function prototype is a statement that looks like the header of a
function. For instance the prototype of the function

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 0\tabcolsep) * \real{1.0000}}@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
double f(int x, int y, char z)

\{

if (z == \textquotesingle a\textquotesingle)

\{

\vtop{\hbox{\strut  return x + y;}\hbox{\strut  \}}}

else

\{

\vtop{\hbox{\strut  return x * y;}\hbox{\strut  \}}\hbox{\strut \}}} \\
\end{longtable}

is just

\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
double f(int, int, char); \\
\end{longtable}

Once a prototype of a function f is given, the program can call the
function; the body of f need not be defined before f is called.

Prototypes of functions can be kept in a file and then ``\#include'' in
a cpp file. The definition of the functions can be kept in a different
cpp file.

\end{document}
