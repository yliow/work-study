\newpage\EMPHASIZE{26. Pointers}

\textsc{Objectives}

\begin{itemize}

\item
  Declare pointers
\item
  Assign values to pointers, address-of operator, and NULL
\item
  Comparison of address values
\item
  Use pointers as function parameters modify values
\item
  Use pointers as function parameters speedup function call
\item
  Returning references and pointers
\item
  Dynamic memory manage for non-array values
\item
  Memory deallocation and preventing memory leaks
\end{itemize}

Now we come to a concept that is extremely useful and powerful in CS.

Drumroll \ldots{} \emph{pointers!!!}

Pointers are variables that can hold physical memory addresses. By pointing a pointer to any memory location in your computer, you can access the data at that point in your computer's memory. Both data and code are stored in your computer memory. Therefore with pointers you can access any data and code. This has several consequences.

\begin{itemize}
\item
  Pointers allow you to write a function that allows pass-by- reference.
  In fact your references should really be thought of as pointers under
  the hood.
\item
  In terms of data, pointers allow you to access a part of your
  program's memory called the free store or memory heap. This allows you
  to control memory usage and have better control over memory
  management, requesting memory only when you need it and releasing it
  back to the system when it's not needed.
\item
  By embedding pointer values into data, we can create very complex
  relations between data values by linking them together. This allows
  you to build data structures to model trees, graphs, etc. Graphs are
  probably one of the most important mathematical structures in CS. A
  road network is basically a graph. A computer network is basically a
  graph. Social graph that describes person-to-person relationship in
  social media is basically a graph. Etc., etc., etc., etc., etc.
  \ldots{} !!!
\item
  Since code also lives in your computer's memory, pointers can also
  point to code such as functions. With pointers, you can actually pass
  functions (technically speaking the memory location of functions) into
  functions, i.e., functions can become arguments.
\end{itemize}

\begin{itemize}
\item
  Nowadays, hardware devices are usually ``mapped'' to memory locations
  too. That means that pointers can also be used to access devices to
  perform I/O.
\item
  Etc!!! \ldots{} not to mention bizarre things like code that rewrites
  itself.
\end{itemize}

All the reasons have to do with using pointers to achieve some computational goals. Another really important reason why pointers are important is this: Pointers are not just some abstract idea of computations in the theoretical sense. Pointers are fundamental to actual computer architecture in the sense that pointers or memory addresses are understood by your hardware. For many programming languages, you cannot access pointers or memory addresses directly. Those languages will hide pointers away from programmers by providing some language feature(s) to achieve the same goal, bypassing pointers and memory addresses. This is no big deal if all you want to do is to achieve the high level computational goals. However, if you do need to dive into the guts of your computer, you will have to know pointers very well. This also means that people who are trained only in a language that does not provide means to access pointer or memory addresses will have problems doing low-level programming or will have problems fully understanding areas such as assembly language programming and computer architecture. And low level programming does happen in the real world for instance in the case of systems programming and game development.

Because the landscape of pointers is huge let me tell you what's the plan

\begin{itemize}

\item
  First I will talk about general concepts related to pointers: memory
  addresses, pointer values, pointer operations, etc. Another basic
  concept you need to know is pointer arithmetic. But I'll delay pointer
  arithmetic till the second set of notes on pointers so that we can go
  into some applications of pointers quickly
\item
  For the first application of pointers, we'll see that pointers allow
  us to directly access and manipulation data from anywhere. In
  particular, a function can access data that is in another function.
  You recall that this is exactly what references are used for. In fact
  your C++ compiler actually converts references to pointers. So
  understanding pointers is absolutely crucial to understanding
  references. And if you know pointers well, you don't even need
  references. In fact in the original C language -- the ancestor of C++
  -- there is no concept of references.
\item
  The second application is similar to the first: we'll call functions
  with pointers (we'll also look at passing in reference) and possibly
  returning pointers (we'll also look at returning reference). In this
  case, the goal is to speed up function call.
\item
  For the third application, we'll go into an area in your computer
  called the heap and perform dynamic memory management ourselves. (The
  heap is also called the free store.) This means that we can ask the
  heap to give us an \emph{int} value when we need it and give the
  \emph{int} value back to the heap when we're done with it. This is
  very different from using an \emph{int} value that belongs to an
  \emph{int} variable. For an \emph{int} variable, the value exists when
  you declare the \emph{int} variable. The value is given back to the
  computer when the variable goes out of scope. You don't have as much
  control over memory usage for your regular variables. To use the heap
  ... you must use pointers.
\end{itemize}

In the next set of notes on pointers, I'll talk about pointer arithmetic, the relationship between pointers and arrays, and dynamic memory management of (dynamic) arrays.

Here we go \ldots{} !!!

\newpage\EMPHASIZE{Memory}

So far the model of the space where variables live does not have any organization. It's just a collection of cells with names and values.

Now for a more accurate model \ldots{}

\begin{itemize}
\item
  A computer's memory is made up of a linear collection of memory cells
  - each is a byte (i.e. 8 bits)
\item
  Each memory cell has a numeric address, its memory address
\item
  Each memory cell can hold 1 byte of data (1 byte = 8 bits)
\end{itemize}

\begin{python}
from latextool_basic import *
p = Plot()
#p += Grid(x0=-5, x1=5, y0=-2, y1=10)
p += ellipse(-3, 4, 0, 5, linecolor='red')
p += Rect(-3, 8, 0, 9, label='1245057', linewidth=0.0)
p += Rect(-3, 7, 0, 8, label='1245056', linewidth=0.0)
p += Rect(-3, 6, 0, 7, label='1245055', linewidth=0.0)
p += Rect(-3, 5, 0, 6, label='1245054', linewidth=0.0)
p += Rect(-3, 4, 0, 5, label='1245053', linewidth=0.0)
p += Rect(0, 9, 3, 10, label='...', linewidth=0.0)
p += Rect(0, 8, 3, 9, label='0101010', linewidth=0.1)
p += Rect(0, 7, 3, 8, label='1010001', linewidth=0.1)
p += Rect(0, 6, 3, 7, label='00011011', linewidth=0.1)
p += Rect(0, 5, 3, 6, label='01000100', linewidth=0.1)
p += Rect(0, 4, 3, 5, label='01100000', linewidth=0.2, linecolor='red')
p += Rect(5, 4, 7, 5, label='Cell', linewidth=0.2, linecolor='red')
p += Line(points=[(5,4.5), (3,4.5)], linecolor='red',linewidth=0.15, endstyle='>')
p += Rect(-7, 4, -5, 5, label='Address', linewidth=0.2, linecolor='red')
p += Line(points=[(-5,4.5),(-3,4.5)], linecolor='red',linewidth=0.15, endstyle='>')
p += Rect(7, 6.5, 11.5, 8.5, label='VERY IMPORTANT!!!', linewidth=0.2, linecolor='red')
p += Line(points=[(7, 7.5), (4, 7)], linecolor='red',linewidth=0.15, endstyle='>')
p += Rect(-3, 2, 0, 3, label='3', linewidth=0)
p += Rect(-3, 1, 0, 2, label='2', linewidth=0)
p += Rect(-3, 0, 0, 1, label='1', linewidth=0)
p += Rect(-3, -1, 0, 0, label='0', linewidth=0)
#
p += Rect(0, 3, 3, 4, label='...', linewidth=0.0)
p += Rect(0, 2, 3, 3, label='00100101', linewidth=0.1)
p += Rect(0, 1, 3, 2, label='11110010', linewidth=0.1)
p += Rect(0, 0, 3, 1, label='00110101', linewidth=0.1)
p += Rect(0, -1, 3, 0, label='10010001', linewidth=0.1)
p += Rect(0, -2, 3, -1, label='...', linewidth=0.0)

print(p)
\end{python}

Remember: Each memory cell has \EMPHASIZE{two} quantities, the \EMPHASIZE{memory address} and the \EMPHASIZE{content.}

Notice that memory addresses are \EMPHASIZE{integer values}.

When you declare a variable, based on the type, C++ will allocate the correct number of bytes for that variable. For example, for an \emph{int}, your

C++ (on a 32-bit machine) will allocate 4 bytes.

Also, when you declare two variables in the same scope, the memory used do not overlap -- they occupy different memory spaces.

\newpage\EMPHASIZE{Memory addresses and memory address of a variable}

In C++, if \verb!x! is a variable, the \EMPHASIZE{memory address} of \verb!x! is \EMPHASIZE{\texttt{\&x}}.

Try this:

\begin{consolethree}[escapeinside=||]
int x = 123;

std::cout << "val of x = " << x << '\n'
          << "addr of x = " << |\EMPHASIZE{\&x}| << '\n';
\end{consolethree}

My output:

\begin{consolethree}[escapeinside=||]
val of x is 123

addr of x is 1245052
\end{consolethree}
(Your output is most probably going to be different from mine.) The \EMPHASIZE{\&} in the above is called the \EMPHASIZE{address-of operator}.

Two things you must know right away \ldots{}

First, technically speaking \emph{\&x} is the \EMPHASIZE{address of the }\emph{\EMPHASIZE{value}}\EMPHASIZE{ of }\texttt{\EMPHASIZE{x}}. But I will sometimes call \texttt{\&x} the \EMPHASIZE{address of }\texttt{\EMPHASIZE{x}} since that's the common practice.

Second, in reality, an \texttt{int} value takes up more than 1 byte. For a 32-bit machine, the value of \texttt{x} is spread out among 4 bytes: Recall that to see how many bytes are used to store an integer value you can do this:

\begin{consolethree}[escapeinside=||]
std::cout << sizeof(int) << std::endl;
\end{consolethree}
So in the above example when the program says that the address of \texttt{x} is 1245052, it means that the \texttt{int} value 123 occupies the memory at addresses 1245052, 1245053, 1245054, 1245055. The \EMPHASIZE{address of }\texttt{\EMPHASIZE{x}} actually refers to the \EMPHASIZE{starting address}, i.e., address of the first byte, i.e. 1245052.
\xsidebox[0cm]{0cm}{}{refx}{\texttt{\&x} = address of first byte of the value of variable \texttt{x}}

You don't have to worry about how the value 123 is ``spread out'' among 4 bytes. But briefly, the integer 123 (to human beings) is a bunch of bits (to a 32-bit computer):
\begin{center}
00000000000000000000000001111011
\end{center}
(Details will be covered in CISS360.) So here's where you will find the value of our \texttt{x} from above:
\begin{python}
from latextool_basic import *
p = Plot()
p += Rect(-3, 8, 0, 9, label='1245057', linewidth=0.0)
p += Rect(-3, 7, 0, 8, label='1245056', linewidth=0.0)
p += Rect(-3, 6, 0, 7, label='1245055', linewidth=0.0)
p += Rect(-3, 5, 0, 6, label='1245054', linewidth=0.0)
p += Rect(-3, 4, 0, 5, label='1245053', linewidth=0.0)
p += Rect(-3, 3, 0, 4, label='1245052', linewidth=0.0)
p += Rect(-3, 0, 0, 1, label='0', linewidth=0.0)
p += Rect(0, 9, 3, 10, label='...', linewidth=0.0)

p += Rect(0, 8, 3, 9, label=' ', linewidth=0.1)
p += Rect(0, 7, 3, 8, label=' ', linewidth=0.1)
p += Rect(0, 6, 3, 7, label='01111011', linewidth=0.1)
p += Rect(0, 5, 3, 6, label='00000000', linewidth=0.1)
p += Rect(0, 4, 3, 5, label='00000000', linewidth=0.1)
p += Rect(0, 3, 3, 4, label='00000000', linewidth=0.1)
p += Rect(0, 2, 3, 3, label=' ', linewidth=0.1)
p += Rect(0, 2, 3, 3, label=' ', linewidth=0.1)
p += Rect(0, 1, 3, 2, label='...', linewidth=0.0)
p += Rect(0, 0, 3, 1, label=' ', linewidth=0.1)

print(p)
\end{python}
Notice that 123 is translated to 32 bits. Each byte can hold 8 bits. That's why the bits of an integer requires 4 bytes. At this point, we don't need to worry how the 123 is translated into bits. So I will usually simplify the above picture of your computer's memory by drawing this:
\begin{python}
from latextool_basic import *
p = Plot()
p += Rect(-3, 8, 0, 9, label='1245057', linewidth=0.0)
p += Rect(-3, 7, 0, 8, label='1245056', linewidth=0.0)
p += Rect(-3, 6, 0, 7, label='1245055', linewidth=0.0)
p += Rect(-3, 5, 0, 6, label='1245054', linewidth=0.0)
p += Rect(-3, 4, 0, 5, label='1245053', linewidth=0.0)
p += Rect(-3, 3, 0, 4, label='1245052', linewidth=0.0)
p += Rect(-3, 0, 0, 1, label='0', linewidth=0.0)
p += Rect(0, 9, 3, 10, label='...', linewidth=0.0)

p += Rect(0, 3, 3, 7, label='\EMPHASIZE{123}', background='blue!10!white', linewidth=0.0)
p += Rect(0, 8, 3, 9, label=' ', linewidth=0.1)
p += Rect(0, 7, 3, 8, label=' ', linewidth=0.1)
p += Rect(0, 6, 3, 7, label=' ', linewidth=0.02)
p += Rect(0, 5, 3, 6, label=' ', linewidth=0.02)
p += Rect(0, 4, 3, 5, label=' ', linewidth=0.02)
p += Rect(0, 3, 3, 4, label=' ', linewidth=0.02)
p += Rect(0, 2, 3, 3, label=' ', linewidth=0.1)
p += Rect(0, 2, 3, 3, label=' ', linewidth=0.1)
p += Rect(0, 1, 3, 2, label='...', linewidth=0.0)
p += Rect(0, 0, 3, 1, label=' ', linewidth=0.1)

print(p)
\end{python}
Let me summarize ...

\begin{itemize}
\item
  A computer's memory is made up of bytes.
\item
  Associated to each byte is its address and its contents (value).
\item
  The value of a variable occupies memory, possibly more than 1 byte.
\item
  If \texttt{x} is a variable, then in C++
\item
  \texttt{x} refers to the contents (value)
\item
  \texttt{\&x} refers to the beginning address of its value, i.e., the
  address of the first byte of its value
\end{itemize}

By the way the address printed when you run your program might contain things like a, c, e, etc. That's because the address is actually printed in \EMPHASIZE{hexadecimals}, i.e., \EMPHASIZE{numbers in base 16}. (You will also learn more about hexadecimals in CISS360.) Certain compilers allow you to typecast hexadecimal values into \texttt{int} value. Try the following (don't panic and call 911 if your compiler won't let you):

\begin{consolethree}[escapeinside=||]
int x = 123;

std::cout << "val of x: " << x
          << '\n' << "addr of x: " << |\textbf{int(\&x)}||\xsidebox[0cm]{0cm}{}{addrx}{'An integer can be written (expressed) in many ways ... in\\-base 10 or decimal (usual way)\\-base 16 or hexadecimal\\-base 8 or octals\\-base 2 or bits'}{}|
          << '\n';
\end{consolethree}

If it does not work, you can use any scientific calculator to convert from hex to decimals yourself. Most scientific calculators nowadays have the ability to convert between base 10 to base 2, 8, and 16.

In almost all programming languages, a hexadecimal number starts with 0x. So you might see something like this when working with address values:
\begin{center}
0x013251a2
\end{center}
The actual base 16 hexadecimal is 13251a2.

Technically speaking the memory address is an \EMPHASIZE{unsigned integer}, i.e., it does not have a negative sign, i.e., it's a positive integer. So you can convert your memory address value to an unsigned integer like this:

\begin{consolethree}[escapeinside=||]
int x = 123;
std::cout << "val of x: " << x
          << '\n' << "addr of x: "
          << |\EMPHASIZE{(unsigned int)(\&x)}|
          << '\n';
\end{consolethree}
An \texttt{\textbf{unsigned int}} can only represent integers up to $2^{32} - 1$. If you have a newer laptop, your address values are very likely larger than $2^{32} - 1$. If your compiler yells at you, instead of type casting with \texttt{\textbf{unsigned int}}, use \texttt{\textbf{unsigned long long int}}.

An \texttt{\textbf{unsigned int}} is really a type. So you can declare an \texttt{\textbf{unsigned int}} variable. By the way, you have actually already seen \texttt{\textbf{unsigned int}} when using \texttt{\textbf{srand()}}. Likewise \texttt{\textbf{unsigned long long int}} is also a type.

\begin{ex} Find a scientific calculator program that can convert between base 10 and base 2, 8, and 16. (If you have time, use the web and learn to convert between base 10 and base 2, 8, 16 by hand -- this will be covered in detail in CISS360.)
\begin{itemize}
\item
  Convert 42 into base 2, 6, 16.
\item
  Convert base 16 a0234d1 to base 10.
\end{itemize}
\end{ex}

\begin{ex}
Declare two integer variables like this:
\begin{consolethree}[escapeinside=||]
int x;
int y;
\end{consolethree}
and print their addresses (in base 10). How far apart are the addresses of the two integer values of the variables? (Use your scientific calculator for subtracting two hexadecimal address values if you need to.) If the address differs by 4 (and the sizeof int is 4), then there's no gap between the memory occupied by the first and the second since an integer occupies 4 bytes. This means that your compiler is very efficient and is putting the value of \texttt{x} and \texttt{y} next to each other. (The address of the second variable is probably smaller.)
\end{ex}
\begin{ex}
This simple exercise is meant to make your brain remember \texttt{unsigned int}.

\begin{enumerate}
\item
  Declare an \texttt{unsigned int} variable \texttt{i} and initialize it
  with value 42. Print \texttt{i}. Get a positive integer from the user
  and give this value to \texttt{i}. Print \texttt{i}.
\item
  Write a simple program that computes the sum 1 + 2 + \ldots{} +
  \texttt{i} where \texttt{i} is provided by the user. Print the sum. In
  your program, since all integer values used are positive, you must
  only use \texttt{unsigned int} variables.
\end{enumerate}
\end{ex}

\begin{ex}
Declare a \texttt{double} variable \texttt{x}. Print it's address. Now declare another \texttt{double} variable \texttt{y} and print the address of \texttt{y}. There shouldn't be a gap between the \texttt{double} values of the above variables if they are declared next to each other. From the program can you deduce the number of bytes used to store a \texttt{double}? Verify your guess by executing this:
\begin{consolethree}[escapeinside=||]
double x = 3.14159;
std::cout << sizeof(double) << std::endl;
std::cout << sizeof(x) << std::endl;
\end{consolethree}
\end{ex}

\begin{ex}

\begin{enumerate}
\item
  How many bytes does a character variable/value use?
\item
  How many bytes does a boolean variable/value use?
\end{enumerate}
\end{ex}

\begin{ex}
Declare an array of integers:
\begin{consolethree}[escapeinside=||]
int x[3];
\end{consolethree}

and print their address of \texttt{x[0]} and \texttt{x[1]} and
\texttt{x[2]}. How far apart are they? Are the addresses ascending or
descending?
\end{ex}

\EMPHASIZE{WARNING!!!}

Note that \texttt{\&} is now used in two totally different ways!!!

\begin{consolethree}[escapeinside=||]
int x;
int & y = x;     // int & is a type
std::cout << &x; // & is the address-of operator
\end{consolethree}
Remember that!

\newpage\EMPHASIZE{Pointer Variable}

At this point, you should ask the following question: ``If you can put \texttt{int} values into \texttt{int} variables, \texttt{double} values into \texttt{double} variables, \texttt{bool} values into \texttt{bool} variables \ldots{} surely I can put address values into variables, right?'' (If you did not ask that, then you're not learning actively! Wake up!)

So here we go \ldots{}

A \EMPHASIZE{pointer variable} is a variable whose value is a memory
address. Run this:

\begin{consolethree}[escapeinside=||]
int x = 1;

int * p;|\tikzmarknode{c26p0_anchor}\\\\\\|

p = &x;         

std::cout << &x << ' ' << p << std::endl;
\end{consolethree}
\xsidebox[1cm]{-4cm}{}{c26p0}{\texttt{p} is a pointer to an \texttt{int}}
\DrawArrowVH{c26p0}{c26p0_anchor}
\newpage
We say that \texttt{p} \EMPHASIZE{points to} \texttt{x} (well ... technically, \texttt{p} points to the \texttt{\textbf{value}} of \texttt{x}.) To declare a pointer variable you use this format:
\begin{center}
\texttt{[type]} * \texttt{[pointer]};
\end{center}
You can of course do this, i.e. declaration with initialization:

\begin{consolethree}[escapeinside=||]
int x = 1;
int * p = &x;
std::cout << &x << ' ' << p << std::endl;
\end{consolethree}
Here's the format of a statement that declares a pointer with
initialization:

\begin{center}
\texttt{[type]} * \texttt{[pointer] = [address of same type]};
\end{center}

A very common convention is to begin the name of a pointer with \texttt{p} or \texttt{p\_}. It's also common to include the name of the concept the pointer points to in the name:

\begin{ex}
Complete this code segment. \texttt{psalary} should
point to \texttt{salary:}

\begin{consolethree}[escapeinside=||]
double salary = 100.23;

______ * psalary = _________;
\end{consolethree}
Verify!!! \ldots{} i.e., print the address of \texttt{salary} and \texttt{psalary} and make sure they are the same.
\end{ex}

\begin{ex}
Can you assign the address of a type of value to a pointer variable of another type? Answer: \verb!_____________.! Try this:

\begin{consolethree}[escapeinside=||]
double x = 1.2;
int * p = &x; // trying to point an int pointer
              // to a double
\end{consolethree}
\end{ex}
You \EMPHASIZE{cannot} initialize a pointer with the pointer value of a \EMPHASIZE{different type}.

\begin{ex}
Here's an \texttt{int} array:

\begin{consolethree}[escapeinside=||]
int x[] = {2, 3, 5, 7, 11, 13};
\end{consolethree}
\end{ex}

Declare an \texttt{int} pointer, say call it \texttt{p}, that points to the value 11 in the array. Verify! Next, print the address of the value 13 and 7 in \texttt{x}.

\begin{ex}
Here's a C-string:

\begin{consolethree}[escapeinside=||]
char x[] = "hello world";
\end{consolethree}
\end{ex}
Declare a \texttt{char} pointer, say call it \texttt{p}, that points to the
'w' in the string. Verify!

\newpage\EMPHASIZE{Mental Picture}

Look at this code:

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p;
p = &x;
\end{consolethree}

Suppose the \texttt{int} value of x is at memory location 124500 in the computer and the memory location is at 124504. The computer's memory would look like this:
\begin{python}
from latextool_basic import *
p = Plot()
p += Rect(-3, 9, 0, 10, label='124508', linewidth=0.0)
p += Rect(-3, 8, 0, 9, label='124507', linewidth=0.0)
p += Rect(-3, 7, 0, 8, label='124506', linewidth=0.0)
p += Rect(-3, 6, 0, 7, label='124505', linewidth=0.0)
p += Rect(-3, 5, 0, 6, label='124504', linewidth=0.0)
p += Rect(-3, 4, 0, 5, label='124503', linewidth=0.0)
p += Rect(-3, 3, 0, 4, label='124502', linewidth=0.0)
p += Rect(-3, 2, 0, 3, label='124501', linewidth=0.0)
p += Rect(-3, 1, 0, 2, label='124500', linewidth=0.0)
#
p += Rect(0, 5, 3, 9, label='\EMPHASIZE{124500}', linewidth=0.0, background='gray!45!white!')
p += Rect(0, 1, 3, 5, label='\EMPHASIZE{42}', linewidth=0.0, background='gray!25!white!')
#
p += Rect(0, 10, 3, 11, label='\EMPHASIZE{...}', linewidth=0)
p += Rect(0, 9, 3, 10, label=' ', linewidth=0.1)
p += Rect(0, 8, 3, 9, label=' ', linewidth=0.05)
p += Rect(0, 7, 3, 8, label=' ', linewidth=0.05)
p += Rect(0, 6, 3, 7, label=' ', linewidth=0.05)
p += Rect(0, 5, 3, 6, label=' ', linewidth=0.05)
p += Rect(0, 4, 3, 5, label=' ', linewidth=0.05)
p += Rect(0, 3, 3, 4, label=' ', linewidth=0.05)
p += Rect(0, 2, 3, 3, label=' ', linewidth=0.05)
p += Rect(0, 1, 3, 2, label=' ', linewidth=0.05)
p += Rect(0, 0, 3, 1, label=' ', linewidth=0.05)
p += Rect(0, -1, 3, 0, label=' ', linewidth=0.05)
p += Rect(0, -2, 3, -1, label=' ', linewidth=0.05)
p += Rect(0, -3, 3, -2, label='\EMPHASIZE{...}', linewidth=0)
print(p)
\end{python}

Here's the memory model that you are already used to:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, 1.5, 5, 5.5)

p += Rect(0.5, 2.5, 0.5, 2.5, label='p')
p += Rect(1, 2, 4, 3, label='124500')

p += Rect(0.5, 4.5, 0.5, 4.5, label='x')
p += Rect(1, 4, 4, 5, label='42')

print(p)
\end{python}

To indicate that the value 42 of variable x is at memory address 124500,
I will draw this:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, 1.5, 5, 5.5)

p += Rect(1.5, 5.25, 1.5, 5.25, label='124500')
p += Rect(0.5, 2.5, 0.5, 2.5, label='p')
p += Rect(1, 2, 4, 3, label='124500')

p += Rect(0.5, 4.5, 0.5, 4.5, label='x')
p += Rect(1, 4, 4, 5, label='42')

print(p)
\end{python}

Well \ldots{} actually important thing is the \EMPHASIZE{relationship} between \texttt{p} and the value of \texttt{x}: Think of \texttt{p} as knowing where to find the value of \texttt{x}. So we usually have this mental picture in mind when we talk about pointers:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, 1.5, 5, 5.5)

xbawx = Rect(1, 2, 4, 3, label='124500')

p += xbawx
p += Rect(0.5, 4.5, 0.5, 4.5, label='x')
p += Rect(1, 4, 4, 5, label='42')

pbawx = Rect(1.5, 5.25, 1.5, 5.25, label='124500')
p += pbawx
p += Rect(0.5, 2.5, 0.5, 2.5, label='p')

p += Line(points=[(3.5, 2.5), (4.5, 2.5), (4.5, 4.5), (2.8, 4.5)], linewidth=0.15, endstyle='>')
print(p)
\end{python}

Sometimes, I will even simplify the mental picture by drawing this:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, 1.5, 5, 5.5)

xbawx = Rect(1, 2, 4, 3, label='124500')

p += xbawx
p += Rect(0.5, 4.5, 0.5, 4.5, label='x')
p += Rect(1, 4, 4, 5, label='42')

#pbawx = Rect(1.5, 5.25, 1.5, 5.25, label='124500')
#p += pbawx
p += Rect(0.5, 2.5, 0.5, 2.5, label='p')

p += Line(points=[(3.5, 2.5), (4.5, 2.5), (4.5, 4.5), (2.8, 4.5)], linewidth=0.15, endstyle='>')
print(p)
\end{python}

(Later, we'll see how to access access the value of x using p.)

Note that the arrow drawn in the diagram is to help us (human beings) see quickly what value a pointer is pointing to. Your computer only works with numbers (as in bits). The arrows in the drawing above are only a visual guide for us to see pointer relations quickly. There are no ``hardware arrows'' in your computer or CPU!!! Remember that!!!

\begin{ex}
In a code fragment, there are two variables \texttt{i} and \texttt{j}, both of \texttt{int} type. The value of \texttt{i} is 5000 and the value of \texttt{j} is 6000. The value of \texttt{i} is at address 108080 and the address of the value of \texttt{j} is 501200. In addition, there are two pointer variables \texttt{p} and \texttt{q} such that \texttt{p} points to the value of \texttt{j} and \texttt{q} points to the value of \texttt{i}. Draw the memory model labeling everything (variable name, value, and address). Include arrows to relate pointers to the values the pointers point to.
\end{ex}

\begin{ex}
Same as above except that both \texttt{p} and \texttt{q}
points to the value of \texttt{j}.
\end{ex}

\begin{ex}
Draw the memory model at the end of the following code fragment where the addresses of \texttt{pi[0]}, \texttt{pi[1]}, \texttt{pi[2]}, \texttt{pi[3]}, \texttt{pi[4]} are 8000, 8008, 8016, 8024, 8032, 8040.
\end{ex}

\begin{consolethree}[escapeinside=||]

double pi[] = {3.1, 3.14, 3.141, 3.1415, 3.14159};

double * p = &pi[1];
\end{consolethree}

\begin{ex}
Draw the memory model at the end of the following code fragment:

\begin{consolethree}[escapeinside=||]

int x[] = {2, 3, 5, 7, 11};

int * p = &x[3];

int * q = &x[1];
\end{consolethree}
(In this case, addresses of \texttt{x[0]}, \texttt{x[1]}, \ldots{}
are not given, so just draw the simplified mental picture.)
\end{ex}

\begin{ex}
Given the following:

\begin{consolethree}[escapeinside=||]

int x = 42; // address is 5000

double y = 3.1415; // address is 5004

char z = '$'; // address is 5012

bool b = true; // address is 5016
\end{consolethree}

Declare 4 pointers (of the right type!) to point the each of the above variables. Draw the memory model.
\end{ex}

\begin{ex}
Write a code fragment so that you get the following memory model:

\begin{python}
from latextool_basic import *
p = Plot()
#outline
p += Rect(0, -7, 12, 10)

#pointer boxes
abox = Rect(2, 8, 3.5, 9, label="'a'")
bbox = Rect(2, 6, 5, 7, label='2.718')
cbox = Rect(2, 4, 4, 5)
dbox = Rect(2, 2, 4, 3)
ebox = Rect(2, 0, 4, 1, label='false')
fbox0 = Rect(2, -2, 4, -1, label='2')
fbox1 = Rect(4, -2, 6, -1, label='5')
fbox2 = Rect(6, -2, 8, -1, label='3')
fbox3 = Rect(8, -2, 10, -1, label='7')
gbox = Rect(2, -4, 4, -3)
hbox = Rect(2, -6, 4, -5)

p += abox
p += bbox
p += cbox
p += dbox
p += ebox
p += fbox0
p += fbox1
p += fbox2
p += fbox3
p += gbox
p += hbox

#add labels
a = Rect(1.5, 8.5, 1.5, 8.5, label='a')
b = Rect(1.5, 6.5, 1.5, 6.5, label='b')
c = Rect(1.5, 4.5, 1.5, 4.5, label='c')
d = Rect(1.5, 2.5, 1.5, 2.5, label='d')
e = Rect(1.5, 0.5, 1.5, 0.5, label='e')
f = Rect(1.5, -1.5, 1.5, -1.5, label='f')
g = Rect(1.5, -3.5, 1.5, -3.5, label='g')
h = Rect(1.5, -5.5, 1.5, -5.5, label='h')

p += a
p += b
p += c
p += d
p += e
p += f
p += g
p += h

#arrow paths
#c->a
p += Line(points=[(2.5,4.5), (7.5, 4.5), (7.5, 8.5), (3.5, 8.5)], linewidth=0.1, endstyle='>')
#d->f
p += Line(points=[(2.5,2.5), (9,2.5), (9, -1)], linewidth=0.1, endstyle='>')
#g->b
p += Line(points=[(2.5, -3.5), (10, -3.5), (10,6.5), (5,6.5)], linewidth=0.1, endstyle='>')
#h->e
p += Line(points=[(2.5, -5.5),(6.5,-5.5),(6.5,0.5),(4,0.5)], linewidth=0.1, endstyle='>')

print(p)
\end{python}

\end{ex}

\newpage\EMPHASIZE{Common Gotcha}

This is a very common gotcha:

\begin{consolethree}[escapeinside=||]
int x = 0, y = 1;
int * p = &x, q = &y, r = &x;
\end{consolethree}
It won't work (does not compile) because the above actually means this:

\begin{consolethree}[escapeinside=||]
int x = 0, y = 1;
int * p = \&x;
int q = \&y;
int r = \&x;
\end{consolethree}
It should be

\begin{consolethree}[escapeinside=||]
int x = 0, y = 1;
int * p = \&x, * q = \&y, * r = \&x;
\end{consolethree}
or (better) just write this:

\begin{consolethree}[escapeinside=||]
int x = 0, y = 1;
int * p = \&x;
int * q = \&y;
int * r = \&x;
\end{consolethree}

\newpage\EMPHASIZE{Memory address values and NULL}

Up to this point I never assign constant address values directly to
pointer variables like this:

\begin{consolethree}[escapeinside=||]
int x = 42;         // say the value of x is at
                    // address 1205000
int * p = 1205000;  // p points to the value of x
\end{consolethree}
To begin with, the address of x is usually different each time you run your program and is definitely different on a different computer. So the above would be a terrible idea.

In general, assigning a constant to a pointer variable is rare. This happens when you're doing something very special such as very low level programming where you need to access hardware or doing embedded systems programming. For instance, say you know that an \texttt{unsigned int} value at memory location 20500080 is used for communication with a hardware device, you would do something like this:

\begin{consolethree}[escapeinside=||]
unsigned int * device = (unsigned int *) 20500080;
\end{consolethree}

After that, whenever the device outputs a value, it's sent to the \texttt{unsigned int} at this location and \texttt{device} pointer will be used to access this value.

Unless otherwise stated, for CISS240, 245, 350, you will never assign or work directly with a constant memory address value. The only exception is the memory address \EMPHASIZE{0}. However instead of using memory address 0 like this:

\begin{consolethree}[escapeinside=||]
int * p = 0;
double * q = 0;
char * r = 0;
\end{consolethree}
you use the predefined constant \texttt{\EMPHASIZE{NULL}} like this:

\begin{consolethree}[escapeinside=||]
int * p = NULL;
double * q = NULL;
char * r = NULL;
\end{consolethree}

In order to use \texttt{NULL}, you might have to \texttt{\#include <cstddef>} at the top of your code:

\begin{consolethree}[escapeinside=||]
#include <iostream>

|\EMPHASIZE{\#include <cstddef>}|

int main()
{
    int * p = NULL;
    double * q = NULL;
    char * r = NULL;
    return 0;
}
\end{consolethree}
Just to keep everything uniform, just make sure you include cstddef.

So what is the value at address 0???

Well the only important thing you need to know is this: \EMPHASIZE{you are not allowed to access the value at address 0.} Therefore \ldots{}

\EMPHASIZE{\texttt{NULL} is only used to indicate that a pointer variable is not pointing to anything useful}. (You can also use \texttt{\textbf{nullptr}} instead of \texttt{\textbf{NULL}}. For C++11 compliant compilers, \texttt{\textbf{nullptr}} and \texttt{\textbf{NULL}} are the same. C++11 ISO/IEC 14882 was released 9/2011.)

Because of the above, \texttt{NULL} is sometimes used to initialize a pointer variable before it is being used:

\begin{consolethree}[escapeinside=||]
int x = 1;
int * p = NULL;   // p does not point to anything yet

... p is not used for anything useful ...

p = \&x;          // now point p to x

... now p is used to do something useful ...
\end{consolethree}

\begin{ex}
Print \texttt{NULL}. (Don't forget to type cast.) What do you see? Remember!

For a pointer p with NULL value, the picture is of course like this:
\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0,0, 8, 3)
p += Rect(2, 1, 5, 2, label='0')
p += Rect(1.5, 1.5, 1.5, 1.5, label='p')

print(p)
\end{python}
\end{ex}    
It's common to draw it like this:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0,0, 8, 3)
p += Rect(2, 1, 5, 2)
p += Rect(1.5, 1.5, 1.5, 1.5, label='p')

p += Line(points=[(2, 1), (5, 2)], linewidth=0.01)
p += Line(points=[(2, 2), (5, 1)], linewidth=0.01)

print(p)
\end{python}

or like this:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0,0, 8, 3)
p += Rect(2, 1, 5, 2)
p += Rect(1.5, 1.5, 1.5, 1.5, label='p')

p += Line(points=[(3.5, 1.5), (6, 1.5), (6, 0.5)], linewidth=0.1, endstyle='>')

p += Line(points=[(5.65, 0.5), (6.35, 0.5)], linewidth=0.1)

p += Line(points=[(5.8, 0.25), (6.2, 0.25)], linewidth=0.1)

p += Line(points=[(5.9, 0), (6.1, 0)], linewidth=0.1)

print(p)
\end{python}


\newpage\EMPHASIZE{Dereferencing Pointers}

Recall: If \texttt{p} is a pointer, then the value of \texttt{p} is the \EMPHASIZE{memory address} of the value \texttt{p} is pointing to.

You can access the \EMPHASIZE{value} \texttt{p} is pointing to. That's call \EMPHASIZE{dereferencing} \texttt{p} and you do it using \EMPHASIZE{*p}. The \texttt{*} used in this way is called the \EMPHASIZE{dereferencing operator}. It's also called the indirection operator.

Try this:

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p;
p = \&x;

std::cout << x << ' ' << *p << '\n';

x = 0;
std::cout << x << ' ' << *p << '\n';

*p = 42;
std::cout << x << ' ' << *p << '\n';
\end{consolethree}
Suppose \texttt{\&x} is 124500, then the memory model looks like this:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, 1.5, 5, 5.5)

xbawx = Rect(1, 2, 4, 3, label='124500')
refbawx = Rect(8, 7, 12, 9, linecolor='red', linewidth=0.1, align='c', s='You can refer to this box using \\texttt{x} or \\texttt{*p}')
p += xbawx
p += refbawx
p += Rect(0.5, 4.5, 0.5, 4.5, label='x')
p += Rect(1, 4, 4, 5, label='42')
p += Line(points = [(8, 8), (2.5, 5)], linewidth=0.1, linecolor='red', endstyle='>')
pbawx = Rect(1.5, 5.25, 1.5, 5.25, label='124500')
p += pbawx
p += Rect(0.5, 2.5, 0.5, 2.5, label='p')

p += Line(points=[(3.5, 2.5), (4.5, 2.5), (4.5, 4.5), (2.8, 4.5)], linewidth=0.15, endstyle='>')
print(p)
\end{python}


\EMPHASIZE{MAKE SURE YOU SEE THE DIFFERENCE BETWEEN \texttt{p} and \texttt{*p}!!!:}

\begin{itemize}
\item
  \EMPHASIZE{\texttt{p} is 124500}
\item
  \EMPHASIZE{\texttt{*p} is 42}
\end{itemize}

\EMPHASIZE{WARNING:}

There are now \EMPHASIZE{3 different meanings for *}!!!

\begin{consolethree}[escapeinside=||]
int x = 2 * 3;           // * = multiplication
int * p = &x;            // * = for pointer type
std::cout << x
          << ',' << *p   // * = for dereferencing
          << '\n';
\end{consolethree}
It's really important to remember that if a pointer \texttt{p} points to a box, then the dereference of \texttt{p}, i.e. \texttt{*p}, refer to the contents or the ``inside'' of the box.

In particular, if I give you this picture without showing you the name of the variable with a value of 23:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0,0, 8, 5)
p += Rect(2, 3, 5, 4, label='23')
p += Rect(2, 1, 5, 2)
p += Rect(1.5, 1.5, 1.5, 1.5, label='p')
p += Line(points=[(2.5, 1.5), (6.5, 1.5), (6.5, 3.5), (5, 3.5)], linewidth=0.05, endstyle='>')

print(p)
\end{python}

you tell me right away that \texttt{*p} is 23. You don't need to know the variable name of that box.

Note that \texttt{*p} refers to the contents of the box \texttt{p} points to in two ways and can be used in two ways, for reading and for writing:

\begin{itemize}
\item
  you can use \texttt{*p} to \EMPHASIZE{read} the value that \texttt{p} points
  to
\item
  you can use \texttt{*p} to \EMPHASIZE{overwrite} the value \texttt{p} points
  to
\end{itemize}

For instance:

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p = &x;
int i;
i = *p;         // read the value that p points to (and
                // give it to i)
*p = 100;       // write the value (i.e. 100) onto the
                // value that p points to
\end{consolethree}


So \texttt{*p} can appear on either the right or the left of the
assignment operator.

\begin{ex}
An \EMPHASIZE{lvalue} is something that can appear on the left of = (the assignment operator). An \EMPHASIZE{rvalue} is something that can appear on the the right of =. You have just seen that \texttt{*p} is is both an lvalue and an rvalue.
\begin{itemize}

\item
  Is 42 an lvalue? An rvalue?
\item
  Suppose \texttt{x} is a variable. Is \texttt{x} an lvalue? An rvalue?
\item
  Suppose \texttt{c} is a constant. Is \texttt{c} an lvalue? An rvalue?
\item
  Suppose \texttt{f()} is a function with void return type. Is \texttt{f} an
  lvalue? An rvalue?
\item
  Suppose \texttt{f()} is a function with \texttt{int} return type. Is
  \texttt{f} an lvalue? An rvalue?
\end{itemize}
\end{ex}

Let me repeat the above. Suppose the address value in \texttt{p} is 124500. Then if you see something like

\begin{consolethree}[escapeinside=||]
a = b + *p + c;
\end{consolethree}

you should think of it as

\begin{consolethree}[escapeinside=||]
a = b + (the value at address 124500) + c;
\end{consolethree}

And if you see

\begin{consolethree}[escapeinside=||]
*p = b + c;
\end{consolethree}

you should think of it as

\begin{consolethree}[escapeinside=||]
store value of (b + c) at address 124500
\end{consolethree}

In summary,
\begin{python}
from latextool_basic import table
print(table([(1, 2, 3),
(2, 2, 5),
(5, 2),
(-1, 2, 6),
(1, 2, 3),
]))
#print(table[("\texttt{*p}", "Statement", "Same as"), ("lvalue", "\texttt{*p = ...}", "store ... in memory at address \texttt{p}"), ("rvalue", "\texttt{... = ... *p}", "... = ... (value in memory at address \texttt{p}) ...")])
\end{python}

\begin{ex}
Add one statement to the following:
\begin{consolethree}[escapeinside=||]
int x = 0;
int * p = &x;

// add one statement here to change the value of x
// to 42. Do NOT use the variable name x in your
// statement.

std::cout << x << '\n';
\end{consolethree}
\end{ex}

\begin{ex}
Add one statement to this code fragment so that the
output is 3.1415:
\begin{consolethree}[escapeinside=||]
// p is a pointer variable that points to a double

// add one statement below this line



std::cout << *p << '\n';
\end{consolethree}
\end{ex}

\begin{ex}
What is the output of this program:
\begin{consolethree}[escapeinside=||]
int x = 2;
int * p = &x;
*p = *p + *p;
std::cout << x << '\n';
\end{consolethree}
(Hint: Draw a picture)
\end{ex}

\begin{ex}
What is the output of this program?

\begin{consolethree}[escapeinside=||]
int x = 2;
int y = 42;
int * p = &x;
int * q = &y;
std::cout << *p + *q << '\n';
\end{consolethree}
(Hint: Draw a picture)
\end{ex}

\begin{ex}
What is the output of this program?
\begin{consolethree}[escapeinside=||]
int x = 2;
int y = 42;
int * p = &x;
int * q = &y;
*p = *p * 2 + *q;
std::cout << x << ' ' << y << '\n';
\end{consolethree}
(Hint: Draw a ...)
\end{ex}

\begin{ex}
What is the output of this program?
\begin{consolethree}[escapeinside=||]
int x = 2;
int y = 42;
int * p = &x;
int * q = &y;
*p = *p * *q;
std::cout << x << ' ' << y << '\n';
\end{consolethree}
(Hint: Draw, draw, draw ...)
\end{ex}

\begin{ex}
What is the output of this program?
\begin{consolethree}[escapeinside=||]
int x = 2;
int y = 42;
int * p = &x;
int * q = &x;
*p = *p * *q;
*q = 42;
std::cout << x << ' ' << y << '\n';
std::cout << *p << ' ' << *q << '\n';
\end{consolethree}
(Hint: Draw...)
\end{ex}

\begin{ex}
Do a simple addition program using the following skeleton.
\begin{consolethree}[escapeinside=||]
int x = 0, y = 0;
int * p = &x;
int * q = &y;
// Statement to prompt the user for an integer and
// put it into x. Do NOT use x in your statement.

// Statement to prompt the user for an integer and
// put it into y. Do NOT use y in your statement.

std::cout << x + y << '\n';
\end{consolethree}
\end{ex}

\begin{ex}
Declare a \texttt{double} variable called \texttt{d} and initialize it to 3.14. Declare a \texttt{double} pointer to point to \texttt{d}; call it \texttt{q}. Print \texttt{d} and \texttt{*q}. Add 1 to the value of \texttt{d} using \texttt{d}. Print \texttt{d} and \texttt{*q}. Add 1 to the value of \texttt{d} but using \texttt{q}. Print \texttt{d} and \texttt{q}.
\end{ex}

\begin{ex}
What is the output of this code fragment:

\begin{consolethree}[escapeinside=||]
int x[] = {5, 4, 3, 2, 1};

for (int i = 4; i >= 0; -\/-i)
{   
    int * p = &x[i];
    std::cout << (*p) << std::endl;
}
\end{consolethree}
\end{ex}

\begin{ex}
Here's a program you are familiar with:

\begin{consolethree}[escapeinside=||]
int s = 0;

for (int i = 0; i <= 100; i++)
{   
    s += i;
    std::cout << i << ' ' << s << '\n';
}

std::cout << "1 + ... + 100 = " << s << '\n';
\end{consolethree}
I'm going to add a pointer:

\begin{consolethree}[escapeinside=||]
int s = 0;
int * p = &s;
for (int i = 0; i <= 100; i++)
{   
    s += i;
    std::cout << i << ' ' << s << '\n';
}

std::cout << "1 + ... + 100 = " << s << '\n';
\end{consolethree}

Now modify the program so that it works the same as before but the variable name \texttt{s} is not used after the statement that declares \texttt{p}:
\end{ex}

\begin{consolethree}[escapeinside=||]
int s = 0;
int * p = &s;

// Modify code below so that variable name s is not
// used.

for (int i = 0; i < 100; i++)

{   
    s += i;
    std::cout << i << ' ' << s << '\n';
}

std::cout << "1 + ... + 100 = " << s << '\n';
\end{consolethree}
\begin{ex}
If you see this picture
\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0,0, 8, 5)
p += Rect(2, 3, 5, 4, label='\$')
p += Rect(2, 1, 5, 2)
p += Rect(1.5, 1.5, 1.5, 1.5, label='x')
p += Line(points=[(2.5, 1.5), (6.5, 1.5), (6.5, 3.5), (5, 3.5)], linewidth=0.05, endstyle='>')

print(p)
\end{python}

can you tell me what is the type of x?
\end{ex}
\begin{ex}
If you see this
\begin{consolethree}[escapeinside=||]
double x = a[*b]; 
\end{consolethree}

can you tell me what is the type of \texttt{b}?
\end{ex}

\begin{ex}
If you see this
\begin{consolethree}[escapeinside=||]
std::cout << x % (*y); 
\end{consolethree}

can you tell me what is the type of \texttt{y}?
\end{ex}

\begin{ex}
Complete this:

\begin{consolethree}[escapeinside=||]
void nextprime(int * p)
{

}

int main()
{   
    int x = 7;
    nextprime(&x); // x becomes 11
    std::cout << x << std::endl;
    nextprime(&x); // x becomes 13
    std::cout << x << std::endl;
    nextprime(&x); // x becomes 17
    std::cout << x << std::endl;
    return 0;
}
\end{consolethree}
\end{ex}

\begin{ex}
Can you apply the pre- and post-increment operators to \texttt{*p} where \texttt{p} is a pointer to an \texttt{int}?

\begin{consolethree}[escapeinside=||]
++(*p);

(*p)++;

--(*p);

(*p)--;
\end{consolethree}
\end{ex}

Do you need the parentheses? Can you apply the augmented assignment operators to \texttt{*p?}

Note that if you do not assign a memory address to your pointer, it would have an arbitrary address value, pointing to some arbitrary value.
Reading that value might result result in printing something that looks like garbage. It might even cause your program to crash if you do not have access rights to that location!!!

Another thing to note is that the dereferencing operator works with an address -- it does not have to be applied to a pointer. In other words if you're doing this:

\begin{consolethree}[escapeinside=||]
std::cout << *p << std::endl;
\end{consolethree}

and if you know that \texttt{p} has value 124500, then the above can also be

\begin{consolethree}[escapeinside=||]
std::cout << *124500 << std::endl;
\end{consolethree}

\begin{ex}
First get a strong cup of coffee \ldots{} now \ldots{} What is the output? Or is there an error?

\begin{consolethree}[escapeinside=||]
#include <iostream>

int * f(int * x)
{   
    return x;
}

int f(int x)
{   
    return x;
}

int main()
{   
    int a = 21;
    std::cout << *f(&a) + f(a) << std::endl;
    return 0;
}
\end{consolethree}
Verify! (Draw a picture if you need to.)
\end{ex}

\begin{ex}
Sip your coffee \ldots{} another one \ldots{} What is the output? Or is there an error?

\begin{consolethree}[escapeinside=||]
#include <iostream>

int h(int * z)
{   
    return *z;
}

int * g(int * y)
{   
    return y;
}

int * f(int * x)
{   
    return (&x == NULL ? NULL : g(x));
}

int main()
{   
    int a = 21;
    std::cout << *f(&a) + h(&a) << std::endl;
    return 0;
}
\end{consolethree}
Verify!
\end{ex}

\newpage\EMPHASIZE{Assignment Operator}

It's not too surprising that you can do assignments on pointers \ldots{}

First try to guess what this does:

\begin{consolethree}[escapeinside=||]
int x = 42;
int y = 123;

int * p = &x;
int * q = &y;
std::cout << *p << "\n";

p = q;
std::cout << *p << "\n";
\end{consolethree}
Now run it and verify.

Here are some pictures. Up to this point:

\begin{consolethree}[escapeinside=||]
int x = 42;
int y = 123;

int * p = &x;
int * q = &y;

std::cout << *p << "\n";
\end{consolethree}
the memory model looks like this:
\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, -1, 8, 8)
p += Rect(2, 6, 5, 7, label='42')
p += Rect(1.5, 6.5, 1.5, 6.5, label='x')
p += Rect(2, 4, 5, 5, label='123')
p += Rect(1.5, 4.5, 1.5, 4.5, label = 'y')
p += Rect(2, 2, 5, 3)
p += Rect(1.5, 2.5, 1.5, 2.5, label = 'p')
p += Rect(2, 0, 5, 1)
p += Rect(1.5, 0.5, 1.5, 0.5, label = 'q')
p += Line(points=[(3, 2.5), (7, 2.5), (7, 6.5), (5, 6.5)], linewidth=0.05, endstyle='>')
p += Line(points=[(3, 0.5), (6, 0.5), (6, 4.5), (5, 4.5)], linewidth=0.05, endstyle='>')

print(p)
\end{python}
The next statement

\begin{consolethree}[escapeinside=||]
p = q;
\end{consolethree}

gives the memory address in \texttt{q} to \texttt{p}. Since \texttt{q} has the memory address of \texttt{y}, this means that \texttt{p} ends up with the memory address of \texttt{y}. So we get:

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, -1, 8, 8)
p += Rect(2, 6, 5, 7, label='42')
p += Rect(1.5, 6.5, 1.5, 6.5, label='x', linecolor='white')
p += Rect(2, 4, 5, 5, label='123')
p += Rect(1.5, 4.5, 1.5, 4.5, label = 'y', linecolor='white')
p += Rect(2, 2, 5, 3)
p += Rect(1.5, 2.5, 1.5, 2.5, label = 'p', linecolor='white')
p += Rect(2, 0, 5, 1)
p += Rect(1.5, 0.5, 1.5, 0.5, label = 'q', linecolor='white')
p += Line(points=[(3, 2.5), (7, 2.5), (7, 4.75), (5, 4.75)], linewidth=0.05, endstyle='>')
p += Line(points=[(3, 0.5), (6, 0.5), (6, 4.25), (5, 4.25)], linewidth=0.05, endstyle='>')

print(p)
\end{python}

Since \texttt{p} points to \texttt{y}, or rather, \texttt{p} point to the \texttt{int} box that contains the value of \texttt{y}, of course \texttt{*p} gives us \texttt{123}.

Let me explain everything above all over again, this time using (made up) memory addresses \ldots{} \EMPHASIZE{PAY ATTENTION!}

Here's the above code again, except that I've included some made-up addresses for the value of \texttt{x} and the value of \texttt{y}:

\begin{consolethree}[escapeinside=||]
int x = 42;         // value of x is at address 80000
int y = 123;        // value of y is at address 80004

...
\end{consolethree}
At this point in the code
\xsidebox[0cm]{-1cm}{}{madeupx}{The addresses are made up. Don't worry about them. I just gave them values of x and y addresses to illustrate the concepts below}
\begin{consolethree}[escapeinside=||]
int x = 42;         // value of x is at address 80000
int y = 123;        // value of y is at address 80004

int * p = &x;       // p = 80000
int * q = &y;       // q = 80004
std::cout << *p << "\n";
\end{consolethree}
the picture looks like this:
\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, -1, 8, 8)
p += Rect(2.5, 7.25, 2.5, 7.25, label = '80000', linecolor='white')
p += Rect(2, 6, 5, 7, label='42')
p += Rect(1.5, 6.5, 1.5, 6.5, label='x')
p += Rect(2, 4, 5, 5, label='123')
p += Rect(2.5, 5.25, 2.5, 5.25, label = '80004', linecolor='white')
p += Rect(1.5, 4.5, 1.5, 4.5, label = 'y')
p += Rect(2, 2, 5, 3,label = '80000')
p += Rect(1.5, 2.5, 1.5, 2.5, label = 'p')
p += Rect(2, 0, 5, 1, label = '80004')
p += Rect(1.5, 0.5, 1.5, 0.5, label = 'q')

print(p)
\end{python}

and if I draw in arrows for pointers to help us see the pointer-to-value
relationship it would look like this:
\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, -1, 8, 8)
p += Rect(2.5, 7.25, 2.5, 7.25, label = '80000', linecolor='white')
p += Rect(2, 6, 5, 7, label='42')
p += Rect(1.5, 6.5, 1.5, 6.5, label='x', linecolor='white')
p += Rect(2, 4, 5, 5, label='123')
p += Rect(2.5, 5.25, 2.5, 5.25, label = '80004', linecolor='white')
p += Rect(1.5, 4.5, 1.5, 4.5, label = 'y', linecolor='white')
p += Rect(2, 2, 5, 3, label = '80000')
p += Rect(1.5, 2.5, 1.5, 2.5, label = 'p', linecolor='white')
p += Rect(2, 0, 5, 1, label = '80004')
p += Rect(1.5, 0.5, 1.5, 0.5, label = 'q', linecolor='white')
p += Line(points=[(4, 2.5), (7, 2.5), (7, 6.5), (5, 6.5)], linewidth=0.05, endstyle='>')
p += Line(points=[(4, 0.5), (6, 0.5), (6, 4.5), (5, 4.5)], linewidth=0.05, endstyle='>')

print(p)
\end{python}
Next, the statement

\begin{consolethree}[escapeinside=||]
p = q;
\end{consolethree}

gives the value of \texttt{q} to \texttt{p}. The value of \texttt{q} is 80004.
Therefore the value of \texttt{p} becomes 80004. The diagram now looks like this:
\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, -1, 8, 8)
p += Rect(2.5, 7.25, 2.5, 7.25, label = '80000', linecolor='white')
p += Rect(2, 6, 5, 7, label='42')
p += Rect(1.5, 6.5, 1.5, 6.5, label='x', linewidth=0.0,linecolor='white')
p += Rect(2, 4, 5, 5, label='123')
p += Rect(2.5, 5.25, 2.5, 5.25, label = '80004', linecolor='white')
p += Rect(1.5, 4.5, 1.5, 4.5, label = 'y', linewidth=0.0,linecolor='white')
p += Rect(2, 2, 5, 3, label = '80000')
p += Rect(1.5, 2.5, 1.5, 2.5, label = 'p', linewidth=0.0,linecolor='white')
p += Rect(2, 0, 5, 1, label = '80004')
p += Rect(1.5, 0.5, 1.5, 0.5, label = 'q', linewidth=0.0,linecolor='white')

print(p)
\end{python}

And if I now draw the arrows, I have

\begin{python}
from latextool_basic import *
p = Plot()

p += Rect(0, -1, 8, 8)
p += Rect(2.5, 7.25, 2.5, 7.25, label = '80000', linecolor='white')
p += Rect(2, 6, 5, 7, label='42')
p += Rect(1.5, 6.5, 1.5, 6.5, label='x', linewidth=0.0,linecolor='white')
p += Rect(2, 4, 5, 5, label='123')
p += Rect(2.5, 5.25, 2.5, 5.25, label = '80004', linecolor='white')
p += Rect(1.5, 4.5, 1.5, 4.5, label = 'y', linewidth=0.0,linecolor='white')
p += Rect(2, 2, 5, 3,label = '80000')
p += Rect(1.5, 2.5, 1.5, 2.5, label = 'p', linewidth=0.0,linecolor='white')
p += Rect(2, 0, 5, 1, label = '80004')
p += Rect(1.5, 0.5, 1.5, 0.5, label = 'q', linewidth=0.0,linecolor='white')
p += Line(points=[(4, 2.5), (7, 2.5), (7, 4.75), (5, 4.75)], linewidth=0.05, endstyle='>')
p += Line(points=[(4, 0.5), (6, 0.5), (6, 4.25), (5, 4.25)], linewidth=0.05, endstyle='>')

print(p)
\end{python}

Get it?
\begin{ex}
First draw memory models for this:

\begin{consolethree}[escapeinside=||]
int x = 42;         // address 10000
int y = 43;         // address 10004
int * p = &x;
// Draw picture 1
std::cout << &x << ' ' << &y << ' ' << p << '\n';
p = &y;
// Draw picture 2
std::cout << &x << ' ' << &y << ' ' << p << '\n';
\end{consolethree}

Verify your picture by running your program.
\end{ex}

\begin{ex}
Draw the memory models for the following:

\begin{consolethree}[escapeinside=||]
int x = 42;         // address 80000
int y = 123;        // address 80004
int * p = &x;
int * q = &y;
// Draw picture 1

std::cout << &x << ' ' << &y << ' '
          << p << ' ' << q << '\n';
p = &y;
// Draw picture 2
std::cout << &x << ' ' << &y << ' '
          << p << ' ' << q << '\n';
q = &x;
// Draw picture 3
std::cout << &x << ' ' << &y << ' '
          << p << ' ' << q << '\n';
\end{consolethree}
\end{ex}

\begin{ex}
What is the output?

\begin{consolethree}[escapeinside=||]
int i = 42;     // address 5000
int j = 5;      // address 5004
int k = -2;     // address 5008
int * p = &i;
int * q = &j;
int * r = p;
p = q;
q = r;
std::cout << *p << ' ' << *q << ' ' << *r << '\n'; 
\end{consolethree}
(Hint: Draw a picture)
\end{ex}

\begin{ex}
You are brainstorming with your team in one of the company's meeting rooms. Your boss pops in to say hi on his way to get coffee and he notices the following diagram on the whiteboard. Someone is tracing a piece of code on the whiteboard:
\begin{python}
from latextool_basic import *
p = Plot()
#outline
p += Rect(0, -7, 12, 10)

#pointer boxes
abox = Rect(2, 8, 3.5, 9, label="'a'")
bbox = Rect(2, 6, 5, 7, label='2.718')
cbox = Rect(2, 4, 4, 5)
dbox = Rect(2, 2, 4, 3)
ebox = Rect(2, 0, 4, 1, label='42')
fbox0 = Rect(2, -2, 4, -1, label='2')
fbox1 = Rect(4, -2, 6, -1, label='5')
fbox2 = Rect(6, -2, 8, -1, label='3')
fbox3 = Rect(8, -2, 10, -1, label='7')
gbox = Rect(2, -4, 4, -3)
hbox = Rect(2, -6, 4, -5)

p += abox
p += bbox
p += cbox
p += dbox
p += ebox
p += fbox0
p += fbox1
p += fbox2
p += fbox3
p += gbox
p += hbox

#add labels
a = Rect(1.5, 8.5, 1.5, 8.5, label='a', linewidth=0.0,linecolor='white')
b = Rect(1.5, 6.5, 1.5, 6.5, label='b', linewidth=0.0,linecolor='white')
c = Rect(1.5, 4.5, 1.5, 4.5, label='c', linewidth=0.0,linecolor='white')
d = Rect(1.5, 2.5, 1.5, 2.5, label='d', linewidth=0.0,linecolor='white')
e = Rect(1.5, 0.5, 1.5, 0.5, label='e', linewidth=0.0,linecolor='white')
f = Rect(1.5, -1.5, 1.5, -1.5, label='f', linewidth=0.0,linecolor='white')
g = Rect(1.5, -3.5, 1.5, -3.5, label='g', linewidth=0.0,linecolor='white')
h = Rect(1.5, -5.5, 1.5, -5.5, label='h', linewidth=0.0,linecolor='white')

p += a
p += b
p += c
p += d
p += e
p += f
p += g
p += h

#arrow paths
#c->a
p += Line(points=[(2.5,4.5), (7.5, 4.5), (7.5, 8.5), (3.5, 8.5)], linewidth=0.1, endstyle='>')
#d->f
p += Line(points=[(2.5,2.5), (9,2.5), (9, -1)], linewidth=0.1, endstyle='>')
#g->b
p += Line(points=[(2.5, -3.5), (10, -3.5), (10,6.5), (5,6.5)], linewidth=0.1, endstyle='>')
#h->e
p += Line(points=[(2.5, -5.5),(6.5,-5.5),(6.5,0.5),(4,0.5)], linewidth=0.1, endstyle='>')

print(p)
\end{python}

On his way back, your boss glanced at the whiteboard and sees this:
\begin{python}
from latextool_basic import *
p = Plot()
#outline
p += Rect(0, -7, 12, 10)

#pointer boxes
abox = Rect(2, 8, 3.5, 9, label="'\$'")
bbox = Rect(2, 6, 5, 7, label='3.145')
cbox = Rect(2, 4, 4, 5)
dbox = Rect(2, 2, 4, 3)
ebox = Rect(2, 0, 4, 1, label='42')
fbox0 = Rect(2, -2, 4, -1, label='2')
fbox1 = Rect(4, -2, 6, -1, label='5')
fbox2 = Rect(6, -2, 8, -1, label='3')
fbox3 = Rect(8, -2, 10, -1, label='7')
gbox = Rect(2, -4, 4, -3)
hbox = Rect(2, -6, 4, -5)

p += abox
p += bbox
p += cbox
p += dbox
p += ebox
p += fbox0
p += fbox1
p += fbox2
p += fbox3
p += gbox
p += hbox

#add labels
a = Rect(1.5, 8.5, 1.5, 8.5, label='a', linewidth=0.0, linecolor='white')
b = Rect(1.5, 6.5, 1.5, 6.5, label='b', linewidth=0.0,linecolor='white')
c = Rect(1.5, 4.5, 1.5, 4.5, label='c', linewidth=0.0,linecolor='white')
d = Rect(1.5, 2.5, 1.5, 2.5, label='d', linewidth=0.0,linecolor='white')
e = Rect(1.5, 0.5, 1.5, 0.5, label='e', linewidth=0.0,linecolor='white')
f = Rect(1.5, -1.5, 1.5, -1.5, label='f', linewidth=0.0,linecolor='white')
g = Rect(1.5, -3.5, 1.5, -3.5, label='g', linewidth=0.0,linecolor='white')
h = Rect(1.5, -5.5, 1.5, -5.5, label='h', linewidth=0.0,linecolor='white')

p += a
p += b
p += c
p += d
p += e
p += f
p += g
p += h

#arrow paths
#c->a
p += Line(points=[(2.5,4.5), (7.5, 4.5), (7.5, 8.5), (3.5, 8.5)], linewidth=0.1, endstyle='>')
#d->b
p += Line(points=[(2.5,2.5), (4,2.5), (4, 6)], linewidth=0.1, endstyle='>')
#g->b
p += Line(points=[(2.5, -3.5), (11, -3.5), (11, 6.5), (4, 6.5)], linewidth=0.1, endstyle='>')
#h->f
p += Line(points=[(2.5, -5.5),(6.5,-5.5),(3,-1.75)], linewidth=0.1, endstyle='>')

print(p)
\end{python}

You notice he was shaking his head as he walked away. Why?
\end{ex}

\begin{ex}

What is the output?

\begin{consolethree}[escapeinside=||]
int i = 1;
int j = 2;
int k = 3;
int * p = &k;
int * q = &i;
int * r = &j;
*p = *q + *r;
p = q;
*p = *q + *r;
p = r;
*p = *q + *r;
std::cout << i << ' ' << j << ' ' << k << '\n';
std::cout << *p << ' ' << *q << ' ' << *r << '\n'; 
\end{consolethree}
\end{ex}

\begin{ex}
What is the output? Or is there an error?

\begin{consolethree}[escapeinside=||]
int i = 1;
int j = 2;
int k = 3;
int * p = &k;
int * q = &i;
int * r = &j;
*p = *q + *r;
p = q;
*p = *q + *r;
p = r;
*p = *q + *r;
std::cout << i << ' ' << j << ' ' << k << '\n';
std::cout << *p << ' ' << *q << ' ' << *r << '\n'; 
\end{consolethree}
\end{ex}

\newpage\EMPHASIZE{Comparison}

You can only compare pointers \EMPHASIZE{of the same type.}

You can compare compatible pointers using
\begin{center}
\texttt{==}, \texttt{!=}, \texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=}
\end{center}
because pointers are memory address and hence can be converted to integers and therefore can be compared just like integers. Try this

\begin{consolethree}[escapeinside=||]
int x = 0;
int y = 1;
int * p = &x;
int * q = &y;
std::cout << (p == q) << "\n";
\end{consolethree}

and this:

\begin{consolethree}[escapeinside=||]
int x = 0;
char c = 'a';
int * p = &x;
char * r = &c;
std::cout << (p == r) << "\n";
\end{consolethree}

Of course if two pointers point to the same memory address, then you get
true when you compare their memory address values:

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p = &x;
int * q = &x;
std::cout << (p == q) << "\n";
\end{consolethree}

Recall that variables declared in a block are lined up so that variables declared earlier will have a small address value.

\begin{consolethree}[escapeinside=||]
int x = 0;
int y = 1;
int * p = &x;
int * q = &y;
std::cout << (unsigned int)(p) << ' '
          << (unsigned int)(q) << '\n';
std::cout << (p < q) << '\n';
\end{consolethree}
In the above, you see that the address of x (i.e., the address of the value of x) is smaller that the address of y.

\begin{ex}
TRUE or FALSE: The output is 1 since the value that \texttt{p} and \texttt{q} points to are the same (i.e., 42).

\begin{consolethree}[escapeinside=||]
int x = 42;
int y = 42;
int * p = &x;
int * q = &y;
std::cout << (p == q) << "\n";
\end{consolethree}
\end{ex}

\begin{ex}
What is the output?

\begin{consolethree}[escapeinside=||]
int x = 0;
int y = 1;
int z = 2;
int * p = &x;
int * q = &y;
int * r = &z;
*r = 0;
r = q;
*p = 0;
p = q;
*q = 0;
std::cout << (p == q) << ' ' << (q != r) << '\n';
\end{consolethree}
\end{ex}

\begin{ex}
What is the output?

\begin{consolethree}[escapeinside=||]
#include <iostream>

int f(int * x, int * y)
{   
    return (x == y ? *x : *x + *y);
}

int main()
{   
    int a = 2;
    int b = 3;
    std::cout << f(&a, &b) + f(&a, &a)
              << std::endl;
    return 0;
}
\end{consolethree}
\end{ex}

\begin{ex}
What is the output? Or is there an error?

\begin{consolethree}[escapeinside=||]
#include <iostream>

int f(int * x)
{   
    return (x == NULL ? -1 : *x);
}

int main()
{
    int a = 2;
std::cout << f(&a) << ' ' << f(NULL)
          << std::endl;
    return 0;
}
\end{consolethree}
[HINT: What is \texttt{NULL} again? What does it represent?]
\end{ex}

\newpage\EMPHASIZE{Pointer Power \#1: Assessing value anywhere}

Here comes the first application of pointers \ldots{} a really important one \ldots{} we can use pointers to access a variable's memory anywhere we like. (This is not new since references are exactly for that purpose. You want to review references now.)

First of all recall the following:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void swap(int x, int y)
{
    int t = x;
    x = y;
    y = t;
}

int main()
{   
    int x = 0, y = 1;
    std::cout << x << ' ' << y << '\n';
    swap(x, y);
    std::cout << x << ' ' << y << '\n';
    return 0;
}
\end{consolethree}
Of course the function uses pass-by-value. The \texttt{x} and \texttt{y} in \texttt{swap()} has nothing to do with the \texttt{x} and \texttt{y} in \texttt{main()} and therefore \texttt{swap()} cannot possibly change the values of variables in \texttt{main()}.

Now look at this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void swap(int & x, int & y)
{    
     int t = x;
     x = y;
     y = t;
}

int main()
{   
    int x = 0, y = 1;
    std::cout << x << ' ' << y << '\n';
    swap(x, y);
    std::cout << x << ' ' << y << '\n';
    return 0;
}
\end{consolethree}
This second \texttt{swap()} function uses pass-by-reference and it does swap the values of two variables in \texttt{main()}.

With your understanding of pointers, run and explain this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void swap(int * x, int * y)
{    
     int t = *x;
     *x = *y;
     *y = t;
}

int main()
{   
    int x = 0, y = 1;
    std::cout << x << ' ' << y << '\n';
    swap(&x, &y);
    std::cout << x << ' ' << y << '\n';
    return 0;
}
\end{consolethree}
Therefore pointers can be used as parameters to modify values of variables in the calling function, i.e., they can be used to achieve the same results as references. Actually references are secretly pointers!

Understand this very important idea: pointers allow you to access any value you like from anywhere in your code as long as know where to find the value (and you have access rights to that value):

\begin{consolethree}[escapeinside=||]

#include <iostream>

void j(int * x)
{    
     *x = 42; // TADA!
}

void i(int * x)
{
    j(x);
}

void h(int * x)
{
    i(x);
}

void f(int * x)
{
    h(x);
}

int main ()
{
    int x = 0;
    f(&x);
    std::cout << x << std::endl;
    return 0;
}
\end{consolethree}
Here's another example. This version of reciprocating \texttt{x} does not
work:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void reciprocal(double x)
{
    x = 1.0 / x;
}

int main()
{
    double x = 2.0;
    reciprocal(x);
    std::cout << x << '\n';     // x is still 2.0
    return 0;
}
\end{consolethree}
This one does work, using reference:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void reciprocal(double & x)
{
    x = 1.0 / x;
}

int main()
{
    double x = 2.0;
    reciprocal(x);
    std::cout << x << '\n';     // x is 0.5
    return 0;
}
\end{consolethree}
And this one does work, using pointers:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void reciprocal(double * x)
{
    *x = 1.0 / *x;
}

int main()
{
    double x = 2.0;
    reciprocal(&x);
    std::cout << x << '\n';     // x is 0.5
    return 0;
}
\end{consolethree}
Now's your turn \ldots{}

\begin{ex}

Here's an increment function that does not work:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void inc(int x)
{
    x++;
}

int main()
{
    int a = 42;
    inc(a);
    std::cout << a << std::endl;    // a is still 42
    return 0;
}
\end{consolethree}
And here's one that works, using reference variables:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void inc(int & x)
{
    x++;
}

int main()
{
    int a = 42;
    inc(a);
    std::cout << a << std::endl;    // a is 43
    return 0;
}
\end{consolethree}
Complete the following program so that the new increment works, except
that the parameter is a pointer and not a reference:
\end{ex}

\begin{consolethree}[escapeinside=||]
void inc(int * x)
{
}

int main()
{
    int a = 42;
    inc(&a);
    std::cout << a << std::endl;    // you should get 43
    return 0;
}
\end{consolethree}

\begin{ex}
Complete the \verb!array_append()! function (which adds a value to the array \verb!x! and increments the value of the length variable of the array. The expected output is \verb!2 3 5 7!.
d
\begin{consolethree}[escapeinside=||]
#include <iostream>

void array_println(int x[], int xlen)
{
    for (int i = 0; i < xlen; ++i)
    {
        std::cout << x[i] << ' ';
    }
    std::cout << std::endl;
}

void array_append(int x[], int * xlen, int value)
{
}

int main()
{
    int x[10] = {2, 3, 5};
    int xlen = 3;
    array_append(x, &xlen, 7);
    array_println(x, xlen);
    return 0;
}
\end{consolethree}
\end{ex}

\begin{ex}
Here's a function that acts like an integer input function:
\begin{consolethree}[escapeinside=||]
#include <iostream>

void scanf(int * x)
{
}

int main()
{
    int a = 0;
    scanf(&a);
    std::cout << a << std::endl;
    return 0;
}
\end{consolethree}
Complete this so that when you run it and enter 42, there's an output of 42.
\end{ex}
\begin{ex}
This is similar to the above:
\begin{consolethree}[escapeinside=||]
#include <iostream>

void scanf(double * x)
{
}

int main()
{
    double a = 0;
    scanf(&a);
    std::cout << a << std::endl;
    return 0;
}
\end{consolethree}
Test it!!!
\end{ex}

\newpage\EMPHASIZE{Constantness for pointers}

Recall that for a regular variable like this:

\begin{consolethree}[escapeinside=||]
int x = 42;
\end{consolethree}

to make \texttt{x} constant so that its value cannot change, you do this:

\begin{consolethree}[escapeinside=||]
const int x = 42;
\end{consolethree}

Making a variable constant is a protection mechanism to prevent change in the case when a variable should not be changed. (Make sure you review the notes on constants.)

The above is old stuff. Now for something new \ldots{}

Because a pointer is associated with two values, an address and a value the pointer points to, you can ``const'' two values associated with a pointer. First let me describe the ideas, then I'll talk about the syntax.

Look at the following picture of a pointer \texttt{p} pointing to 42 (at address 5002048):

\begin{python}
from latextool_basic import *
from latexcircuit import POINT
p = Plot()

borderbox = Rect(0, 0, 6, 3, linewidth=0.1)
innerbox = Rect(1, 1, 4, 2, linewidth=0.05, label='5002048')
ppoint = Rect(0.5, 1.5, 0.5, 1.5, label='p', linecolor='white')
p += borderbox
p += innerbox
p += ppoint

ptrbox = Rect(9, 3.5, 12, 4.5, linewidth=0.05, label='42')
ptrlbl = Rect(9, 5, 9, 5, label='5002048', linecolor='white')
p += ptrbox
p += ptrlbl

p += Line(points=[(3.75, 1.5), (9, 4)], linewidth=0.075, linestyle='dashed', endstyle='>')
print(p)
\end{python}

If \texttt{p} is a \EMPHASIZE{constant pointer}, then the pointer value of \texttt{p} is a constant and therefore cannot change.

\begin{python}
from latextool_basic import *
from latexcircuit import POINT
p = Plot()

borderbox = Rect(0, 0, 6, 3, linewidth=0.1)
innerbox = Rect(1, 1, 4, 2, linewidth=0.05, label='5002048')
ppoint = Rect(0.5, 1.5, 0.5, 1.5, label='p', linecolor='white')
p += borderbox
p += innerbox
p += ppoint

ptrbox = Rect(9, 3.5, 12, 4.5, linewidth=0.05, label='42')
ptrlbl = Rect(10, 5, 10, 5, label='5002048', linecolor='white')
p += ptrbox
p += ptrlbl

redbox = Rect(13, 2, 18, 4, linewidth=0.1, linecolor='red', innersep=0.25, s = 'Cannot be changed!!!! \\texttt{p = ...} is wrong!!!!', align='c')
p += redbox
p += Line(points=[(13, 2.5), (4, 1.5)], linewidth = 0.1, linecolor='red', endstyle='>')
p += Line(points=[(3.75, 1.5), (9, 4)], linewidth=0.075, linestyle='dashed', endstyle='>')
print(p)
\end{python}

However if \texttt{p} is a \EMPHASIZE{pointer to constant}, then the value that \texttt{p} points to cannot be changed through using \texttt{*p}:

\begin{python}
from latextool_basic import *
from latexcircuit import POINT
p = Plot()

borderbox = Rect(0, 0, 6, 3, linewidth=0.1)
innerbox = Rect(1, 1, 4, 2, linewidth=0.05, label='5002048')
ppoint = Rect(0.5, 1.5, 0.5, 1.5, label='p', linecolor='white')
p += borderbox
p += innerbox
p += ppoint

ptrbox = Rect(9, 3.5, 12, 4.5, linewidth=0.05, label='42')
ptrlbl = Rect(10, 5, 10, 5, label='5002048', linecolor='white')
p += ptrbox
p += ptrlbl

redbox = Rect(13, 2, 18, 4, linewidth=0.1, linecolor='red', innersep=0.25, s = 'Cannot be changed!!!! \\texttt{p = ...} is wrong!!!!', align='c')
p += redbox
p += Line(points=[(13, 2.5), (10.5, 3.5)], linewidth = 0.1, linecolor='red', endstyle='>')
p += Line(points=[(3.75, 1.5), (9, 4)], linewidth=0.075, linestyle='dashed', endstyle='>')
print(p)
\end{python}

Easy right?

Now let's talk about the syntax \ldots{}

In the case of a pointer, say:

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p = &x;
\end{consolethree}

If you do not want the memory address value in \texttt{p} to be changed, you want \texttt{p} to be a \EMPHASIZE{constant pointer}, you do this:

\begin{consolethree}[escapeinside=||]
int x = 42;

int * |\EMPHASIZE{const}| p = &x;
\end{consolethree}
Note where \texttt{const} is placed: to the right of \texttt{*}.

\begin{ex}
To make sure you remember the above, first run this

\begin{consolethree}[escapeinside=||]
int x = 0, y = 1;
int * p = &x;
std::cout << *p << '\n';
p = &y;
std::cout << *p << '\n'; 
\end{consolethree}
Everything works just fine. Now make \texttt{p} a constant pointer like this:

\begin{consolethree}[escapeinside=||]
int x = 0, y = 1;
int * |\EMPHASIZE{const}| p = &x;
std::cout << *p << '\n';
p = &y; // compiler complaints!!!
std::cout << *p << '\n'; 
\end{consolethree}
Get it?
\end{ex}
What about the case where \texttt{p} points to a constant value? First run this

\begin{consolethree}[escapeinside=||]
int x = 0;
|\EMPHASIZE{const}| int * p = &x;
std::cout << *p << '\n';
\end{consolethree}
No problems. Now try this:

\begin{consolethree}[escapeinside=||]
int x = 0;
|\textbf{const}| int * p = &x;
std::cout << *p << '\n';
*p = 42; // compiler complaints!!!
\end{consolethree}
That's it!

There is however one very important thing you must remember. Run this:

\begin{consolethree}[escapeinside=||]
int x = 0, y = 1;
|\textbf{const}| int * p = &x;
std::cout << x << ' ' << *p << '\n';
x = 42;                  // OK ... x is a variable
std::cout << x << ' ' << *p << '\n';
\end{consolethree}

Note: \EMPHASIZE{If \texttt{p} points to a \texttt{const int}, it doesn't mean that the \texttt{int} value can't change -- it's just that you cannot change it using \texttt{*p}.} In the above, we change the value using \texttt{x} Get it?

Here is a table the summarizes all the cases:

%% \tab[14em]{Can change \texttt{p}?} \tab[2em]{Can change \texttt{*p}?}

%% \tab[14em]{Is \texttt{p =} \ldots{} OK?} \tab[2em]{Is \texttt{*p =} \ldots{} OK?}

%% \tab[3em]{\ \ \ \texttt{int *}} \tab[3em]{\texttt{p}} \tab[3em]{YES} \tab[3em]{YES}

%% \texttt{const int *}\tab[3em]{\texttt{p}} \tab[3em]{YES} \tab[3em]{NO}

%% \tab[3em]{\ \ \texttt{int * const p} \tab[3em]{NO} \tab[3em]{YES}

%% \texttt{const int * const p} \tab[3em]{NO} \tab[3em]{NO}

\begin{tabular}{l l l l}
    & & \texttt{Can change p?} & \texttt{Can change *p?} \\
    & & Is \texttt{p} = ... OK? & Is \texttt{*p} = ... OK? \\
    \texttt{int *} & \texttt{p} & YES & YES \\
    \texttt{const int *} & \texttt{p} & YES & NO \\
    \texttt{int * const} & \texttt{p} & NO & YES \\
    \texttt{const int * const} & \texttt{p} & NO & NO \\
\end{tabular}

Here's an important \EMPHASIZE{memory aid} (this might not be in your textbook): You \EMPHASIZE{read} the pointer type \EMPHASIZE{backwards}. For instance, if you see this declaration:

\tab[3em]{\texttt{const int * const p}}

you read it in this direction:
\begin{python}
from latextool_basic import *
p = Plot()
p += Rect(0, 0, 3, 1, linecolor='white', label='\\texttt{const int * const p}')
p += Line(points=[(4, 0), (-1, 0)], linewidth=0.1, endstyle='>')
print(p)
\end{python}    
so that you say ``\texttt{p} is a constant pointer to an integer constant''. Here are all the 4 possible constantness cases for a pointer declaration:

You say:

%% \tab[3em]{\texttt{int *}} \tab[3em]{\texttt{p}} \tab[3em]{``p is a pointer to int''}

%% \texttt{const int *}\tab[3em]{\texttt{p}} \tab[3em]{``p is a pointer to int const''}

%% \tab[3em]{\texttt{int * const p} \tab[3em]{``p is a const pointer to int''}

%% \tab[3em]{const int * const p} \tab[3em]{``p is a const pointer to int const''}
\begin{tabular}{l l l l}
    \texttt{int *} & \texttt{p} &  ``p is a pointer to int'' \\
    \texttt{const int *} & \texttt{p} &  ``p is a pointer to int const''\\
    \texttt{int * const} & \texttt{p} &  ``p is a const pointer to int'' \\
    \texttt{const int * const} & \texttt{p} &  ``p is a const pointer to int const''\\
\end{tabular}


Two important things to note ...

\EMPHASIZE{A constant pointer must be initialized.} (This is just like a regular constant integer variable -- all constants must be initialized.)

This means:

\begin{consolethree}[escapeinside=||]
int * const p;          // WRONG!!!
p = &x;                 // TOO LATE!!!

const int * const q;    // WRONG AGAIN!!
q = &y;                 // TOO LATE BOZO!!!
\end{consolethree}
\EMPHASIZE{A non-constant pointer cannot point to a constant.} For instance

\begin{consolethree}[escapeinside=||]
const int x = 42;
int * p0 = &x;       // WRONG!!!
int * const p1 = &x; // WRONG!!! 
\end{consolethree}

Why? Because in this case, \texttt{p} is supposed to point to an \texttt{int} (not \texttt{const int}) Therefore \texttt{p} can change the value that it points to using \texttt{*p}. But that value is a \texttt{const}! That's a contradiction!

\begin{ex}
Is this OK?

\begin{consolethree}[escapeinside=||]
const int x = 42;
const int * p = &x;
int * const q = p;
\end{consolethree}
Here are some exercises to tease your brain.
\end{ex}

\begin{ex}
Does the following code fragment compile?

\begin{consolethree}[escapeinside=||]
int x = 42, y = 24;
int * p = &x;
p = &y;     // OK?
*p = 42;    // OK?
\end{consolethree}
Verify on your own.
\end{ex}

\begin{ex}
Does the following code fragment compile?

\begin{consolethree}[escapeinside=||]
double x = 3.14, y = 2.71;
double * const p = &x;
p = &y; // OK?
*p = 0; // OK?
\end{consolethree}
Verify on your own.
\end{ex}

\begin{ex}
Does the following code fragment compile?

\begin{consolethree}[escapeinside=||]
char x = 'a', y = 'b';
const char * p = &x;
p = &y;      // OK?
*p = 0;      // OK?
\end{consolethree}
Verify on your own.
\end{ex}

\begin{ex}
Does the following code fragment compile?

\begin{consolethree}[escapeinside=||]
bool x = true, y = false;
const bool * const p = &x;

p = &y;      // OK?
*p = 0;      // OK?
\end{consolethree}
Verify on your own.
\end{ex}

\begin{ex}
Which of the following pointer declarations with initialization works?

\begin{consolethree}[escapeinside=||]
const char x = '#';
      char * p0 = &x;
      char * const p1 = &x;
const char * p2 = &x;
const char * const p3 = &x;
\end{consolethree}
\end{ex}
\begin{ex}
Does this compile? If it does, what's the output?

\begin{consolethree}[escapeinside=||]
double a = 3.14;
const double * p = &a;
*p = a + *p;

std::cout << a << ' ' << *p << '\n';
\end{consolethree}
\end{ex}
\begin{ex}
Does this compile? If it does, what's the output?

\begin{consolethree}[escapeinside=||]
double a = 3.14;
const double * p = &a;
a = a + *p;

std::cout << a << ' ' << *p << '\n';
\end{consolethree}
\end{ex}
\newpage\EMPHASIZE{Connection between pointers and references}

The previous section shows you that the behavior of pass-by-references can be achieved by pass-by-value where the value passed into a function is a pointer value (i.e., address value).

As I've mentioned before when you use pass-by-reference, your compiler actually converts your function to one using pointers.

To illustrate the connection further run this program:

\begin{consolethree}[escapeinside=||]
int x = 42;
int & r = x;    // r is a reference to x
int * p = &x;   // p is a pointer to x

std::cout << x << ' ' << r << ' ' << *p << '\n';

std::cout << &x << ' ' << &r << ' ' << p << '\n';
\end{consolethree}
You will see that if \texttt{r} is a reference to \texttt{x}, the address of \texttt{r}, i.e. \texttt{\&r}, is the same as \texttt{\&x}. This means that the value \texttt{r} refers to resides at the address of \texttt{x}, i.e., the output of the second line contains the same address.

Let me repeat: The address of a reference variable is the address of the value the reference is referring to. Therefore if \texttt{r} reference x and \texttt{p} points to \texttt{x}, then

\texttt{\&r} and \texttt{p }are the same

and

\texttt{r} and \texttt{*p }are the same.

Think, understand, and remember!

\newpage\EMPHASIZE{Differences between pointers and references}

The above might lead you to think that pointers and references are the same (except for syntax). There are actually lots of differences between pointers and references. With your understanding of pointers, let's take a closer look \ldots

1. There's a pointer value, \texttt{NULL}, that can be assigned to all pointers. This frequently acts as a default pointer value. Recall that \texttt{NULL} does not point to anything useful. References (of any type) MUST refer to a value of a variable (or constant) of the same type -- there's no such thing as \texttt{NULL} reference. So a function that accepts a pointer has the option of being called with ``nothing'':

\begin{consolethree}[escapeinside=||]
void print_cash(int * p_cash_in_cents = NULL)
{
    if (p_cash_in_cents == NULL)
    {
        std::cout << "no cash!!!\n"
    }
    else
    {
        int dollar = *p_cash_in_cents / 100.0;
        int cents = *p_cash_in_cents - dollar * 100.0;
        std::cout << '$' << dollar
                  << '.' << cents << '\n';
    }
}
\end{consolethree}
2. A pointer can be a constant pointer or non-constant pointer:


For a non-constant pointer, the address value in the pointer can change so that it can point to another value.

\begin{consolethree}[escapeinside=||]
p = &x; *p++; // increments x
p = &y; *p++; // increments y
p = &z; *p++; // increments z
\end{consolethree}

\begin{consolethree}[escapeinside=||]
int x = 0, y = 0, z = 0;
int & r = x; r++;           // increments x
r = y; r++;                 // increments y ... NO!!!
\end{consolethree}
The fact that a pointer can point to different values is actually extremely important later when it comes to pointers and arrays.

\newpage\EMPHASIZE{Pointer Power \#2: Speeding up function calls}

Now for our second application of pointers (and references): speeding up function calls by passing in pointer values (or references) in order to avoid copying of values

First look at this very simple (and old) program:

\begin{consolethree}[escapeinside=||]
#include <iostream>

int max(int x, int y)
{
    return (x > y ? x : y);
}

int main()
{
    int a;
    std::cin >> a;
    int b;
    std::cin >> b;
    int x = max(a, b);
    std::cout << x << '\n';
    return 0;
}
\end{consolethree}
No big deal.

Now run this

\begin{consolethree}[escapeinside=||]
#include <iostream>

int * max(int * x, int * y)
{
    if (*x > *y)
    {
        return x;
    }
    else
    {
        return y;
    }
}

int main()
{
    int a;
    std::cin >> a;
    int b;
    std::cin >> b;
    int * p = max(&a, &b);
    std::cout << *p << '\n';
    std::cout << &a << ' ' << &b
              << ' ' << p << '\n';
    return 0;
}
\end{consolethree}
It's helpful if you draw a picture of the computation and explain what's happening. Don't panic \ldots just draw the picture and explain slowly and carefully.

You can clean up the \texttt{max()} function above like this:

\begin{consolethree}[escapeinside=||]
int * max(int * x, int * y)
{
    return (*x > *y ? x : y);
}
\end{consolethree}
This is what's going on in the program: instead of computing and returning the maximum of two values, the function actually returns a pointer value that points to the address of the variable with the larger value.

We can even do this: Note that the above max function has pointer parameters whose pointer values do not change -- we can make them constant pointers. They also do not change the value they point to -- we can make them point to constant integers. So we can do this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

const int * const max(const int * const x,
                      const int * const y)
{
    return (*x > *y ? x : y);
}

int main()
{
    int a;
    std::cin >> a;
    int b;
    std::cin >> b;
    const int * const p = max(&a, &b);
    std::cout << *p << '\n';
    std::cout << &a << ' ' << &b << ' '
              << p << '\n';
    return 0;
}
\end{consolethree}
or this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

const int * const max(const int * const x,
                      const int * const y)
{
    return (*x > *y ? x : y);
}

int main()
{
    int a;
    std::cin >> a;
    int b;
    std::cin >> b;
    std::cout << *max(&a, &b) << '\n';
    std::cout << &a << ' ' << &b << ' '
                    << max(&a, &b) << '\n';
    return 0;
}
\end{consolethree}
Note that you can also do this using references. Study the following program carefully:

\begin{consolethree}[escapeinside=||]
#include <iostream>

const int & max(const int & x, const int & y)
{
    return (x > y ? x : y);
}

int main()
{
    int a;
    std::cin >> a;
    int b;
    std::cin >> b;
    const int & r = max(a, b);
    std::cout << r << '\n';
    std::cout << &a << ' ' << &b
                    << ' ' << &r << '\n';
    return 0;
}
\end{consolethree}
Now why would you want to pass in and return a pointer (or references) to one of the variables that contains the maximum value and not compute and return the maximum value??? Isn't the first method a lot simpler?!?

Because the pointer (or reference method) can save memory (and potentially time). How so?

When you compute the maximum value and return that value, you have to create that value and put it somewhere for returning. (Recall the stack?) For returning the maximum of two doubles, I have to save a double value onto the stack -- that's 8 bytes. For the pointer method (and similarly for the reference method), I have to save the pointer address of the variable holding the maximum value onto the stack. A pointer address is 32-bits (on a 32-bit machine) which is 4 bytes. Also, remember that using pass-by-value, the two doubles would have to saved onto the stack for the max function to retrieve.

And what if the two values I'm computing with actually takes more bytes?
Then the difference is even greater. For instance in C++, there's a \texttt{long double} type. On my computer, the \texttt{long double} occupies 12 bytes. So for the method that returns the maximum value, I have to

\begin{itemize}

\item
  copy two \texttt{long double}s values (24 bytes) onto the stack
\item
  compute and return a \texttt{long double} (12 bytes)
\end{itemize}

For the pointer method that returns an address, I have to

\begin{itemize}

\item
  copy two addresses (8 bytes) of \texttt{long double} variables onto the stack
\item
  compute the address (4 bytes) for returning.
\end{itemize}

There's of course a cost involved for the pointer method -- I have to dereference the pointers. But in any case, when the values to be used for computing occupies a huge amount of space, the pointer (or reference) method is preferred.

\begin{ex}
This is a very important exercise!!! (A very common mistake):

\begin{consolethree}[escapeinside=||]
int * max(int * x, int * y)
{
    int q;
    q = (*x > *y ? *x : *y);
    return &q;
}
\end{consolethree}
What's the problem? (Draw a picture!!!) There's an analogous one using references:
\end{ex}

\begin{consolethree}[escapeinside=||]
int & max(int x, int y)
{
    int q;
    q = (x > y ? x : y);
    return q;
}
\end{consolethree}

Here's a general principle: \EMPHASIZE{Never return a pointer that points to a local variable in a function!!!} Because the pointer will point to a value that will be destroyed when you exit the function!!! In the same way: \EMPHASIZE{Never return a reference that refers to a local variable in a function!!!}

\newpage\EMPHASIZE{Protecting function from accidentally changing data}

Before we go on to the next use of pointers, let's look at the previous section on functions that accept pointers and/or references.

Recall that if you have a function that accepts variables which are ``big'',

\begin{consolethree}[escapeinside=||]
int f(long long int x, long double y)
{
    return (x > y ? 0 : 1);
}

int main()
{
    long long int x = 42;
    long double y = 3.14;
    int x = f(x, y);

    return 0;
}
\end{consolethree}
Then the act of making a function call is faster if you pass in pointers (or references) because the data to be passed in is not copied, only the addresses of the data are passed in:

\begin{consolethree}[escapeinside=||]
int f(long long int & px, long double & py)
{
    return (*px > *py ? 0 : 1);

}

int main()
{
    long long int x = 42;
    long double y = 3.14;
    f(&x, &y);

    return 0;
}
\end{consolethree}
Note that the larger the data, the more crucial it is to use pointers or references.

If \texttt{f()} is meant to change the \texttt{x} and y back in \texttt{main()}, then of course you must pass in pointers or references.

However if \texttt{f()} is not meant to change \texttt{x} and \texttt{y} back in \texttt{main()}, then passing pointers (or references) into \texttt{f()} can be dangerous since f() can potentially change the \texttt{x} and \texttt{y} in \texttt{main()}. To overcome this, you pass in pointer-to-constants (or constant reference):

\begin{consolethree}[escapeinside=||]
int f(const long long int * px,
      const long double * py)
{
    return (*px > *py ? 0 : 1);
}
\end{consolethree}
or

\begin{consolethree}[escapeinside=||]
void f(const long long int & x,
       const long double & y)
{
    return (x > y ? 0 : 1);
}
\end{consolethree}

In general do the following for a function call \texttt{f(..., x, ...)} (say from\texttt{ main()}) where \texttt{x} has type \texttt{T}:

\begin{consolethree}[escapeinside=||]
void f(..., T x, ...)
{
    ... x ...
}

int main()
{
    T x;
    f(..., x, ...);
}
\end{consolethree}
Do the following:

\textbf{CASE 1.} If \texttt{f()} needs to change the \texttt{x} in \texttt{main()}, then parameter \texttt{x} needs to be a reference \textbf{(pass-by-reference)}:

\begin{consolethree}[escapeinside=||]
void f(..., T & x, ...)
{
    ... x ...
}

int main()
{
    T x;
    f(..., x, ...);
}
\end{consolethree}
or parameter \texttt{x} should be changed to a pointer

\begin{consolethree}[escapeinside=||]
void f(..., T * x, ...)
{
    ... *x ...
}

int main()
{
    T x;
    f(..., &x, ...);
}
\end{consolethree}
\textbf{CASE 2A.} If \texttt{f()} does not need to change the \texttt{x} in \texttt{main()}, and \texttt{x} in \texttt{main()} does not use much memory, NO CHANGE IN ABOVE.

\textbf{CASE 2B.} If \texttt{f()} does not need to change the \texttt{x} in \texttt{main()}, and \texttt{x} in \texttt{main()} uses a lot of memory, then parameter \texttt{x} need to be a pointer to a constant:

\begin{consolethree}[escapeinside=||]
void f(..., const T * const x, ...)
{
    ... *x ...
}

int main()
{
    T x;
    f(..., &x, ...);
}
\end{consolethree}
Or you can use a constant reference:
\textbf{(pass-by-constant-reference)}

\begin{consolethree}[escapeinside=||]
void f(..., const T & x, ...)
{
    ... x ...
}

int main()
{
    T x;
    f(..., x, ...);
}
\end{consolethree}

\newpage\EMPHASIZE{Chaining}

Look at this (this is old stuff \ldots no biggy):

\begin{consolethree}[escapeinside=||]
void inc(int * p)
{
    *|\textbf{p = *p + 1; // OR: ++(*p)}|
}

int main()
{
    int x = 0;
    inc(&x); inc(&x); inc(&x);
    std::cout << x << std::endl;
    return 0;
}
\end{consolethree}
Now look at this version:

\begin{consolethree}[escapeinside=||]

|\textbf{int *}| inc(int * p)
{
    *p = *p + 1;
    |\textbf{return p;}|
}

int main()
{
    int x = 0;
    inc(inc(inc(&x)));
    std::cout << x << std::endl;
    return 0;
}
\end{consolethree}
Study the above code very carefully!!! (Chaining will be used a lot later when woirking with classes and objects.)

When a function accepts a pointer value and returns the same pointer value, that function allows chaining, i.e., calling the function multiple times using the same pointer value.

Study this version too (this one does not use references -- the idea is the same):

\begin{consolethree}[escapeinside=||]

int * const inc(int * const p)
{
    *p = *p + 1;
    return p;
}

int main()
{
    int x = 0;
    inc(inc(inc(&x)));
    std::cout << x << std::endl;
    return 0;
}
\end{consolethree}
(i.e., the pointer can be constant.) Study this one that uses references::

\begin{consolethree}[escapeinside=||]
int & inc(int & r)
{
    r = r + 1;
    return r;
}

int main()
{
    int x = 0;
    inc(inc(inc(x)));
    std::cout << x << std::endl;
    return 0;
}
\end{consolethree}

\begin{ex}
Now's your turn. Write functions that will allow this to happen:

\begin{consolethree}[escapeinside=||]

int prime = 5;

nextprime(nextprime(nextprime(&prime))) // prime = 13
\end{consolethree}
where \texttt{nextprime(p)} will set \texttt{*p} to the prime that is \texttt{> *p}. When you're done, do a version that uses pass-by-reference:

\begin{consolethree}[escapeinside=||]
int prime = 5;

nextprime(nextprime(nextprime(prime))) // prime = 13
\end{consolethree}
\end{ex}

\begin{ex}
How about this one:

\begin{consolethree}[escapeinside=||]
int index = 0;

int x[] = {3, 5, 7, 9, 2};

inc(&index, x); 
\end{consolethree}
where \texttt{inc(\&index, x)} increments \texttt{x[index]} and increment \texttt{index} by 1, and returns \texttt{\&index}.
\end{ex}

To increments the first three values of the array x, we can do this:

\begin{consolethree}[escapeinside=||]
int index = 0;

int x[] = {3, 5, 7, 9, 2);

inc(inc(inc(&index, x), x), x); 
\end{consolethree}
\newpage\EMPHASIZE{Pointer Power \#3: Dynamic memory management}

Now we are ready to talk about \EMPHASIZE{dynamic memory management.} For now I will focus on memory management for a single value of basic type. In the next set of notes, we'll talk about dynamic memory management for arrays.

In our examples like

\begin{consolethree}[escapeinside=||]
int x = 1;

int * p = &x;
\end{consolethree}

we always declare another variable for \texttt{p} to point to. You can also point \texttt{p} to an integer value which is \EMPHASIZE{not} associated to an integer variable.

Try this:

\begin{consolethree}[escapeinside=||]
int * p;

p = |\EMPHASIZE{new int}|;

*p = 42;

std::cout << *p << std::endl;
\end{consolethree}
or

\begin{consolethree}[escapeinside=||]
int * p = |\EMPHASIZE{new int}|;

*p = 42

std::cout << *p << std::endl;
\end{consolethree}
You should think of
\begin{center}
\texttt{p = new int;}
\end{center}
as creating an \texttt{int} value \EMPHASIZE{\textit{somewhere}} in the computer's memory and giving the memory address of this value to \texttt{p}. We say that we are \EMPHASIZE{allocating memory} for \texttt{p} (to point to). The integer value created is \underline{\textbf{not}} associated with an integer variable -- there's no integer variable name involved:

\begin{python}
from latextool_basic import *
from latexcircuit import POINT
p = Plot()

borderbox = Rect(0, 0, 6, 3, linewidth=0.1)
innerbox = Rect(1, 1, 4, 2, linewidth=0.05)
p += borderbox
p += innerbox

ptrbox = Rect(9, 3.5, 12, 4.5, linewidth=0.05, label='42')
p += ptrbox
p += Line(points=[(3.75, 1.5), (9, 4)], linewidth=0.075, linestyle='dashed', endstyle='>')
print(p)
\end{python}

Look at the picture: It's REALLY important to understand that

\begin{itemize}

\item
  pointer \texttt{p} consumes memory and
\item
  the value \texttt{p} points to also consumes memory.
\end{itemize}

Make sure you see the difference between the two. Not distinguishing the two is the cause of many confusion later on when you learn more about memory management.

\begin{ex}
What is the output of this program if the user entered 5?

\begin{consolethree}[escapeinside=||]
int * x = new int;
int * y = new int;
*y = 1;

std::cin >> *x;
*x = *x + *y;

std::cout << *x << ' ' << *y << '\n';
\end{consolethree}
In general you can \texttt{new} any type: you can \texttt{new} a \texttt{double}, a \texttt{char}, a \texttt{bool}, etc.
\end{ex}

Remember \texttt{NULL}? If you have declared a pointer \texttt{p}, but you have not allocated memory for \texttt{p}, then \texttt{*p} of course should not be used. And one way to remind yourself that \texttt{p} has not been allocated is to initialize it to \texttt{NULL:}

\begin{consolethree}[escapeinside=||]
int * p = NULL;
                // etc.
                // now you need an integer \ldots

if (p == NULL)
{
    p = new int;
}
// Now use *p
\end{consolethree}

\begin{ex}
What is the output of this program?

\begin{consolethree}[escapeinside=||]
int * x = new int;
*x = 1;
double * y = new double;

*y = 5.1;

for (int i = 0; i <= *y; i++)
{
    *x *= 2;
}
std::cout << *x << '\n';
\end{consolethree}
\end{ex}

\begin{ex}
What's the problem here?

\begin{consolethree}[escapeinside=||]
int * x = new double;
*x = 42;
std::cout << *x << '\n';
\end{consolethree}
\end{ex}

For

\begin{consolethree}[escapeinside=||]
int * p = new int;
*p = 42;
\end{consolethree}
\textit{\EMPHASIZE{where}} is this int value that \texttt{p} points to???
\begin{python}
from latextool_basic import *
from latexcircuit import POINT
p = Plot()

borderbox = Rect(0, 0, 6, 3, linewidth=0.1)
innerbox = Rect(1, 1, 4, 2, linewidth=0.05)
p += borderbox
p += innerbox

ptrbox = Rect(9, 3.5, 12, 4.5, linewidth=0.05, label='42')
p += ptrbox
p += Line(points=[(3.75, 1.5), (9, 4)], linewidth=0.075, linestyle='dashed', endstyle='>')
print(p)
\end{python}

\newpage\EMPHASIZE{The free store or memory heap}

Our variables up to this point (except for pointer variables) have this
behavior:

\begin{itemize}

\item
  When you declare it in a block, the variable is created, the memory
  for the value is also created, and you have access to its name.
\item
  When you exit the block where the variable is declared, the variable
  name and its value are destroyed.
\end{itemize}

Note in particular that the scope and value of the variable goes hand in hand. (Remember: The scope of a variable is where you can access the variable's name.) Such variables are called \EMPHASIZE{automatic variables}. Because the memory used for their variables are destroyed and reclaimed automatically when the variable goes out of scope -- you don't have to manipulate the memory.

\begin{consolethree}[escapeinside=||]
if (i > 0)
{
    int x = 42;
    ...
}
// x dies when x goes out of scope. The memory
// used by x is reclaimed automatically by the
// the program.
\end{consolethree}
You can actually do this:

\begin{consolethree}[escapeinside=||]
auto int x = 42;
\end{consolethree}

but that's redundant \ldots C/C++ variables are automatic by default.

When you allocate memory for pointers, the values they point to are different. For instance you have already seen that
\begin{center}
\texttt{int * p = new int;}
\end{center}

creates an \texttt{int} value for \texttt{p} to point to. Note that

\begin{itemize}
\item
  \textbf{the value of }\texttt{\textbf{p}}\textbf{ (an address) is still
  automatic ... but }
\item
  \textbf{the value }\texttt{\textbf{p}}\textbf{ points to (an
  }\texttt{\textbf{int}}\textbf{) is not automatic}.
\end{itemize}

\begin{consolethree}[escapeinside=||]
if (i > 0)
{
    int * p = new int;
    ...
}

// p dies when p goes out of scope. The memory
// used by p is reclaimed automatically by the
// program. BUT the value p was pointing to is not
// reclaimed!!! 
\end{consolethree}
This is \EMPHASIZE{extremely important!!!}

This means that: When you leave the block where you declare a pointer variable \texttt{p} and called \texttt{new},

\begin{itemize}
\item
  Since \texttt{p} is automatic: the pointer \texttt{p} is destroyed and the
  memory used for the address in \texttt{p} reclaimed, but
\item
  Since *\texttt{p} is not automatic: the memory that \texttt{p} points to is not reclaimed by the computer. We'll talk about how to reclaim the memory later.
\end{itemize}

But anyway where exactly is the memory \texttt{p} points to? It's an an area called the \EMPHASIZE{free store}, also called the \EMPHASIZE{memory heap}. You basically request for memory space using the \texttt{new} command.
\begin{python}
from latextool_basic import *
from latexcircuit import POINT
p = Plot()

borderbox = Rect(0, 0, 6, 3, linewidth=0.1)
innerbox = Rect(1, 1, 4, 2, linewidth=0.05)
p += borderbox
p += innerbox

ptrbox = Rect(9, 2, 12, 3, linewidth=0.05, label='42')
p += ptrbox
p += Line(points=[(3.75, 1.5), (9, 2.5)], linewidth=0.075, linestyle='dashed', endstyle='>')

borderbox2 = Rect(7, 0, 13, 3, linewidth=0.1)
fstorelbl = Rect(8, 3.5, 8, 3.5, linecolor='white', label='Free store')

usemem = Rect(14, 2, 17, 3, linecolor='red', linewidth=0.1, innersep=0.1, label='Used memory', align='c')
unusedmem = Rect(14, 0, 17, 1, linecolor='red', linewidth=0.1, innersep=0.1, label='Used memory', align='c')
p += borderbox2
p += fstorelbl
p += usemem
p += unusedmem
p += Line(points=[(14, 2.5), (11, 2.5)], linecolor='red', linewidth=0.1, endstyle='>')
p += Line(points=[(14, 0.5), (11, 0.5)], linecolor='red', linewidth=0.1, endstyle='>')
print(p)
\end{python}

So our computational model now has the following pieces:
\begin{python}
from latextool_basic import *
p = Plot()

p += ellipse(-2, 4, 2, 7, linewidth=0.1)
p += Rect(0, 8, 0, 8, label='\\textbf{CPU}', linecolor='white')

p += Rect(3, 3, 7, 7, linewidth=0.1)
p += Rect(5, 8, 5, 8, label='\\textbf{Memory for functions}', linecolor='white')
p += Rect(3, 0, 7, 3, innersep=0.1, linecolor='white', s = 'For variables created in a function, including \\texttt{main()}', align='c')

p += Rect(8, 3, 12, 7, linewidth=0.1)
p += Rect(10, 8, 10, 8, label='\\textbf{Stack}', linecolor='white')
p += Rect(8, 0, 12, 3, innersep=0.1, linecolor='white', s = 'For values passed between functions and remembering point of return', align='c')

p += Rect(13, 3, 17, 7, linewidth=0.1)
p += Rect(15, 8, 15, 8, label='\\textbf{Free store or heap}', linecolor='white')
p += Rect(13, 0, 17, 3, innersep=0.1, linecolor='white', s = 'For values created using \\texttt{new}', align='c')

p += Rect(-2, -3, 2, -1, linewidth=0.1)
p += Rect(0, -0.5, 0, -0.5, label='\\textbf{Output}', linecolor='white')
print(p)
\end{python}
The free store will \EMPHASIZE{keep track of which part of its memory is already in use} via \texttt{new}. A piece of memory allocated to a pointer variable will be marked as used. That way, \EMPHASIZE{two calls to \texttt{new} will not give two pointers the same piece of memory}.

char * p = new char;

int * q = new int;

double * r = new double;

\newpage\EMPHASIZE{Memory Leaks}

I already said that memory allocated via \texttt{new} is \EMPHASIZE{not} released back to the free store automatically. \EMPHASIZE{This is a very important point!!!}

What will happen after calling the following \texttt{f} five times?

\begin{consolethree}[escapeinside=||]
void f()
{
    int * p = new int;
}

int main()
{
    ...
    f(); f(); f(); f(); f();
    ...
}
\end{consolethree}
\begin{python}
from latextool_basic import *
p = Plot(scale=0.85)

codebox = Rect(-10.2, 0, -2.0, 6, linewidth=0.05)

textbox0 = Rect(-8.75, 5.5, -9.0, 5.5, linewidth=0.0, label='\\texttt{void f()}', align='l')
textbox1 = Rect(-9.9, 5, -9.95, 5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox2 = Rect(-6.0, 4.5, -6.0, 4.5, linewidth=0.0, label='\\texttt{int * p = new int;}', align='l')
textbox3 = Rect(-9.9, 4, -9.95, 4, linewidth=0.0, label='\\texttt{\}}', align='l')
textbox4 = Rect(-8.65, 3, -8.8, 3, linewidth=0.0, label='\\texttt{int main()}', align='l')
textbox5 = Rect(-9.9, 2.5, -9.95, 2.5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox6 = Rect(-8.75, 2, -8.0, 2, linewidth=0.0, label='\\texttt{...}', align='l')
textbox7 = Rect(-5.25, 1.5, -5.25, 1.5, linewidth=0.0, label='\\texttt{f(); f(); f(); f(); f();}', align='l')
textbox8 = Rect(-8.75, 1, -8.0, 1, linewidth=0.0, label='\\texttt{...}', align='l')
textbox9 = Rect(-9.9, 0.5, -9.95, 0.5, linewidth=0.0, label='\\texttt{\}}', align='l')

p += codebox
p += textbox0
p += textbox1
p += textbox2
p += textbox3
p += textbox4
p += textbox5
p += textbox6
p += textbox7
p += textbox8
p += textbox9

reddot = Circle(x=-9.25, y=1.5, r=0.2, linecolor='red', background='red')
p += Line(points=[(-9.25, -1.5), (-9.25, 1.15)], linewidth=0.15, linecolor='red', endstyle='>')
p += reddot

execbox = Rect(-10.0, -3, -4.0, -2, linewidth=0.0,
               label='\\EMPHASIZE{Program execution at this point}')
p += execbox

membox = Rect(0.0, -1.5, 4.0, 5.5, linewidth=0.1)
memboxlabel = Rect(1.5, 7, 1.5, 7, linewidth=0.0, label='\\textbf{Memory for}')
memboxlabel0 = Rect(1.5, 6.5, 1.5, 6.5, linewidth=0.0, label='\\textbf{function calls}')

fstore = Rect(4.5, -1.5, 8.5, 5.5, linewidth=0.1)
fstorelabel = Rect(6.5, 7, 6.5, 7, linewidth=0.0, label='\\textbf{Free Store}')

mbox = Rect(0.5, -1, 3.5, 1.75, linewidth=0.1)
mboxlabel = Rect(1.5, 2.5, 1.5, 2.5, linewidth=0.0, label='\\textbf{main}')

p += membox
p += memboxlabel
p += memboxlabel0
p += fstore
p += fstorelabel
p += mbox
p += mboxlabel
print(p)
\end{python}

%image 2
\begin{python}
from latextool_basic import *
p = Plot(scale=0.85)

codebox = Rect(-10.2, 0, -2.0, 6, linewidth=0.05)

textbox0 = Rect(-8.75, 5.5, -9.0, 5.5, linewidth=0.0, label='\\texttt{void f()}', align='l')
textbox1 = Rect(-9.9, 5, -9.95, 5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox2 = Rect(-6.0, 4.5, -6.0, 4.5, linewidth=0.0, label='\\texttt{int * p = new int;}', align='l')
textbox3 = Rect(-9.9, 4, -9.95, 4, linewidth=0.0, label='\\texttt{\}}', align='l')
textbox4 = Rect(-8.65, 3, -8.8, 3, linewidth=0.0, label='\\texttt{int main()}', align='l')
textbox5 = Rect(-9.9, 2.5, -9.95, 2.5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox6 = Rect(-8.75, 2, -8.0, 2, linewidth=0.0, label='\\texttt{...}', align='l')
textbox7 = Rect(-5.25, 1.5, -5.25, 1.5, linewidth=0.0, label='\\texttt{f(); f(); f(); f(); f();}', align='l')
textbox8 = Rect(-8.75, 1, -8.0, 1, linewidth=0.0, label='\\texttt{...}', align='l')
textbox9 = Rect(-9.9, 0.5, -9.95, 0.5, linewidth=0.0, label='\\texttt{\}}', align='l')

reddot = Circle(x=-9, y=4.5, r=0.2, linecolor='red', background='red')
p += Line(points=[(-9.25, -1.5), (-9, 4.15)], linewidth=0.15, linecolor='red', endstyle='>')
p += reddot

execbox = Rect(-10.0, -3, -4.0, -2, linewidth=0.0,
               label='\\EMPHASIZE{Program execution at this point}')
execbox0 = Rect(-10.0, -4, -4.0, -3, linewidth=0.0,
               label='\\EMPHASIZE{(first time in f)}')

p += execbox
p += execbox0

membox = Rect(0.0, -1.5, 4.0, 5.5, linewidth=0.1)

fbox = Rect(0.5, 2.5, 3.5, 4.75, linewidth=0.1)
flabel = Rect(0.5, 5.5, 0.5, 5.5, linewidth=0.0, label='\\textbf{f}')

fstore = Rect(4.5, -1.5, 8.5, 5.5, linewidth=0.1)
fstorelabel = Rect(6.5, 7, 6.5, 7, linewidth=0.0, label='\\textbf{Free Store}')

mbox = Rect(0.5, -1.5, 3.5, 1.25, linewidth=0.1)
mboxlabel = Rect(1.5, 2, 1.5, 2, linewidth=0.0, label='\\textbf{main}')

p += membox
p += fbox
p += flabel

p += fstore
p += fstorelabel

p += mbox
p += mboxlabel

p += codebox
p += textbox0
p += textbox1
p += textbox2
p += textbox3
p += textbox4
p += textbox5
p += textbox6
p += textbox7
p += textbox8
p += textbox9

print(p)
\end{python}

%image 3
\begin{python}
from latextool_basic import *
p = Plot(scale=0.85)

codebox = Rect(-10.2, 0, -2.0, 6, linewidth=0.05)

textbox0 = Rect(-8.75, 5.5, -9.0, 5.5, linewidth=0.0, label='\\texttt{void f()}', align='l')
textbox1 = Rect(-9.9, 5, -9.95, 5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox2 = Rect(-6.0, 4.5, -6.0, 4.5, linewidth=0.0, label='\\texttt{int * p = new int;}', align='l')
textbox3 = Rect(-9.9, 4, -9.95, 4, linewidth=0.0, label='\\texttt{\}}', align='l')
textbox4 = Rect(-8.65, 3, -8.8, 3, linewidth=0.0, label='\\texttt{int main()}', align='l')
textbox5 = Rect(-9.9, 2.5, -9.95, 2.5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox6 = Rect(-8.75, 2, -8.0, 2, linewidth=0.0, label='\\texttt{...}', align='l')
textbox7 = Rect(-5.25, 1.5, -5.25, 1.5, linewidth=0.0, label='\\texttt{f(); f(); f(); f(); f();}', align='l')
textbox8 = Rect(-8.75, 1, -8.0, 1, linewidth=0.0, label='\\texttt{...}', align='l')
textbox9 = Rect(-9.9, 0.5, -9.95, 0.5, linewidth=0.0, label='\\texttt{\}}', align='l')

reddot = Circle(x=-3, y=4.5, r=0.2, linecolor='red', background='red')
p += Line(points=[(-9.25, -1.5), (-3, 4.15)], linewidth=0.15, linecolor='red', endstyle='>')
p += reddot

execbox = Rect(-10.0, -3, -4.0, -2, linewidth=0.0,
               label='\\EMPHASIZE{Program execution at this point}')
execbox0 = Rect(-10.0, -4, -4.0, -3, linewidth=0.0,
               label='\\EMPHASIZE{(first time in f)}')

p += execbox
p += execbox0

membox = Rect(0.0, -1.5, 4.0, 5.5, linewidth=0.1)

fbox = Rect(0.5, 2.5, 3.5, 4.75, linewidth=0.1)
flabel = Rect(0.5, 5.5, 0.5, 5.5, linewidth=0.0, label='\\textbf{f}')

pbox = Rect(1.25, 3, 3, 4, linewidth=0.05)
plabel = Rect(0.75, 4, 0.75, 4, label='p')
p += pbox
p += plabel
p += Line(points=[(2.5, 3.5), (5.6, 4.75)], linewidth=0.05, endstyle='>')

p += Line(points=[(6.75, 2.5), (6.75, 4.5)], linewidth=0.1, linecolor='red', endstyle='>')
markbox = Rect(5.5, -1, 7.5, 2, innersep=0.1, linewidth=0.0, s='This area is marked as used', align='c')
p += markbox
fstore = Rect(4.5, -1.5, 8.5, 5.5, linewidth=0.1)
fstorelabel = Rect(6.5, 7, 6.5, 7, linewidth=0.0, label='\\textbf{Free Store}')

fbluebox = Rect(6, 4.5, 7.5, 5, linewidth=0.0, background='blue')

mbox = Rect(0.5, -1.5, 3.5, 1.25, linewidth=0.1)
mboxlabel = Rect(1.5, 2, 1.5, 2, linewidth=0.0, label='\\textbf{main}')

p += membox
p += fbox
p += flabel

p += fstore
p += fstorelabel
p += fbluebox

p += mbox
p += mboxlabel

p += codebox
p += textbox0
p += textbox1
p += textbox2
p += textbox3
p += textbox4
p += textbox5
p += textbox6
p += textbox7
p += textbox8
p += textbox9

print(p)
\end{python}

%image 4
\begin{python}
from latextool_basic import *
p = Plot(scale=0.85)

codebox = Rect(-10.2, 0, -2.0, 6, linewidth=0.05)

textbox0 = Rect(-8.75, 5.5, -9.0, 5.5, linewidth=0.0, label='\\texttt{void f()}', align='l')
textbox1 = Rect(-9.9, 5, -9.95, 5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox2 = Rect(-6.0, 4.5, -6.0, 4.5, linewidth=0.0, label='\\texttt{int * p = new int;}', align='l')
textbox3 = Rect(-9.9, 4, -9.95, 4, linewidth=0.0, label='\\texttt{\}}', align='l')
textbox4 = Rect(-8.65, 3, -8.8, 3, linewidth=0.0, label='\\texttt{int main()}', align='l')
textbox5 = Rect(-9.9, 2.5, -9.95, 2.5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox6 = Rect(-8.75, 2, -8.0, 2, linewidth=0.0, label='\\texttt{...}', align='l')
textbox7 = Rect(-5.25, 1.5, -5.25, 1.5, linewidth=0.0, label='\\texttt{f(); f(); f(); f(); f();}', align='l')
textbox8 = Rect(-8.75, 1, -8.0, 1, linewidth=0.0, label='\\texttt{...}', align='l')
textbox9 = Rect(-9.9, 0.5, -9.95, 0.5, linewidth=0.0, label='\\texttt{\}}', align='l')

reddot = Circle(x=-9.5, y=4, r=0.2, linecolor='red', background='red')
p += Line(points=[(-9.25, -1.5), (-9.5, 3.85)], linewidth=0.15, linecolor='red', endstyle='>')
p += reddot

execbox = Rect(-10.0, -3, -4.0, -2, linewidth=0.0,
               label='\\EMPHASIZE{Program execution at this point}')
execbox0 = Rect(-10.0, -4, -4.0, -3, linewidth=0.0,
               label='\\EMPHASIZE{(first time in f,} \\EMPHASIZE{\\newline about to return)}')

p += execbox
p += execbox0

membox = Rect(0.0, -1.5, 4.0, 5.5, linewidth=0.1)

fbox = Rect(0.5, 2.5, 3.5, 4.75, linewidth=0.1)
flabel = Rect(0.5, 5.5, 0.5, 5.5, linewidth=0.0, label='\\textbf{f}')
p += Line(points=[(0.25, 2.25), (3.75, 5)], linewidth=0.15)
p += Line(points=[(0.25, 5), (3.75, 2.25)], linewidth=0.15)

markbox = Rect(5.5, -1, 8.25, 2, innersep=0.1, linewidth=0.0, s='On returning, memory used by \\texttt{f} is destroyed', align='c')
p += markbox
fstore = Rect(4.5, -1.5, 8.5, 5.5, linewidth=0.1)
fstorelabel = Rect(6.5, 7, 6.5, 7, linewidth=0.0, label='\\textbf{Free Store}')

fbluebox = Rect(6, 4.5, 7.5, 5, linewidth=0.0, background='blue')

mbox = Rect(0.5, -1.5, 3.5, 1.25, linewidth=0.1)
mboxlabel = Rect(1.5, 2, 1.5, 2, linewidth=0.0, label='\\textbf{main}')

p += membox
p += fbox
p += flabel

p += fstore
p += fstorelabel
p += fbluebox

p += mbox
p += mboxlabel

p += codebox
p += textbox0
p += textbox1
p += textbox2
p += textbox3
p += textbox4
p += textbox5
p += textbox6
p += textbox7
p += textbox8
p += textbox9

pbox = Rect(1.25, 3, 3, 4, linewidth=0.05)
plabel = Rect(0.75, 4, 0.75, 4, label='p')
p += pbox
p += plabel
p += Line(points=[(2.5, 3.5), (5.6, 4.75)], linewidth=0.05, endstyle='>')
p += Line(points=[(6.75, 2.5), (3.75, 4)], linewidth=0.1, linecolor='red', endstyle='>')

print(p)
\end{python}

%image 5
\begin{python}
from latextool_basic import *
p = Plot(scale=0.85)

codebox = Rect(-10.2, 0, -2.0, 6, linewidth=0.05)

textbox0 = Rect(-8.75, 5.5, -9.0, 5.5, linewidth=0.0, label='\\texttt{void f()}', align='l')
textbox1 = Rect(-9.9, 5, -9.95, 5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox2 = Rect(-6.0, 4.5, -6.0, 4.5, linewidth=0.0, label='\\texttt{int * p = new int;}', align='l')
textbox3 = Rect(-9.9, 4, -9.95, 4, linewidth=0.0, label='\\texttt{\}}', align='l')
textbox4 = Rect(-8.65, 3, -8.8, 3, linewidth=0.0, label='\\texttt{int main()}', align='l')
textbox5 = Rect(-9.9, 2.5, -9.95, 2.5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox6 = Rect(-8.75, 2, -8.0, 2, linewidth=0.0, label='\\texttt{...}', align='l')
textbox7 = Rect(-5.25, 1.5, -5.25, 1.5, linewidth=0.0, label='\\texttt{f(); f(); f(); f(); f();}', align='l')
textbox8 = Rect(-8.75, 1, -8.0, 1, linewidth=0.0, label='\\texttt{...}', align='l')
textbox9 = Rect(-9.9, 0.5, -9.95, 0.5, linewidth=0.0, label='\\texttt{\}}', align='l')

execbox = Rect(-10.0, -3, -4.0, -2, linewidth=0.0,
               label='\\EMPHASIZE{Program execution at this point}')
execbox0 = Rect(-10.0, -4, -4.0, -3, linewidth=0.0,
               label='\\EMPHASIZE{(about to call f() a second time)}')

p += execbox
p += execbox0

membox = Rect(0.0, -1.5, 4.0, 5.5, linewidth=0.1)

markbox = Rect(5.5, -1, 8.25, 2, innersep=0.1, linewidth=0.0, s='this area is still marked as used', align='c')
p += markbox
fstore = Rect(4.5, -1.5, 8.5, 5.5, linewidth=0.1)
fstorelabel = Rect(6.5, 7, 6.5, 7, linewidth=0.0, label='\\textbf{Free Store}')

fbluebox = Rect(6, 4.5, 7.5, 5, linewidth=0.0, background='blue')

mbox = Rect(0.5, -1.5, 3.5, 1.25, linewidth=0.1)
mboxlabel = Rect(1.5, 2, 1.5, 2, linewidth=0.0, label='\\textbf{main}')

p += membox

p += fstore
p += fstorelabel
p += fbluebox

p += mbox
p += mboxlabel

reddot = Circle(x=-7.25, y=1.35, r=0.15, linecolor='red', background='red')
p += Line(points=[(-9.25, -1.5), (-7.25, 1.15)], linewidth=0.15, linecolor='red', endstyle='>')
p += reddot
p += Line(points=[(6.75, 2.5), (6.75, 4)], linewidth=0.1, linecolor='red', endstyle='>')

p += codebox
p += textbox0
p += textbox1
p += textbox2
p += textbox3
p += textbox4
p += textbox5
p += textbox6
p += textbox7
p += textbox8
p += textbox9

print(p)
\end{python}


%image 6
\begin{python}
from latextool_basic import *
p = Plot(scale=0.85)

codebox = Rect(-10.2, 0, -2.0, 6, linewidth=0.05)

textbox0 = Rect(-8.75, 5.5, -9.0, 5.5, linewidth=0.0, label='\\texttt{void f()}', align='l')
textbox1 = Rect(-9.9, 5, -9.95, 5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox2 = Rect(-6.0, 4.5, -6.0, 4.5, linewidth=0.0, label='\\texttt{int * p = new int;}', align='l')
textbox3 = Rect(-9.9, 4, -9.95, 4, linewidth=0.0, label='\\texttt{\}}', align='l')
textbox4 = Rect(-8.65, 3, -8.8, 3, linewidth=0.0, label='\\texttt{int main()}', align='l')
textbox5 = Rect(-9.9, 2.5, -9.95, 2.5, linewidth=0.0, label='\\texttt{\{}', align='l')
textbox6 = Rect(-8.75, 2, -8.0, 2, linewidth=0.0, label='\\texttt{...}', align='l')
textbox7 = Rect(-5.25, 1.5, -5.25, 1.5, linewidth=0.0, label='\\texttt{f(); f(); f(); f(); f();}', align='l')
textbox8 = Rect(-8.75, 1, -8.0, 1, linewidth=0.0, label='\\texttt{...}', align='l')
textbox9 = Rect(-9.9, 0.5, -9.95, 0.5, linewidth=0.0, label='\\texttt{\}}', align='l')

execbox = Rect(-10.0, -3, -4.0, -2, linewidth=0.0,
               label='\\EMPHASIZE{Program execution at this point}')
execbox0 = Rect(-10.0, -4, -4.0, -3, linewidth=0.0,
               label='\\EMPHASIZE{(about to call f() a second time)}')

p += execbox
p += execbox0

membox = Rect(0.0, -1.5, 4.0, 5.5, linewidth=0.1)

#markbox = Rect(5.5, -1, 8.25, 2, innersep=0.1, linewidth=0.0, s='this area is still marked as used', align='c')
#p += markbox
fstore = Rect(4.5, -1.5, 8.5, 5.5, linewidth=0.1)
fstorelabel = Rect(6.5, 7, 6.5, 7, linewidth=0.0, label='\\textbf{Free Store}')

fbluebox = Rect(6, 4.5, 7.5, 5, linewidth=0.0, background='blue')
fbox = Rect(0.5, 2.5, 3.5, 4.75, linewidth=0.1)
flabel = Rect(0.5, 5.5, 0.5, 5.5, linewidth=0.0, label='\\textbf{f}')

mbox = Rect(0.5, -1.5, 3.5, 1.25, linewidth=0.1)
mboxlabel = Rect(1.5, 2, 1.5, 2, linewidth=0.0, label='\\textbf{main}')

p += membox

p += fstore
p += fstorelabel
p += fbluebox
p += fbox
p += flabel

p += mbox
p += mboxlabel

p += codebox
p += textbox0
p += textbox1
p += textbox2
p += textbox3
p += textbox4
p += textbox5
p += textbox6
p += textbox7
p += textbox8
p += textbox9

reddot = Circle(x=-9, y=4.5, r=0.2, linecolor='red', background='red')
p += Line(points=[(-9.25, -1.5), (-9, 4.15)], linewidth=0.15, linecolor='red', endstyle='>')
p += reddot

print(p)
\end{python}


After some time \ldots
%% \begin{python}
%% \end{python}
The problem \ldots

Memory allocated is not released back to free store after use!!! When this happens too frequently, you will run out of memory. Your program might crash!!! The above problem is called a \EMPHASIZE{memory leak} -- memory allocated was not deallocated.

\begin{ex}
Run this program.

\begin{consolethree}[escapeinside=||]
int main()
{
    while (1)
    {
        int * p = new int;
    }
    return 0;
}
\end{consolethree}
What will happen after a couple of minutes? Why?
\end{ex}

Again \ldots memory allocated from the free store is \EMPHASIZE{not} automatically reclaimed/released when you exit the block where the memory was allocated. The integer \texttt{p} of \texttt{f()} is pointing to is not released.

What should we do then??? \ldots

\newpage\EMPHASIZE{\texttt{delete}}

After doing a \texttt{new}, you can return the memory back to the heap by
doing a \texttt{delete}. For instance:

\begin{consolethree}[escapeinside=||]

int * p = new int;

// ... do something here with *p ...

delete p;
\end{consolethree}
After \texttt{delete p}, the heap will \EMPHASIZE{mark the memory that p is pointing to as available} (i.e. not in use). This is called \EMPHASIZE{deallocating} the memory that \texttt{p} is using or \EMPHASIZE{releasing} the memory \texttt{p} is using back to the heap.

Here are some really important points:

\begin{itemize}

\item
  Delete pointers ASAP when you don't need them anymore.
\item
  As much as possible, delete pointers in the same block where you
  new'ed them. You should see new and delete for a pointer in the same
  block. (There are exceptions.)
\end{itemize}

After a pointer is deleted it should not be dereferenced. If you need memory again, you just do another \texttt{new}:

\begin{consolethree}[escapeinside=||]
if (x > 42)
{
    int * p = new int;

    // ... do something with *p ...

    delete p;

    // DO NOT USE *p HERE

    p = new int;

    // ... do something with *p ...

    delete p;

    // DO NOT USE *p HERE
}

// p is destroyed 
\end{consolethree}
Note that when \texttt{p} is pointing to memory not in the heap obtained by \texttt{new}, then you do NOT \texttt{delete p}. For instance:

\begin{consolethree}[escapeinside=||]
int x = 42;

int * p = &42;

int * q = new int;

delete p; // BAD!!!

delete q; // OK
\end{consolethree}
And of course you do not release if you did not \texttt{new} it:

\begin{consolethree}[escapeinside=||]
double * p;

delete p; // Huh????
\end{consolethree}
Put in a different way: you cannot give a memory back to the heap if you did not get it from the heap to begin with.

The tendency is to forget to deallocate and then re-allocate, like this:

\begin{consolethree}[escapeinside=||]
int * p;

// I need an int ...

p = new int;

// ... now use *p

// 1000 lines later ...

// Lack of sleep ... I need an int ...

p = new int;

// ... now use *p

// 1000 lines later ...

// Amnesia kicks in ... I need an int ...

p = new int;

// ... now use *p
\end{consolethree}
Can you say ``memory leak''?!?! So deallocate ASAP!!! Don't argue!!!

\begin{ex}
The following program does compile and does run. But it has a problem. Fix it by adding ONE statement.

\begin{consolethree}[escapeinside=||]
#include <iostream>

int sum(int n)
{
    int s = 0;
    int * i = new int;
    for (*i = 0; *i <= n; ++(*i))
    {
        s += *i;
    }
    return s;
}

int main()
{   
    std::cout << sum(10) << '\n';
    return 0;
}
\end{consolethree}
\end{ex}
\begin{ex}
Fixit time \ldots (you are only allowed to delete one statement.)

\begin{consolethree}[escapeinside=||]
#include <iostream>

void average(double x[])
{
    double x = 0;
    double * px = &x;
    for (int i = 0; i < 10; ++i)
    {
        *px += x[i];
    }

    x = *px / 10;
    delete px;
    return x;
}

int main()
{
    double x[5] = {1.1, 2.1, 2.3, 3.2, 3.4};
    std::cout << average(x) << std::endl;
    return 0;
}
\end{consolethree}
\end{ex}
\begin{ex}
The following program prompts the user for two integer values and then prints the sum. Do NOT use integer or double variables. You can only use pointers. In fact I have already declared all the variables you need, i.e., two pointer variables. You must allocate and deallocate memory correctly.

\begin{consolethree}[escapeinside=||]
#include <iostream>

int main()
{
    int * p;
    int * q;

    // allocate memory for p

    // allocate memory for q

    // prompt for integer value and store at integer

    // that p points to

    // prompt for integer value and store at integer

    // that q points to

    // print the sum of integers that p and q point

    // to
    
    // deallocate memory used by q

    // deallocate memory used by p

   return 0;
}
\end{consolethree}
\end{ex}

\begin{ex}
Write a number guessing game. First generate a random integer in the range 1..10. Then prompt the user for an integer value. If his/her guess is correct, print ``you got it!''. If his/her guess is too low, print ``too low!'' and prompt him/her again. If his/her guess is too high, print ``too high!'' and prompt him/her again. OK \ldots here's the point, you can only use pointer variables and you must allocate and deallocate memory for your pointers correctly.
\end{ex}

\begin{ex}
Deallocate memory appropriately.

\begin{consolethree}[escapeinside=||]
int f(int a)
{
    int x = a;
    int * y = &a;
    x = a + *y;
    return 2 * x;
}

int g(int a)
{
    int * y = new int;
    if (a < 0)
    {
        int x = f(2 * a);
        int * y = new int;
        y = a + 1;
        x = 2 * *y;
        return x;
    }
    *y = a + 1;
    a = 2 * a;
    return a;
}

int main()
{
    std::cout << g(42) << std::endl;
    return 0;
}
\end{consolethree}

\end{ex}

\begin{ex}
Deallocate memory appropriately.

\begin{consolethree}[escapeinside=||]
int f(int a)
{
    int x = a;
    int * y = &a;
    x = a + *y;
    return 2 * x;
}

int g(int a)
{

   int * y = new int;
   if (a < 0)
   {
        int x = f(2 * a);
        int * y = new int;
        y = a + 1;
        x = 2 * *y;
        return x;
    }
    *y = a + 1;
    a = 2 * a;
    return a;
}

int main()
{
    std::cout << g(42) << std::endl;
    return 0;
}
\end{consolethree}
\end{ex}

\newpage\EMPHASIZE{Use of \texttt{NULL} for memory management}

Recall that \texttt{NULL} is a predefined constant for 0 (as an address)
and it's used to denote an invalid address. We can use \texttt{NULL} to
denote the fact that a pointer has not been allocated.

Look at this:

\begin{consolethree}[escapeinside=||]
int * p = NULL;
// *p is not used yet

...

// Now you're ready to use an int on the heap
p = new int;
// use *p

...
// Now you don't need the int on the heap anymore
delete p;
p = NULL;

...
\end{consolethree}
If you always set your pointer \texttt{p} to \texttt{NULL} when memory is not allocated for \texttt{p} to point to, then you can always check your pointer against \texttt{NULL} like this:

\begin{consolethree}[escapeinside=||]
int * p = NULL;

...

if (p == NULL)
{
    p = new int;
}

// use *p ...
delete p;
p = NULL;

...

if (p == NULL)
{
    p = new int;
}

// use *p ...
delete p;
p = NULL;

...
\end{consolethree}
Why use the free store?

You might ask \ldots why bother requesting for an \texttt{int} inside the free store?

\begin{consolethree}[escapeinside=||]
int * p = new int;
// ... now use *p
delete p;
\end{consolethree}
That's so much trouble \ldots why not just create a plain \texttt{int} variable:

\begin{consolethree}[escapeinside=||]
int x;
// ... now use x
\end{consolethree}
That is true!

Actually the notes from the previous section is just to show you how to use the memory heap. In most cases, you use the heap by requesting for a \texttt{\textbf{\underline{very huge}}} chunk of memory from the free store and not for a single \texttt{int}. In other words, dynamic memory management is useful only for large memory usage. As an example, consider the following scenario:

Suppose you have some type \texttt{T} that requires a huge amount of memory. Say a variable of type \texttt{T} is some kind of an image for a game and a variable of type \texttt{T} holds one megabytes of pixel data. Maybe you need 3 such variables:

\begin{center}
\texttt{T bigvar0, bigvar1, bigvar2;}
\end{center}

In this case all these 3 huge variables will consume 3 MB of memory.

But what if you don't always need them at the same time? Say \ldots

\begin{consolethree}[escapeinside=||]
T bigvar0, bigvar1, bigvar2;

// use bigvar0 for 10 min

// use bigvar1 for 10 min

// use bigvar1 and bigvar2 for 10 min

// use bigvar0 for 10 min 
\end{consolethree}
Then you might want to do this instead:

\begin{consolethree}[escapeinside=||]
T *bigvar0, *bigvar1, *bigvar2;

bigvar0 = new T; // 1 MB used
// use bigvar0 for 10 min
delete bigvar0; // 0 MB used

bigvar1 = new T; // 1 MB used
// use bigvar1 for 10 min

bigvar2 = new T; // 2 MB used
// use bigvar1 and bigvar2 for 10 min
delete bigvar1; // 1 MB used
delete bigvar2; // 0 MB used

bigvar0 = new T; // 1 MB used
// use bigvar0 for 10 min
delete bigvar0; // 0 MB used
\end{consolethree}
This means that you actually only need about 2 MB of memory at any point
in time while running the program, not 3 MB.

Get it?

Later I'll talk about requesting not just memory for a value, but a whole array of values. When the array size is huge, this will take up a lot or memory even if each value in the array is only an \texttt{int}. For instance:

\texttt{int x[1000000];}

takes up 4 x 1,000,000 = 4,000,000 bytes. Dynamic memory management is also important when it comes to managing objects (see CISS245, CISS350) since objects usually occupy more memory.

\newpage\EMPHASIZE{Pointer to Pointer to Pointer to \ldots}

Now take a \texttt{\textbf{deep}} breath \ldots

Look at this:

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p = &x;
\end{consolethree}
Here's the memory model:

So \texttt{p} has the memory address of some value (in this case an \texttt{int} value). But wait a minute\ldots memory address are also values \ldots so the value of \texttt{p} is also somewhere in memory too. For instance suppose the address of the value of x is 124500 and that value is stored in \texttt{p} and the value of \texttt{p} is stored in 124504:

Since 124504 is also an address, surely you can store 124504 into a variable too. In fact, yes, you can. Looking at this:

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p = &x;
int ** q = &p;
\end{consolethree}
While we say the type of \texttt{p} is ``pointer to \texttt{int}'', for \texttt{q} we say the type is ``pointer to pointer to \texttt{int}''. Suppose the address of the value of \texttt{q} is 124508. Here's the memory model

And here's the simplified picture:

Now think about this: What is \texttt{*q}? Using \texttt{*p} as a guide,

\begin{itemize}

\item
  \texttt{p} points to \texttt{x} therefore \texttt{*p} is the value of
  \texttt{x}, i.e., \texttt{*p is }42,
\item
  \texttt{q} points to \texttt{p} therefore \texttt{*q} is the value of
  \texttt{p}
\end{itemize}

So \texttt{*q} must be the memory address value stored in pointer variable \texttt{p}.

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p = &x;
int ** q = &p;

std::cout << x << ' ' << *p << '\n';

std::cout << p << ' ' << *q << '\n';
\end{consolethree}
But wait ... since \texttt{p} is \texttt{*q}, you can dereference \texttt{p}\ldots so you should be able to dereference *q and get \ldots right?

\begin{itemize}

\item
  \texttt{p} points to \texttt{x} therefore \texttt{*p} is \texttt{x}
\item
  \texttt{q} points to \texttt{p} therefore \texttt{*q} is \texttt{p and **q} is
  \texttt{*p} which is \texttt{x}
\end{itemize}

\begin{consolethree}[escapeinside=||]
int x = 42;
int * p = &x;
int ** q = &p;

std::cout << x << ' ' << *p << '\n';

std::cout << p << ' ' << *q << '\n';

std::cout << x << ' ' << *p << ' '
          << **q << '\n';
\end{consolethree}
Thinking of the dereferencing operator \texttt{*} as ``follow the arrow and go into a box'', you can think of \texttt{**} as following \EMPHASIZE{two} arrows and peek into the box you arrive at.

Correct?

To understand the above better, you can go all the way into the actual memory. For instance suppose the value of \texttt{x} lives at address 124500. Remember that an \texttt{int} occupies 4 bytes (for 32 bit machines). And in the computer's memory, the 42 is stored as a bunch of 0s and 1s. But for simplicity, let's just ignore the 0s and 1s of 42 and conceptually put 42 into the memory:

I'm putting \texttt{x} next to 124500 just to remind us that the address of \texttt{x} is 124500. Next, \texttt{p} has the address of \texttt{x}.
Memory address also takes up 4 bytes (again assuming we're using a 32-bit machines). Suppose the address of the value of \texttt{p} 124504:

Now it becomes really clear that even \texttt{p} has an address: the value of \texttt{p} (which is a memory address value) sits at address 124504, i.e., \texttt{\&p} is 124504. Right? Suppose the address of the value of \texttt{q}, is 124508. The memory looks like this;

Get it? Make sure you see that

\begin{itemize}

\item
  \texttt{\&p} is 124504, \texttt{p} is 124500, \texttt{*p} is 42
\item
  \texttt{\&q} is 124508, \texttt{q} is 124504, \texttt{*q} is 124500
\end{itemize}

You see that in some sense knowing low level details actually helps you understand completely what pointers really are and you can see pointer to pointer very easily. (Or even pointer to pointer to pointer to pointer!)

Of course the three type \texttt{int}, \texttt{int*}, \texttt{int**} are different and obviously you should not assign them to each other (with the exception of 0 which can be assigned to any pointer). So the following is WRONG:

\begin{consolethree}[escapeinside=||]
int x = 42;

int * y = x;    // ABOMINABLE ... giving int to int*

int ** z = x;   // HORRORS ... giving int to int**

z = y;          // UNSPEAKABLE ... giving int* to int** 
\end{consolethree}

\begin{ex}
What is the type of \texttt{p}?

Write a statement that adds \texttt{0.5} to the \texttt{3.14} value in the picture using only \texttt{p}.
\end{ex}

\begin{ex}
At one point in the execution of a program, you have the following memory model:

Write one statement that will change the value of \texttt{**p} by incrementing it with the value of \texttt{**q}. Use \texttt{p} and \texttt{q} and not hard-coded constants.
\end{ex}

\begin{ex}
At one point in the execution of a program, you have the following memory model:

Is it possible to execute one or more statements to get the following:

If it is, write the statements (use the least number). If it isn't explain why.
\end{ex}

\begin{ex}
At one point in the execution of a program, you have the following memory model:

Is it possible to execute one or more statements to get the following:

If it is, write the statements (use the least number please). If it isn't explain why.
\end{ex}

\begin{ex}
At one point in the execution of a program, you have the following memory model:

Is it possible to execute one or more statements to get the following:

If it is, write the statements (use the least number please). If it isn't explain why.
\end{ex}

\begin{ex}
What is the output? (Or is it an error?)

\begin{consolethree}[escapeinside=||]
int i = 42;
int * p = &i;
int ** q = &p;

std::cout << *p << ' ' << **q << '\n'; 
\end{consolethree}
(Hint: Draw!!!)
\end{ex}

\begin{ex}
What is the output? (Or is it an error?)

\begin{consolethree}[escapeinside=||]
int i = 42;
int * p = &i;
int ** q = &p;
int *** r = &q;

std::cout << *p << ' ' << **q << ' '
          << ***r << '\n'; 
\end{consolethree}
\end{ex}

\begin{ex}
What is the output? (Or is it an error?)

\begin{consolethree}[escapeinside=||]
int i = 42;
int * p = &i;
int ** q = &p;
int *** r = &q;
***r = 0;

std::cout << *p << ' ' << **q << ' '
          << ***r << '\n'; 
\end{consolethree}
\end{ex}

\begin{ex}
What is the output? (Or is it an error?)

\begin{consolethree}[escapeinside=||]
int i = 42;
int * p = &i;
int * q = *&p;

std::cout << *p << ' ' << *q << '\n'; 
\end{consolethree}
\end{ex}

\begin{ex}
What is the output? (Or is it an error?)

\begin{consolethree}[escapeinside=||]
int i = 42;
int * p = &i;
int *** q = &&p;

std::cout << *p << ' ' << *q << '\n'; 
\end{consolethree}
\end{ex}

\begin{ex}
What is the output? (Or is it an error?)

\begin{consolethree}[escapeinside=||]
int i = 42;
int * p = &i;
int * q = &(*p);

std::cout << *p << ' ' << *q << '\n'; 
\end{consolethree}
\end{ex}

\newpage\EMPHASIZE{Functions that change pointer values}

Recall that a function can change a value back in the caller. You can either pass in pointers or use pass-by-reference: Always keep this example in mind:

\begin{consolethree}[escapeinside=||]
// DOES NOT WORK!!!
// void inc(int x)
// {
// x++;\\
// }

void inc(int * x) // or ``int * const x''
{
    (*x)++;
}

void inc(int & x)
{
    x++;
}

int main()
{
    int x = 42;
    inc(&x);    // x is 43
    inc(x);     // x is 44
}
\end{consolethree}
The same idea can be used to change the value of anything you like \ldots including changing the value of pointers.

\begin{ex}
Explain what's happening in the program below. Is there a problem? How would you fix it?

\begin{consolethree}[escapeinside=||]
#include <iostream>
#include <cstddef>

void setnull(int * p)
{
    p = NULL;
}

int main()
{
    int * p;
    setnull(p);

    std::cout << (unsigned int) p << std::endl; // 0?

    return 0;
}
\end{consolethree}
\end{ex}

\begin{ex}
Explain what's happening in the program below. Is there a problem? How would you fix it?

\begin{consolethree}[escapeinside=||]
#include <iostream>
#include <cstddef>

void swap(int * p, int * q)
{
    int * t = p;
    p = q;
    q = t;
}

int main()
{
    int x = 0, y = 42;
    int * p = &x, * q = &y;

    std::cout << *p << ' ' << *q << '\n'; // 0 42

    swap(p, q); // p should point to x

                // q should point to y

                // Do you get 42 0?

    std::cout << *p << ' ' << *q << '\n';
    return 0;
}
\end{consolethree}
\end{ex}

\begin{ex}
Explain what's happening in the program below. Is there a problem?

\begin{consolethree}[escapeinside=||]
void mynew(int * p)
{
    p = new int;
}

int main()
{
    int * p;
    mynew(p);
    *p = 42;
    return 0;
}
\end{consolethree}
\end{ex}

\begin{ex}
Explain what's happening in the program below. Is there a problem?

\begin{consolethree}[escapeinside=||]          
void mydelete(int * p)
{
    delete p;
}

int main()
{
    int * p;
    mydelete(p);
    return 0;
}
\end{consolethree}
\end{ex}

\begin{ex}
The following function \texttt{copy()} copies the data that one pointer is pointing to to the other pointer. In more details, \texttt{copy(p, q)} will

\begin{itemize}
\item
  Allocate memory for \texttt{p} (if \texttt{p} has not been allocated
  memory; \texttt{p} has value \texttt{NULL} if it has not been allocated
  memory)
\item
  Copy the integer \texttt{q} points to over to the integer \texttt{p}
  points to.
\item
  Deallocate the memory \texttt{q} points to and set \texttt{q} to
  \texttt{NULL}.
\end{itemize}
  Test it!

\end{ex}
