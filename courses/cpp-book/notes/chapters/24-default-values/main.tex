\newpage\EMPHASIZE{24. Default Values}

\textsc{Objectives}
\begin{itemize}
\item Write functions with default values
\item Use default values to extend a function
\item Write prototypes for functions with default values and implement the bodies of such functions.
\end{itemize}


\newpage\EMPHASIZE{Default Values}

Try this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void printHeads(int numHeads = 1)
{
    std::cout << "number of heads: " << numHeads
              << std::endl;
}

int main()
{
    printHeads(); // NO ARGUMENT PASSED IN!!!
    printHeads(42);
    return 0;
}
\end{consolethree}

(Forget about prototypes for the time being. They will come in a bit ...)

Parameter \texttt{numHeads} of function \texttt{printHeads()} is called a parameter with a \EMPHASIZE{default value}.

One obvious use of default values is that you can make it easier for other programmers to use your function: You choose the most common value for a parameter and make it the default value for that parameter. Any time someone (including yourself) uses the function in the ``most commonly used'' manner, he/she need not send in an argument.

Here's another example:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void printHello(int i = 0)
{
    std::cout << "hello ";
    switch (i)
    {
        case 0: std::cout << "world\n"; break;
        case 1: std::cout << "galaxy\n"; break;
        case 2: std::cout << "universe\n"; break;
        case 3: std::cout << "underverse\n"; break;
    }
}

int main()
{
    printHello();
    printHello(1);
    return 0;
}
\end{consolethree}

Right now there are only \EMPHASIZE{three rules} to remember: Think of the parameters of a function as parameters without default values and parameters with default values. \EMPHASIZE{All the parameters with default values must be together} and appear \EMPHASIZE{after those without default values}.

In other words this is OK:

\begin{consolethree}[escapeinside=||]
bool spam(int a, double b, |\textbf{\underline{char c = '\$', int d = 42}}|)
{
    ...
}
\end{consolethree}

But this is WRONG:

\begin{consolethree}[escapeinside=||]
bool spam(int a, |\textbf{\underline{double b = 3.14}}|, char c, |\textbf{\underline{int d = 42}}|)|\xsidebox[0cm]{0cm}{}{txt2}{\texttt{c} does not have a default value but appears after \texttt{b} which has a default value.}|
{
    ...
}
\end{consolethree}

Make sure you try this or you won't remember.

So remember to group up the parameters into those with default values
and those without. The ones without (if any) must come first.

Another rule: \textbf{default values must be constants} (example:
constant literals such as 5 or constant expressions.) In other words
this is OK:

\begin{consolethree}[escapeinside=||]
const int X = 42;
bool spam(int a, double b, char c = '$', int d = X+1)
{
    ...
}
\end{consolethree}

But this is WRONG:

\begin{consolethree}[escapeinside=||]
int X = 42;
bool spam(int a, double b, char c = '$', int d = X)
{
    ...
}
\end{consolethree}

\begin{ex}
What is the output (or circle the errors)? (Do this by hand)

\begin{consolethree}[escapeinside=||]
int f(int a, int b = 4, int c = 5)
{
    return a + b + c;
}

int main()
{
    std::cout << f(1, 2, 3) << ' ' << f(1, 2) << ' '
              << f(1) << std::endl;
    return 0;
}
\end{consolethree}

Now verify using your compiler.
\end{ex}

Last one: \EMPHASIZE{You cannot have default values for array parameters.} For instance the following will not compile:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void print(int x[] = {2, 3})
{
    std::cout << x[0] << ' ' << x[1];
}

int main()
{
    print();
    return 0;
}
\end{consolethree}

(See last section for exception.)

\begin{ex}
What is the output (or circle the errors)? (Do this by hand)

\begin{consolethree}[escapeinside=||]
int f(int a = 3, int b, int c = 5)
{
    return a + b + c;
}

int main()
{
    std::cout << f(1, 2, 3) << std::endl;
    return 0;
}
\end{consolethree}

Now verify using your compiler.
\end{ex}

\begin{ex}
Write a function \texttt{printDateTime()} that prints the date and time data passed in:

\begin{consolethree}[escapeinside=||]
void printDateTime(int yyyy, int mm, int dd,
                   int hh = 0, int mm = 0, int ss = 0)
{
    ... CODE ...
}

int main()
{
    printDateTime(2007, 1, 15);
    printDateTime(2007, 1, 15, 14, 15, 59);
    return 0;
}
\end{consolethree}

Expected output:

\begin{console}
2007-01-15 00:00:00
2007-01-15 14:15:59
\end{console}

After you are done, make January 1, 1970 the default date.

[Hint: Use \texttt{std::fill()} function.]
\end{ex}


\newpage\EMPHASIZE{Default value parameter and nonconstant value}

One more example. Recall we have the \texttt{isprime()} that returns \texttt{true} if the values passed in is a prime number, otherwise \texttt{false} is returned.

\begin{consolethree}[escapeinside=||]
bool isprime(int n)
{
    for (int i = 2; i <= sqrt((double)n); i++)
    {
        if (n % i == 0) return false;
    }
    return true;
}
\end{consolethree}

Suppose for some reason you know something about n: if there is a prime divisor of n, then it must be at least 11. You might want to tell \texttt{isprime()} to start the search for a divisor from 11.

Let's modify the function preserving the older use:

\begin{consolethree}[escapeinside=||]
#include <iostream>
#include <cmath>

bool isprime(int n, int start = 2)
{
    for (int i = start; i <= sqrt((double)n); i++)
    {
        if (n % i == 0) return false;
    }
    return true;
}

int main()
{
    std::cout << isprime(5) << '\n'
              << isprime(5, 3) << '\n'
              << isprime(169, 11) << std::endl;
    return 0;
}
\end{consolethree}

Now let's try to generalize the upper bound of the search. Let's try this:

\begin{consolethree}[escapeinside=||]
#include <iostream>
#include <cmath>

bool isprime(int n,
             int start = 2,
             |\textbf{int end = sqrt((double)n))}|
{
    for (int i = start; i <= end; i++)
    {
        if (n % i == 0) return false;
    }
    return true;
}

int main()
{
    std::cout << isprime(5) << '\n'
              << isprime(5, 3) << '\n'
              << isprime(169, 11) << std::endl;
    return 0;
}
\end{consolethree}

Does it work?

It \EMPHASIZE{won't work} because remember you can only use constants for default values. So how do you set a parameter to ``default value'' that depends on an expression like the above? This is how you do it:

\begin{consolethree}[escapeinside=||]
#include <iostream>
#include <cmath>

bool isprime(int n, int start = 2, int end = -1)
{
    |\textbf{if (end == -1) end = sqrt(double(n));}|
    for (int i = start; i <= end; i++)
    {
        if (n % i == 0) return false;
    }
    return true;
}

int main()
{
    std::cout << isprime(5) << '\n'
              << isprime(5, 3) << '\n'
              << isprime(169, 11) << '\n'
              << isprime(21, 3, 7);
    return 0;
}
\end{consolethree}

Of course in this case we must choose a reasonable default value for parameter \texttt{end}. In the above case, I choose a value the user won't be using. This is similar to the use of the sentinel values in terminating a while-loop.

Note that a default values can be from a function call as long as the function call involves only constants. Make sure you run this:

\begin{consolethree}[escapeinside=||]
int g(int x)
{
    return x * x;
}

void f(int x, int y = g(42))
{}
\end{consolethree}


\newpage\EMPHASIZE{Function extension}

As I've just mentioned, one reason for default values is to make a function convenient to use. You basically set parameter values to the most common values.

There is actually \EMPHASIZE{another use} of default values that's not usually mentioned in some textbooks.

Default values can be used to \EMPHASIZE{extend the functionality} of a function without breaking existing code. Here's what I mean.

Suppose you have a program that computes the average of an array of 3 elements:

\begin{consolethree}[escapeinside=||]
double avg(int x[])
{
    int s = 0;
    for (int i = 0; i < 3; i++)
    {
        s += a[i];
    }
    return s / 3.0;
}

int main()
{
    int x[] = {1, 2, 3};
    std::cout << avg(x) << std::endl;
    return 0;
}
\end{consolethree}

What if you now want to average over 5 elements? You can write a new function that averages over 5 elements. Of course you know now that you should have written a function to average over general lengths.

\begin{consolethree}[escapeinside=||]
double avg(int x[])
{
    int s = 0;
    for (int i = 0; i < 3; i++)
    {
        s += a[i];
    }
    return s / 3.0;
}

double avg2(int x[], int len)
{
    int s = 0;
    for (int i = 0; i < len; i++)|\xsidebox[0cm]{0cm}{}{txt1}{BAD! Code duplication! The functions look almost the same.}|
    {
        s += a[i];
    }
    return (double) s / len;
}

int main()
{
    int x[] = {1, 2, 3};
    std::cout << avg(x) << std::endl;
    int y[] = {1, 2, 3, 4};
    std::cout << avg2(y, 4) << std::endl;
    return 0;
}
\end{consolethree}

Another way would be to modify the original function. But of course all uses of the previous version of \texttt{avg()} must be changed; you need to add a size to the function call:

\begin{consolethree}[escapeinside=||]
double avg(int x[], int size)
{
    int s = 0;
    for (int i = 0; i < size; i++)
    {
        s += a[i];
    }
    return s / 3.0;
}

int main()
{
    int x[] = {1, 2, 3};
    std::cout << avg(x, |\EMPHASIZE{3}|) << std::endl;|\xsidebox[0cm]{0cm}{}{txt0}{BAD! Each usage of the old function must change.}|
    int y[] = {1, 2, 3, 4};
    std::cout << avg(y, 4) << std::endl;
    return 0;
}
\end{consolethree}

That's no big deal for a small program. But for a large program with thousands of lines or more, the change can be costly.

Here's another way to modify your \texttt{avg()} function without breaking existing usage:

\begin{consolethree}[escapeinside=||]
double avg(int x[], |\textbf{int size = 3}|)
{
    int s = 0;
    for (int i = 0; i < size; i++)
    {
        s += a[i];
    }
    return (double) s / size;
}

int main()
{
    int x[] = {1, 2, 3};
    std::cout << avg(x) << std::endl;
    int y[] = {1, 2, 3, 4};
    std::cout << avg(y, 4) << std::endl;
    return 0;
}
\end{consolethree}

Get the point?

One more example.

For some programs it is common to ``clip'' a value. For instance if you want a value to be positive, after calling the function with the value, the same value is returned if the value is positive. If the value is negative, 0 is returned.

\begin{itemize}
\item clip(5) returns 5
\item clip(-3.44) returns 0
\end{itemize}

In other words the statement \texttt{x = clip(x)} will ensure that
\texttt{x} is positive. Complete this program:

\begin{consolethree}[escapeinside=||]
double clip(double x)
{
    if (x >= 0)
        return x;
    else
        return 0;
}

int main()
{
    std::cout << clip(5.6) << std::endl   // 5.6
              << clip(0) << std::endl     // 0
              << clip(-1.23) << std::endl; // 0
    return 0;
}
\end{consolethree}

Now modify your clip so that it accepts a minimum clipping value. In other words, x = clip(x, 1) ensures that x is at least 1. Furthermore old test code must continue to work.

\begin{consolethree}[escapeinside=||]
double clip(double x, double min = 0)
{
    if (x >= min)
        return x;
    else
        return min;
}

int main()
{
    std::cout << clip(5.6) << std::endl      // 5.6
              << clip(0) << std::endl        // 0
              << clip(-1.23) << std::endl    // 0
              << clip(5, 1.2) << std::endl   // 5
              << clip(0.5, 1.2) << std::endl // 1.2
              << clip(-3, 1.2) << std::endl; // 1.2
    return 0;
}
\end{consolethree}

See the use of default values now?

Let's go one step further. Suppose the maximum possible value ever passed into the \texttt{clip()} function is 1e100 (mathematically speaking this is 1 x 10$^{100}$). Let's extend the \texttt{clip()} function to accept a maximum clip value.

\begin{consolethree}[escapeinside=||]
double clip(double x,
            double min = 0, double max = 1e100)
{
    if (x < min)
        return min;
    else if (x > max)
        return max;
    return x;
}

int main()
{
    std::cout << clip(5.6) << std::endl      // 5.6
              << clip(0) << std::endl        // 0
              << clip(-1.23) << std::endl    // 0
              << clip(5, 1.2) << std::endl   // 5
              << clip(0.5, 1.2) << std::endl // 1
              << clip(-3, 1.2) << std::endl  // 1
              << clip(3, 0, 5) << std::endl  // 3
              << clip(3, 4, 5) << std::endl  // 4
              << clip(3, 0, 1) << std::endl; // 1
    return 0;
}
\end{consolethree}

I hope it's clear that the graph of the clip(x, min, max) (for fixed min and max) function is this:

% \includegraphics[width=3.3335in,height=2.5in]{Pictures/1000000000000140000000F021743FC92E9323B2.png}

Such functions that ``squeeze'' a value to within a range is common in many applications. For instance there's the Sigmoid function. This is used in artificial intelligence in the study of artificial brain neurons. Maybe you will study that when you take CISS450 Artificial Intelligence.

\begin{ex}
Write a \texttt{randrange()} function that accepts integers a and b and returns a random integer n such that a <= n < b. Test your code with this:

\begin{consolethree}[escapeinside=||]
int randrange(int a, int b)
{
    ... CODE ...
}

int main()
{
    for (int i = 0; i < 10; i++)
    {
        std::cout << randrange(5, 15) << std::endl;
    }
    return 0;
}
\end{consolethree}

Now modify your program so that it accepts a \texttt{step} variable. For instance if you call randrange(5, 15, 2), an integer randomly chosen from 5, 7, 9, 11, and 13 is returned; if you call randrange(5, 15, 3), an integer randomly chosen from 5, 8, 11, and 14 is returned;
\end{ex}

\begin{ex}
You are a programmer for Wal-art (they sell art supplies ...). Your boss told you to write a function to compute weekly pay. Write a function \texttt{getSalary()} that accepts the number of hours (as a double) and computes the wage using this formula:

\begin{itemize}
\item For each hour up to 40 hours, the hourly rate is 7.20
\item For each overtime hour (i.e. beyond 40 hours), the hourly rate is 8.30.
\end{itemize}

Test your code with this \texttt{main()}

\begin{consolethree}[escapeinside=||]
double getSalary(int hours)
{
    ... CODE ...
}

int main()
{
    std::cout << getSalary(30) << std::endl;
    std::cout << getSalary(45.5) << std::endl;
    return 0;
}
\end{consolethree}

[... time passes ...nostalgic music ... scenes fade in and out ...]

It's been 6 months and your \texttt{getSalary()} function has been used extensively in the information system. Your boss told you that the higher-ups have decided to create 3 types of hourly wage workers. The previous computation for the salary refers to an hourly wage worker oftype 0. For type 1, the hourly wage is 8.50/hour for hours up to 40 hours/week and 9.30 for each hour after 40 hours. For employee of type 2, the hourly wage is 10.50/hour; overtime hourly rate is the same as the regular hourly rate.

Modify your \texttt{getSalary()} function so that previous usage is not broken. Test your code with this \texttt{main()}:

\begin{consolethree}[escapeinside=||]
// *** NEED TO CHANGE ***
double getSalary(int hours)
{
    ... OLD CODE ...
}

int main()
{
    std::cout << getSalary(30) << std::endl;
    std::cout << getSalary(45.5) << std::endl;
    std::cout << getSalary(45.5, 0) << std::endl;
    std::cout << getSalary(45.5, 1) << std::endl;
    std::cout << getSalary(45.5, 2) << std::endl;
    return 0;
}
\end{consolethree}
\end{ex}

Default values of basic types are all the same. However you cannot use default values for arrays in the ``obvious'' way:

\begin{consolethree}[escapeinside=||]
void f(int x[] = {1, 2, 3})
{
    ... code ...
}
\end{consolethree}

The program will not even compile. In other words, the \EMPHASIZE{array initializer list cannot be used as a default value}.


\newpage\EMPHASIZE{Prototypes for default values}

First try this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void printHeads(int = 1);

int main()
{
    printHeads();
    printHeads(42);
    return 0;
}

void printHeads(int numHeads = 1)
{
    std::cout << "number of heads: " << numHeads
              << std::endl;
}
\end{consolethree}

It does \EMPHASIZE{not} work. Remember that!!!

Now try this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void printHeads(int = 1);

int main()
{
    printHeads();
    printHeads(42);
    return 0;
}

void printHeads(int numHeads)
{
    std::cout << "number of heads: " << numHeads
              << std::endl;
}
\end{consolethree}

See the difference?

The \EMPHASIZE{default values appear only in the prototype if you want to have a prototype} and not in the function header when you define the function bodies.

(This is not arbitrary. There's a reason for this. But you would need to know how compilers work to understand why this is the case. So for now you just have to remember this fact.)

Of course if you don't have a prototype, then you can include the default value in the function header -- but NOT if you have a prototype.

That's the only gotcha you should remember. This is a very common mistake for beginners.


\newpage\EMPHASIZE{Multi-file compilation}

I have nothing to add here. Just remember that the \EMPHASIZE{default values appear only in the function prototypes}, not in the function headers when defining function bodies (see previous section) if you want to give that function a prototype. In other words, this \EMPHASIZE{does not work}:

\begin{consolethree}[escapeinside=||]
#include <iostream>
#include "test.h"

int main()
{
    printHeads();
    printHeads(42);
    return 0;
}
\end{consolethree}

\begin{consolethree}[escapeinside=||]
// test.h
#ifndef TEST_H
#define TEST_H

void printHeads(int numHeads = 1);

#endif
\end{consolethree}

\begin{consolethree}[escapeinside=||]
// test.cpp
#include <iostream>
#include "test.h"

void printHeads(int numHeads = 1)
{
    std::cout << "number of heads: " << numHeads
              << std::endl;
}
\end{consolethree}

Modify your test.cpp:

\begin{consolethree}[escapeinside=||]
// test.cpp
#include <iostream>
#include "test.h"

void printHeads(int numHeads)
{
    std::cout << "number of heads: " << numHeads
              << std::endl;
}
\end{consolethree}

and it works. Make sure you run this.

\begin{ex}
Identify all the errors in this header file:

\begin{consolethree}[escapeinside=||]
#ifndef BLAH_H
#define BLAH_H

int[] spam(int = 0, char, int[] = {2, 3, 5, 7},
           int a = 1, int b = 2, int c = a + b);

#end
\end{consolethree}

(There are 5).
\end{ex}


\newpage\EMPHASIZE{Default value for array parameter}

Recall that You cannot have default values for array parameters. For instance the following will not compile:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void print(int x[] = {2, 3})
{
    std::cout << x[0] << ' ' << x[1];
}

int main()
{
    print();
    return 0;
}
\end{consolethree}

There's an exception: \EMPHASIZE{The only exception is an array of characters.} In this case, \EMPHASIZE{your array parameter must be an array of constant characters}:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void printHello(|\EMPHASIZE{const}| char s[] = "world")
{
    std::cout << "hello " << s << std::endl;
}

int main()
{
    printHello();
    printHello("underverse");
    return 0;
}
\end{consolethree}

This means that in the \texttt{printHello()} function you cannot change the characters in parameter \texttt{s}.

\begin{ex}
Remove \texttt{const} from the above and try to compile.
\end{ex}

\begin{ex}
Write a function \texttt{print\_dollar\_amt()} such that

\begin{consolethree}[escapeinside=||]
print_dollar_amt(123);     // prints $1.23
print_dollar_amt(123, 45); // prints $123.45
\end{consolethree}
\end{ex}
