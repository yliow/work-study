\chapter{Booleans}
Objectives
\begin{tightlist}
\li Use boolean literals
\li Use boolean operators
\li Declare boolean variables
\li Declare and initialize boolean variables
\li Use assignment operator for boolean variables
\li Declaring constant boolean variables
\end{tightlist}

Boolean values represent \lq\lq true'' and \lq\lq false''. We'll see later that this type
is important for writing programs that can make decisions.
\newpage\section{Booleans}

An integer can be 5 or 42 or 1024. A double can be 2.141.\\\\

A \textbf{\EMPHASIZE{boolean}} value is either true or false. Boolean values are used by programs to make decisions (among other things). Up to this point our
programs can now accept input(s) and perform computations one
statement at a time.\\\\
THAT'S NOT GOOD ENOUGH!\\\\
Programs should be smart enough to decide which statement to execute.
If you're playing a game, you want the game to decide when to restart a
game right? You do want to gain extra points when you hit a rogue
spaceship, correct??? A program that analyzes the image file of a brain
scan should only print \lq\lq THERE'S BRAIN TUMOR!'' only when there's
really a brain tumor right?!?\\\\

All these and more require \textbf{\EMPHASIZE{decision-making.}} You want to write a program that says (more or less):\\
\begin{align*}
  \text{if rocket hits bad ship then}\\
& \text{bad ship explodes}\\
& \text{player gets 10 points}\\
\end{align*}
The condition
\begin{align*}
\text{rocket hits bad ship}\\
\end{align*}
is of course either true or false. That's the point of having booleans.\\\\
Another use of booleans is to decide/control when a \textbf{\EMPHASIZE{loop}} or \textbf{\EMPHASIZE{repetition}} should end. For instance, look at this “program” from a DVD player software:\\
\tab[3em]{\lq\lq continue playing the video stream and audio stream\\ as long as the STOP button is not pressed''}
or to make it more like a "program":\\
\tab[3em]{while STOP button is not pressed:}\\
\tab[6em]{play the next 0.01 second of video stream and the}\\
\tab[6em]{next 0.01 second of audio stream}\\\\
The condition \lq\lq STOP button is not pressed'' again is either true or false. It has a boolean value.\\\\
So \dots before we can talk about decision-making and (also known as
branching) and loops/repetition, you need to know how to work with booleans.\\\\
Whereas ints and doubles and floats can have lots of values, note that booleans only have \textbf{\EMPHASIZE{two}}: \verb!true! and \verb!false!\\\\

\textbf{Exercise.} Run this program.\\
\begin{console}
  std::cout << true << ' '
            << false << std::endl;
\end{console}
What does C++ display \EMPHASIZE{true} as? \underline{\mbox{}\hspace{1in}}\\
What does C++ display \EMPHASIZE{false} as? \underline{\mbox{}\hspace{1in}}

\textbf{\section{Boolean operators: and}}
Booleans, like \verb!ints! and \verb!doubles!, have operators. Just like + allows you
to combine two ints into one:\\

\tab[3em]{1 + 2}\\\\
(i.e. 3) boolean operators take boolean value(s) and return a boolean value. Why do you need them? Here's a simple example:

\tab[3em]{(I'm learning C++) and (I'm a student at CC)}

Is this true or false? Well this becomes:

\tab[3em]{(true) and (true)}

(Otherwise why are you here???) Of course you know that this is

\tab[3em]{true}

So what I'm saying is that the \textbf{\EMPHASIZE{{"and"}}} is a \textbf{\EMPHASIZE{{binary operator}}} that takes (true) and (true) and evalutes to (true). In a C++ program \lq\lq and'' is written

\tab[3em]{\&\&}

Too bad that's something you have to remember. \&\& is a \textbf{binary} boolean operator since you need to feed it two boolean values to get a result. (Instead of calling it the \lq\lq and'' operator, mathematicians/computer scientists call it the \lq\lq logical and'' operator.)

To define \lq\lq and'' you need to figure out all the possible cases:

\tab[3em]{true \&\& true = true}\\
\tab[3em]{true \&\& false = false}\\
\tab[3em]{false \&\& true = false}\\
\tab[3em]{false \&\& false = false}

This is called a \textbf{truth} table of \lq\lq and'' or \&\&. Make sure you can reproduce the above truth table!!!

\textbf{Exercise.} Verify the result of the \&\& operator by completing this program. Complete and run this program and make sure C++ is not crazy.

\begin{console}
  std::cout << "true && true = " << (true && false) << '\n'
            << "true && false = " << (true && false) << '\n'
            <<
            <<                                               ;
\end{console}

\textbf{Exercise.} By the way, what happens if you remove the parentheses?
%\newpage
i.e., what happens when you do this:\\
\begin{console}
  std::cout << true && true << '\n';
\end{console}
\textbf{Exercise.} What is the value of this boolean expression\\\\

\tab[3em]{\verb!false! \&\& \underline{\mbox{}\hspace{1in}}}

even though the second value is missing? This is the same for

\tab[3em]{\underline{\mbox{}\hspace{1in}} \&\& \verb!false!}

\newpage
\textbf{\section{Boolean operator: or}}
Another important boolean operator is \lq\lq or'' (or \lq\lq logical or''). Here's an example:

\tab[3em]{(I'm learning C++) or (I have 3 arms)}

Assuming you do not have three arms, the resulting boolean value is of course:

\tab[3em]{(true) or (false) = (true)}

In C++ \lq\lq or'' is written
%this needs to be corrected, not sure of how right now
\tab[12em]{\EMPHASIZE{\textbar\textbar}}

(two vertical broken lines – look at the left of the keyboard, above the backslash \ key on your keyboard).


\textbf{Exercise.} Of course we must have a truth table for \lq\lq or'':
Verify this table using a C++ program:
\tab[3em]{true $||$ true = true}
\tab[3em]{true $||$ false = true}
\tab[3em]{false $||$ true = true}
\tab[3em]{false $||$ false = false}
\begin{console}
  std::cout << "true || true = " << (true || true) << '\n'
            <<
            <<
            <<                                             ;
\end{console}

Same thing again ... make sure you can reproduce the above table.

\textbf{Exercise.} What is the value of this boolean expression

\tab[3em]{\verb!true! $||$ \underline{\mbox{}\hspace{1in}}}

  \text{even though the second value is missing? What about this:}
  
\tab[3em]{\underline{\mbox{}\hspace{1in}} $||$ \verb!true!}

At this point we have two boolean operators. What if we have a boolean expression like this:

\tab[3em]{\verb!false! \&\& \verb!false! $||$ \verb!true!}

Note that precedence is important since

(\verb!false! \&\& \verb!false!) $||$ \verb!true!

= \verb!false! $||$ \verb!true!

= \verb!true!

and

\verb!false! \&\& (\verb!false! $||$ \verb!true!)

= \verb!false! \&\& \verb!true!

= \verb!false!

which gives us different results!!!

The precedence rule is simple:
%ISSUE@@ || needs to be more similar to the original document
\tab[9em]{() highest priority}\\
\tab[9em]{\&\&}\\
\tab[9em]{\textbf{$|$ $|$} lowest priority}\\

and as usual for (boolean) operators of the same priority level, you perform left-to-right.

Let's evaluate this by hand:
%ISSUE@@ this might require a table, definitely a rewrite
\texttt{true} $||$ \texttt{false} \&\& \underline{(\texttt{false} $||$ \texttt{true})} \&\& \texttt{false}

= \texttt{true} $||$ \texttt{false} \&\& \underline{(\texttt{true})} \&\& \texttt{false} by \texttt{false} $||$ \texttt{true} = \texttt{true}

= \texttt{true} $||$ \underline{\texttt{false} \&\& \texttt{true}} \&\& \texttt{false}   by (\texttt{true}) = \texttt{true}

= \texttt{true} $||$ \underline{\texttt{false} \&\& \texttt{false}}           by \texttt{false} \&\& \texttt{true} =\texttt{false}

= \underline{\texttt{true} $||$ \texttt{false}}                    by \texttt{false} \&\& \texttt{false} =\texttt{false}

= \texttt{true}                             by \texttt{true} $||$ \texttt{false} = \texttt{true}

Now verify it with C++:
\begin{console}
std::cout << (true $||$ false && (false $||$ true) && false)
          << std::endl;
\end{console}

You should get 1 which means that boolean value is true.

\textbf{Exercise.} First evaluate this by hand:

\tab[3em]{(\verb!true! $||$ \verb!false!) \&\& \verb!false! $||$ \verb!true! \&\& \verb!false!}
  
Next verify it with C++:

\textbf{Exercise.} First evaluate this by hand:

\tab[3em]{(\verb!false! \&\& \verb!false!)! $||$ (\verb!false! $||$ \verb!true!) \&\& \verb!false!}

Next verify it with C++:

\textbf{Exercise.} Check that \&\& and $||$ are commutative, i.e. suppose x and y are boolean values, then

\tab[3em]{x \&\& y is the same as y \&\& x}

\tab[3em]{x $||$ y is the same as y $||$ x}

(Here's a memory aid: “I have three arms and I am the Queen of England” has the same boolean value as “I am the Queen of England and I have three arms”. That's pretty obvious, right?)

\textbf{Exercise.} Check that if x is a boolean value, then

\tab[3em]{x \&\& x is the same as x}

\tab[3em]{x $||$ x is the same as x}

(Here's a memory aid: “I have a space shuttle in my backyard and I have
a space shuttle in my backyard” is the same as “I have a space shuttle in
my backyard”. Also, “I have ten dollars or I have ten dollars” is the same
as “I have ten dollars”. Right?)

\EMPHASIZE{Boolean operator: not}

So far we have “and” (i.e. \&\& in C++-speak) and “or” (i.e. $||$ in C++-speak).

There's another operator called “not” (or “logical not”). In C++ it's written

\tab[15em]\EMPHASIZE{\textbf{!}}

This operator is \EMPHASIZE{unary} – it requires one value. It simply inverts the boolean value. You write the boolean value on the right-hand side of !. In
other words you write

\tab[3em]{\texttt{!true}}

and not

\tab[3em]{\texttt{true!}}

\textbf{Exercise.} Complete the following truth table

\tab[3em]{!true \tab[3em]{=}}\\
\tab[3em]{!false\tab[3em]{=}}

by completing and running this program:
\begin{console}
std::cout <<  “!true = ” << (!true) << '\n'
          <<                  << std::endl;
\end{console}

\textbf{Exercise.} Check that if x is a boolean value then

\tab[3em]{!!x   is the same as x}

[Memory aid: “It is not true that I am not tall” is the same as “I am tall”.]

Here the precedence rules for \&\&, $||$, and !:

\tab[3em]{() \tab[2em]{highest precedence level}}\\
\tab[3em]{!}\\
\tab[3em]{\&\&}\\
\tab[3em]{$||$ \tab[2em]{lowest precedence level}}\\

(Memory aid: remember unary operators always have higher priority.
This is the same for integer and floating point operators.)

\textbf{Exercise.} Evaluate this by hand:

\tab[3em]{\texttt{(true $||$ false) \&\& !false $||$ true \&\& !false}}

Now verify it with C++:


\textbf{Exercise.} Evaluate this by hand:

\tab[3em]{\texttt{!true \&\& !(false \&\& !false $||$ true) \&\& false}}

Now verify it with C++.

\EMPHASIZE{Other boolean operators}

So far the boolean operators take boolean values (true and false) and
returns a boolean value.

Now we want to think about those that take numeric values (ints,
doubles, floats) and spit out boolean values.

\textbf{Exercise.} Run this program
\begin{console}
std::cout << (1 < 2) << std::endl;
std::cout << (1 > 2) << std::endl;
std::cout << (4 < 3) << std::endl;
std::cout << (4 > 3) << std::endl;
std::cout << (5 <= 8) << std::endl;
std::cout << (5 >= 8) << std::endl;
std::cout << (24 == 42) << std::endl;
std::cout << (24 != 42) << std::endl;
\end{console}
Of course you know

\tab[3em]{$<$    \tab[2em]{less than}}\\
\tab[3em]{$>$    \tab[2em]{greater than}}\\

and you can easily guess

\tab[3em]{$<=$    \tab[2em]{less than or equal to}}\\
\tab[3em]{$>=$    \tab[2em]{greater than or equal to}}

It's probably harder to guess that

\tab[3em]{$==$    \tab[2em]{is equal to}}\\
\tab[3em]{$!=$    \tab[2em]{is not equal to}}

By the way $<=$ and $>=$ CANNOT be written as

\tab[3em]{$=<$    \tab[2em]{BAD, BAD, BAD!!!}}\\
\tab[3em]{$=>$    \tab[2em]{BAD, BAD, BAD!!!}}

\textbf{Exercise.} Run this program.
\begin{console}
std::cout << (5 < = 8) << std::endl;
std::cout << (5 > = 8) << std::endl;
std::cout << (24 = = 42) << std::endl;
std::cout << (24 =! 42) << std::endl;
std::cout << (24 => 42) << std::endl;
\end{console}
What's wrong? Fix it!!!


It's not too surprising that the above boolean operators ($<, <=, >, >=, ==, !=$) work for doubles too. Yes?

\textbf{Exercise.} Check your instructor was not lying by running this program:
\begin{console}
std::cout << (1.1 < 2.2) << std::endl;
std::cout << (1.1 > 2.2) << std::endl;
std::cout << (4.4 < 3.3) << std::endl;
std::cout << (4.4 > 3.3) << std::endl;
std::cout << (5.5 <= 8.8) << std::endl;
std::cout << (5.5 >= 8.8) << std::endl;
std::cout << (24.24 == 42.42) << std::endl;
std::cout << (24.24 != 42.42) << std::endl;
\end{console}

\EMPHASIZE{Associativity and precedence rules}

What happens when you want C++ to evaluate a boolean expression like
this:
\tab[3em]{x + y $<$ a * b $-$ c}

where x, y, a, b and c are (say) integer variables? C++ must of course
work on one operator at a time. In general, the numeric operators go first.
In other words the +, *, - in the above expression goes before $<$.
In general the precedence rules now look like this:

\tab[3em]{*,/,\%,+,- (binary and unary)}\\
\tab[3em]{$<, <=, >, >=, !=, ==$}

The ! Is slightly special. It's unary. So the precedence is pretty high.

Specifically we have

\tab[3em]{+, - (unary) \tab[2em]{highest precedence level}}\\
\tab[3em]{!}\\
\tab[3em]{*, /, \%}\\
\tab[3em]{+,- (binary)}\\
\tab[3em]{$<, <=, >, >=$}\\
\tab[3em]{$==, !=$}\\
\tab[3em]{\&\&}\\
\tab[3em]{$\mathbf{||}$ \tab[2em]{lowest precedence level}}\\

By the way = is also an operator – the assignment operator. It's not too
surprising that for the following expression:

\tab[3em]{x = a + b - c}

= is the last thing to happen (see previous notes). In fact = is the last in
the precedence rules:

\tab[3em]{+, - (unary) 
\tab[3em]{!}\\
\tab[3em]{*, /, \%}\\
\tab[3em]{+, - (binary)}\\
\tab[3em]{$<, <=, >, >=$}\\
\tab[3em]{$==, !=$}\\
\tab[3em]{\&\&}\\
\tab[3em]{$\mathbf{||}$}\\
\tab[3em]{= \tab[2em]{lowest precedence level}}

The associativity rules are what you expect.

\tab[3em]{a $<=$ b $<=$ c \tab[1em]{is the same as (a $<=$ b) $<=$ c}}

(This actually causes a very common error ... see next section for a
VERY IMPORTANT gotcha) and

\tab[3em]{!!!(1 == 2) \tab[1em]{is the same as !(!(!(1 == 2)))}}

So there's nothing much to remember.

Let's try to compute the boolean value of

\tab[3em]{3 $<$ 2 * 3 \&\& 9 / 2 $<$ 6 * 3}

Here we go:
%ISSUE@@
\tab[3em]{3 $<$ 2 + 3 \&\& \underline{9 / 2} $<$ 6 * 3}\\
\tab[3em]{3 $<$ 2 + 3 \&\&
\tab[3em]{3 $<$ 2 + 3 \&\&
\tab[3em]{\underline{3 $<$ 5} \&\& 4 < 18}
\tab[3em]{\texttt{true} \&\& \underline{4 $<$ 18}
\tab[3em]{\texttt{true} \&\& \texttt{true}
\tab[3em]{\texttt{true}}

\begin{console}
std::cout << (3 $<$ 2 + 3 && 9 / 2 $<$ 6 * 3) << '\n';
\end{console}

\textbf{Exercise.} Evaluate

\tab[1em]{1 + 2 $<$ 2 * 2 \&\& 3 – 1 $<$ 5 – 2 $||$ 5 * 2 $<$ 6 * 3}

and verify with C++.

\textbf{Exercise.} Evaluate

\tab[1em]{6 * 2 $<$ 2 + 6 \&\& (3 – 1 $<$ 5 – 2 $||$ 5 * 2 $<$ 6 * 3)}

and verify with C++.

\textbf{Exercise.} Evaluate

\tab[1em]{6 * 2 $<$ 8 \&\& (2 $>=$ 5 – 3 $||$ (2 $!=$ 6 * 3 $||$ 3 $<$ 4))}

and verify with C++.

\EMPHASIZE{Gotcha}


%each very is larger than the last and 'common gotcha' is the same size as the first 'very'
Here's a \EMPHASIZE{very very very common gotcha} that unfortunately even experienced programmers make. Look at this:

This seems to be similar to the following in math:

\tab[12em]{-3 $<=$ -2 $<=$ -1}

and in math

\tab[12em]{-3 $\leq$ -2 $\leq$ -1}

Is true, right? Try this:
\begin{console}
std::cout << (-3 <= -2 <= -1) << std::endl;
\end{console}

The output is 0!!! Which means false!!! Whoa ... what's happening?!?
Let's evaluate this the way C++ would::

\tab[9em]{-3 $<=$ -2 $<=$ -1}

is the same as

\tab[9em]{(-3 $<=$ -2) $<=$ -1}

Now

\tab[9em]{-3 $<=$ -2 is true}

That means that

\tab[3em]{-3 $<=$ -2 $<=$ -1}\\
\tab[3em]{= (-3 $<=$ -2) $<=$ -1}\\
\tab[3em]{= true $<=$ -1}

Here lies the problem. This is a comparison between a boolean and an
integer. C++ type cast the boolean true to 1:

\tab[3em]{-3 $<=$ -2 $<=$ -1}\\
\tab[3em]{= (-3 $<=$ -2) $<=$ -1}\\
\tab[3em]{= true $<=$ -1}\\
\tab[3em]{= 1 $<=$ -1}

and of course 1 $<=$ -1 is false

\tab[3em]{-3 $<=$ -2 $<=$ -1}\\
\tab[3em]{= (-3 $<=$ -2) $<=$ -1}\\
\tab[3em]{= true $<=$ -1}\\
\tab[3em]{= 1 $<=$ -1}

So how do we fix it? Well \underline{\textit{\textbf{mathematically}}}

\tab[15em]{-3 $\leq$ -2 $\leq$ -1}

actually means

\tab[12em]{“-3 $\leq$ -2 and -2 $\leq$ -1”}

Try this:
\begin{console}
std::cout << ((-3 <= -2) && (-2 <= -1)) << '\n';
\end{console}

So if you want to (mathematically) say
\[
\text{a $\leq$ b $\leq$ c}
\]
then in C++ you want to say
\[
\text{a $<=$ b \&\& b $<=$ c}
\]
Likewise the C++ expression for the mathematical expression:
\[
\text{a $<$ b $<$ c}
\]
is
\[
\text{a $<$ b \&\& b $<$ c}
\]

Don't say I didn't warn you.


\EMPHASIZE{Boolean variables}

The C++ name for the boolean type is \verb!bool!.

Declaring boolean variables is easy. Try this program:
\begin{console}
bool earthIsFlat = false;
std::cout << "earth is flat: " << earthIsFlat
          << std::endl;
\end{console}

\textbf{Exercise.} Declare a boolean variable totallyBroke and initialize it
with the “and” of the all the three variables in the following code segment.
Print the values of all the variables.

\begin{console}
bool noSavings = true;
bool noInheritance = true;
bool noJob = true;


\end{console}

Of course you can use an expression that evaluates to a boolean value:
\begin{console}
int a = 42;
int b = 24;
bool x = (a == b);
std::cout << x << std::endl;
bool y = (b < a && b + 5 < a);
std::cout << y << std::endl;
\end{console}

\textbf{Exercise.} Suppose you're given an integer variable x. Write down the a boolean expression that is true exactly when x is greater than 1 and less than 10. Test your code with x = 0, 1, 5, 10, 20.
\begin{console}
int x;
std::cin >> x;
bool b = _______________________________;
std::cout << b << std::endl;
\end{console}

\textbf{Exercise.} Write a program that prompts the user for the following values:\\
\begin{tightlist}
\li amount in the user's savings account
\li monthly rent
\li daily expenses
\li number of days in the current month
\end{tightlist}\\
(choose appropriate names and types). Next declare a boolean variable
\verb!callHomeForCash! and set it to true exactly when the amount in the
user's savings account is less than the total expenses for the current
month. Print all the values.


\textbf{Exercise.} Verify that you can declare boolean constants.\\
\EMPHASIZE{Boolean input (console window)}


You can input boolean values from the keyboard in a console application.
However you do not enter true or false. You enter 1 for true and 0 for
false. Try this:\\
\begin{console}
bool b;
std::cin >> b;
std::cout << b << std::endl;
\end{console}
\textbf{Exercise.} Run your above program again. This time enter integer 5. Next try integer 42. Hmmmm. What's happening?

\textbf{Exercise.} You are commissioned to write a software for Bowing's new
plane. The software takes the following as input:
\begin{tightlist}
\li distance to nearest airport (mile)
\li amount of fuel left (gallons)
\li mileage (miles per gallon with only one pilot)
\li number of passengers (excluding pilot)
\li average weight of each passenger (in lbs, excluding pilot)
\li thunderstorm in flight path to nearest airport
\end{tightlist}\\
(choose appropriate names and types). With passengers, the mileage
decreases by 1/100 of the total weight of the passengers (excluding the
pilot). For instance if the mileage is 1000 miles/gallon, then with an extra
passenger weight of 200lbs, the mileage becomes 1000/(200/100).
Furthermore, if there is indeed a thunderstorm in the path towards the
nearest airport, the mileage drops by a factor of 3. For instance if the
mileage (after taking into account the extra passenger weight) is 300
miles per gallon, then with the presence of a thunderstorm in the path,
the mileage becomes 300/3. Finally declare a boolean variable
\verb!canMakeIt! and set it to true exactly when the plane can arrive at the
nearest airport. Write a program to prompts the user for all the above
data and print \verb!canMakeIt!.

\EMPHASIZE{Some simplification tricks}

Here's a summary of some simplification rules for ! where x and y are
numeric (either \verb!ints! or \verb!doubles! or \verb!floats!):

%ISSUE@@ need to fix this, collapsing the spaces 
\begin{center}
\[\text{!(x == y)   same as    x != y}\]
\[\text{!(x != y)   same as    x == y}\]
\[\text{!(x $<$ y)    same as    x $>=$ y}\]
\[\text{!(x $<=$ y)   same as    x $>$ y}\]
\[\text{!(x $>$ y)   same as    x $<=$ y}\]
\[\text{!(x $>=$ y)   same as    x $<$ y}\]  
\end{center}

\textbf{Exercise.} Simplify

\tab[3em]{!(a + b $>$ c + d + e)}

Using a C++ program, check that your new expression has the same
boolean value as the original expression above.

\EMPHASIZE{Decision trees}

You must have seen something like this before. Suppose you go to a
restaurant and you were told that there are two entrees: barbecue
chicken (BC) and grilled fish (GF) and there are two desserts: ice cream
(IC) or carrot cake (CC). This is the decision tree of all possible meals:

\begin{tikzpicture}
  [
    node distance=3cm and 0.5cm,
    every node/.style=
    {
      rectangle,
      draw,
      minimum width=0.1cm,
      minimum height=1cm,
      align=right,
      inner sep=3pt
    },
    every edge/.style={draw,->,>=stealth},
    edge label/.style={midway,font=\small,draw=none,fill=none,inner sep=3pt}
  ]

\node (A) {choose entree};
\node [below left=of A] (B) {choose dessert};
\node [below right=of A] (C) {choose dessert};
\node [below left=of B] (D) {BC, IC};
\node [below right=of B, xshift=-5mm] (E) {BC, CC};
\node [below left=of C, xshift=5mm] (F) {GF, IC};
\node [below right=of C] (G) {GF, CC};

\draw (A) edge node[edge label, above left] {entree=BC} (B);
\draw (A) edge node[edge label, above right] {entree=GF} (C);
\draw (B) edge node[edge label, left] {dessert=IC} (D);
\draw (B) edge node[edge label, right] {dessert=CC} (E);
\draw (C) edge node[edge label, left] {dessert=IC} (F);
\draw (C) edge node[edge label, right] {dessert=CC} (G);
\end{tikzpicture}

This diagram lists the consequence of decisions. For instance if you
choose BC for entree and IC for dessert, the consequence (see lower left
of the above diagram) is that you have a meal of

\tab[3em]{BC, IC}

At each point, there are several options. Etc. This is sometimes called a
decision tree. Decision trees might also contain information such as cost
benefit, risk analysis, etc.

For me, I'll use this to show you what happens when you have a
complex boolean expression. Here we go.

Suppose you're given integer variables x and y. Write down a boolean
expression that is true exactly when the following is true:

\begin{tightlist}
\li If x is greater than 1, then y must be less than 10
\li If x is less than or equal to 1, then y must be 42.
\end{tightlist}

Here are all the possible cases:

\begin{tikzpicture}
  [
    node distance=2.3cm and 2.5cm,
    invisible/.style=
    {
      inner sep=0pt,
      outer sep=0pt,
      align=right,
      text opacity=1,
      draw=none,
      fill=none,
      minimum size=0pt
    },
    leaf node/.style=
    {
      rectangle,
      draw,
      minimum width=1cm,
      minimum height=1cm,
      font=\small
    }
    every edge/.style={draw,->,>=stealth},
    edge label/.style={midway,font=\small,draw=none,fill=none,inner sep=5pt}
  ]

\node [invisible](A){};
\node [invisible, below left=of A] (B){};
\node [invisible, below right=of A] (C){};
\node [below left=of B] (D) {\texttt{true}};
\node [below right=of B, xshift=-20mm] (E) {\texttt{false}};%
\node [below left=of C, xshift=20mm] (F) {\texttt{true}};
\node [below right=of C] (G) {\texttt{false}};
\draw (A) edge node[edge label, above left] {$x > 1$} (B);
\draw (A) edge node[edge label, above right] {$x <= 1$} (C);
\draw (B) edge node[edge label, left] {$y < 10$} (D);
\draw (B) edge node[edge label, right] {$y >= 10$} (E);
\draw (C) edge node[edge label, left] {$y == 42$} (F);
\draw (C) edge node[edge label, right] {$y != 42$} (G);
\end{tikzpicture}

The boolean expression we want is one that will take us from the top to
the bottom with a value of true. There are of course two paths:

%tree here
\begin{tikzpicture}
  [
    node distance=2.3cm and 2.5cm,
    invisible/.style=
    {
      inner sep=0pt,
      outer sep=0pt,
      align=right,
      text opacity=1,
      draw=none,
      fill=none,
      minimum size=0pt
    },
    leaf node/.style=
    {
      rectangle,
      draw,
      minimum width=1cm,
      minimum height=1cm,
      font=\small
    }
    every edge/.style={draw,->,>=stealth},
    edge label/.style={midway,font=\small,draw=none,fill=none,inner sep=5pt},
    bold edge/.style={ultra thick, midway,font=\small,draw=none,fill=none,inner sep=5pt} 
  ]
\node [invisible](A){};
\node [invisible, below left=of A] (B){};
\node [invisible, below right=of A] (C){};
\node [below left=of B] (D) {\texttt{true}};
\node [below right=of B, xshift=-20mm] (E) {\texttt{false}};
\node [below left=of C, xshift=20mm] (F) {\texttt{true}};
\node [below right=of C] (G) {\texttt{false}};
\draw[bold edge] (A) edge node[edge label, above left] {$x > 1$} (B);
\draw[bold edge] (A) edge node[edge label, above right] {$x <= 1$} (C);
\draw[bold edge] (B) edge node[edge label, left] {$y < 10$} (D);
\draw (B) edge node[edge label, right] {$y >= 10$} (E);
\draw[bold edge] (C) edge node[edge label, left] {$y == 42$} (F);
\draw (C) edge node[edge label, right] {$y != 42$} (G);
\end{tikzpicture}

i.e., either the take the path where x $>$ 1 and y $<$ 10 or you take the path
where x $<=$ 1 and y == 42.

The boolean expression that guarantees a true value is then

\tab[3em]{(x $>$ 1 \&\& y $<$ 10) || (x $<=$ 1 \&\& y == 42)}

Ignore the boolean expression for now and look at the original
requirement:

“Write down the a boolean expression that is true exactly when the
following is true:
\begin{tightlist}
\li If x is greater than 1, then y must be less than 10
\li If x is less than or equal to 1, then y must be 42.”
\end{tightlist}

What will you get if x = 0 and y = 0? Since x = 0, you should look at the
second case:

“Write down the a boolean expression that is true exactly when the
following is true:
\begin{tightlist}
\li If x is greater than 1, then y must be less than 10
\li \textbf{If x is less than or equal to 1, then y must be 42.}”
\end{tightlist}

In this case, your boolean expression must be true exactly when y is 42.
But our y is 0. So we must have a false value. Now let's check our
boolean expression and see if we do get a false value. Substituting x = 0
and y = 0 into:

\[\text{(x $>$ 1 \&\& y $<$ 10) $||$ (x $<=$ 1 \&\& y == 42)}\]

we get

\[\text{(0 $>$ 1 \&\& 0 $<$ 10) $||$ (0 $<=$ 1 \&\& 0 == 42)}\]

Now let's compute the boolean value of this expression:
\[\text{(0 $>$ 1 \&\& 0 $<$ 10) $||$ (0 $<=$ 1 \&\& 0 == 42)}\]
\[\text{= (false \&\& true ) $||$ ( true \&\& false )}\]
\[\text{= (false) $||$ (false)}\]
\[\text{= false}\]

Voila! Our boolean expression is correct in this case.

\textbf{Exercise.} Let's check one more case.
(a) From the requirements, what is the expected boolean value when x = 10 and y = 10?\\
(b) What is the boolean value of our boolean expression

\[\text{(x $>$ 1 \&\& y $<$ 10) || (x $<=$ 1 \&\& y == 42)}\]

when x=10 and y=10?\\
(c) Does (a) match (b)?

\textbf{Exercise.} One more check \dots
(a) From the requirements, what is the expected boolean value when x =
1 and y = -5?\\

(b) What is the boolean value of our boolean expression

\[\text{(x $>$ 1 \&\& y $<$ 10) $||$ (x $<=$ 1 \&\& y == 42)}\]

when x = 1 and y = -5?\\
(c) Does (a) match (b)?


\textbf{Exercise.} To speed up the verification process you can write a code to evaluate the boolean expression:
\begin{console}
int x, y;
std::cin >> x >> y;
bool b = (x > 1 && y < 10) || (x <= 1 && y == 42);
std::cout << b << std::endl;
\end{console}

When you're testing your boolean expression, you SHOULD test all
possible branches of the decision tree:

\begin{tikzpicture}
  [
    node distance=2.3cm and 2.5cm,
    invisible/.style=
    {
      inner sep=0pt,
      outer sep=0pt,
      align=right,
      text opacity=1,
      draw=none,
      fill=none,
      minimum size=0pt
    },
    leaf node/.style=
    {
      rectangle,
      draw,
      minimum width=1cm,
      minimum height=1cm,
      font=\small
    }
    every edge/.style={draw,->,>=stealth},
    edge label/.style={midway,font=\small,draw=none,fill=none,inner sep=5pt}
  ]

\node [invisible](A){};
\node [invisible, below left=of A] (B){};
\node [invisible, below right=of A] (C){};
\node [below left=of B] (D) {\texttt{true}};
\node [below right=of B, xshift=-20mm] (E) {\texttt{false}};
\node [below left=of C, xshift=20mm] (F) {\texttt{true}};
\node [below right=of C] (G) {\texttt{false}};
\draw (A) edge node[edge label, above left] {$x > 1$} (B);
\draw (A) edge node[edge label, above right] {$x <= 1$} (C);
\draw (B) edge node[edge label, left] {$y < 10$} (D);
\draw (B) edge node[edge label, right] {$y >= 10$} (E);
\draw (C) edge node[edge label, left] {$y == 42$} (F);
\draw (C) edge node[edge label, right] {$y != 42$} (G);
\end{tikzpicture}

In other words your test cases must run through all the four possible
paths from the top to the bottom. For instance here are 4 cases:

\begin{tightlist}
\li x = 2, y = 0
\li x = 10, y = 10
\li x = 0, y = 42
\li x = -1, y = 10
\end{tightlist}

In fact, in testing boolean expressions (or testing software in general),
you should also test near boundary cases. For instance, in the above,
when x $>$ 1, the value y = 10 is the boundary case. So it is advisable for x
= 10, one should test the cases y = 9, y = 10, y = 11. For the case when
x $<=$ 1, the boundary case is at y = 42. So it makes sense to test y = 41,
42, 43. In fact at the higher level, x has a boundary case of x = 1. So it's
also advisable to test x = -1, x = 0, x = 1.


\textbf{Exercise.} Suppose you're given integer variables x and y. Write a
boolean expression that is true exactly when the following is true:
\begin{tightlist}
\li If x is even, then y is less than 10
\li If x is odd, then y is greater than 20
\end{tightlist}
Test your boolean expression thoroughly.

\textbf{Exercise.} Suppose you're writing a computer game and you have the
following variables.

\begin{tabular}{p{4cm} p{2cm} p{5cm}}
  fuel\_level & int & The amount of fuel left, ranges from 0 to 1000.\\

  & &\\ 
  
  shield\_energy & int & Range from 0 to 3.\\

  & &\\ 
  
  laser\_pod\_energy & double & Ranges from 0.0 to 1.0. The player can fire the laser only when this is 1.0, i.e., when the laser pod is fully charged.\\

  num\_laser\_collides & int & Number of enemy laser that collides with your ship.\\

  num\_asteroid\_collides & int & Number of asteroids that collides with your ship\\  
\end{tabular}

(You of course do not need to know how values are assigned to these
variables. Just assume that they have the right values.) Write a boolean
expression that tells us if the game should continue. The game should
continue exactly when the following is true:

Your fuel level is greater than 0 and furthermore one of the following is
true.
\begin{tightlist}
\li If your shield energy is 0: the number of lasers and asteroids that collides with you is 0.
\li If your shield energy is 1: the number of lasers is at most 1 and no asteroid has collided with you.
\li If your shield energy is 2: the number of lasers is at most 5 and the number of asteroid that is in collision with you is at most 2.
\li Your shield energy is 3.
\end{tightlist}

\newpage\EMPHASIZE{de Morgan's laws}

Look at this statement. John said to Mary:

\[\text{“I'm not stupid and I'm not ugly!!!”}\]

What about this. John said

\[\text{“It's not true that I'm either stupid or ugly!!!”}\]

Note that they both mean the same thing. In other words if b and c are
boolean values, then

\[\text{(!b) \&\& (!c)}\]

is the same as

\[\text{!(b $||$ c)}\]

The two facts:

\begin{tabular}{p{3cm} p{3cm} p{3cm}}
(!b) \&\& (!c) & is the same as & !(b \&\& c)\\
(!b) $||$ (!c) & is the same as & !(b $||$ c)\\
\end{tabular}

are called \EMPHASIZE{de Morgan's laws.}

Why are these formula helpful? Here's one use of de Morgan's Laws to
simplify a boolean expression:

\[\text{!(x $<$ 0 $||$ x $>$ 5) = !(x $<$ 0) \&\& !(x $>$ 5)}\]

Now note that !(x $<$ 0) is the same as x $>=$ 0. Right? Also, !(x $>$ 5) is the same as x $<=$ 5. So

\[\text{!(x $<$ 0 $||$ x $>$ 5) =! (x $<$ 0) \&\& !(x $>$ 5)}\]
\[ \tab[3em]{\text{= (x $>=$ 0) \&\& (x $<=$ 5)}}\]

Note that the final boolean expression does not have the ! operator.
Altogether

\begin{tabular}{p{5cm} p{5cm}}
!(x $<$ 0 $||$ x $>$ 5) & uses 4 operators\\
(x $>=$ 0) \&\& (x $<=$ 5) & uses 3 operators\\
\end{tabular}

Get it?

\textbf{Exercise.} Using de Morgan's law, simplify this expression:

\[\text{!(x $<$ y + z \&\& y – z == x)}\]

\textbf{Exercise.} Using de Morgan's law, simplify this expression:

\[\text{!(x $<$ y + z $||$ y != x + y \&\& y – z == x)}\]

\textbf{Exercise.} Using de Morgan's law, simplify this expression:

\[\text{!((x < y + z $||$ y != x + y) \&\& y – z == x)}\]

Write a simple C++ program to verify your simplification.

\textbf{Exercise.} Simplify this expression:

\[\text{!((x $<$ y * z $||$ y \% 3 $<$ 1) \&\& y $>=$ x + 1)}\]

(All variables are integer variables with positive values.) Write a simple
C++ program to verify your simplification.

\newpage\EMPHASIZE{An easy simplification}

Here's something you should know: If x is a boolean variable. Then

\tab[3em]{x}

and

\tab[3em]{x == true}

have the same boolean value. That's not too surprising since the
following pairs of statements are the same:

\begin{tabular}{p{5cm} p{7cm}}
“I'm broke.” & “It is true that I'm broke.”\\
“I'm ten feet tall.” & “It is true that I'm ten feet tall.”\\
“I have a pet tiger.” & “It is true that I have a pet tiger.”\\
\end{tabular}

Right?

Let me try to prove that. There are only two possible values for x: it's
either \verb!true! or \verb!false!.

CASE: x is \verb!true!. In that case

\tab[3em]{x == \verb!true!}\\
\tab[3em]{= \verb!true! == \verb!true!}\\
\tab[3em]{= \verb!true!}\\

which is the value of x.
CASE: x is false. In that case

\tab[3em]{x == \texttt{true}}
\tab[3em]{= \texttt{false} == \texttt{true}}
\tab[3em]{= \texttt{false}}

which is, again, the value of x.

So in all cases,

\tab[3em]{x}

and

\tab[3em]{x == \texttt{true}}

have the same boolean value.

Similarly

\tab[3em]{!x}

and

\tab[3em]{x == \texttt{false}}

have the same boolean value

\textbf{Exercise.} Here's a boolean expression for “It is true that the earth is flat, it is true that the speed of light is greater than 180000 miles/second, it is true that I have a pet tiger, and it is false that I cannot tie shoelaces.”:


\tab[3em]{(\texttt{earth\_is\_flat} == \texttt{true})}\\
\tab[3em]{\&\& ((\texttt{LIGHT\_SPEED} $>$ 180000) == \texttt{true})}\\
\tab[3em]{\&\& (\texttt{have\_pet\_tiger} == \texttt{true})}\\
\tab[3em]{\&\& (\texttt{cannot\_tie\_shoelaces} == \texttt{false})}\\


Simplify it (so that == does not appear in your simplified expression.)
Test it with a C++ program.

\newpage\EMPHASIZE{Summary}

The boolean type has two values: true and false. The C++ name of the boolean type is \verb!bool!.

C++ supports the following operators for boolean values:

\begin{tabular}{p{1cm} p{3cm}}
  \&\& & (logical) and\\
  $||$ & (logical) or\\
  ! & (logical) not\\
\end{tabular}
  
They are defined by the following truth tables:
%% \begin{verbatim}
%% true && true  = true
%% true && false = false
%% false && true = false
%% false && false = false

%% true || true  = true
%% true || false = true
%% false || true = true
%% false || false = false

%% !true  = false
%% !false = true
%% \end{verbatim}

\begin{center}
\verb!true! \&\& \verb!true!  = \verb!true!
\verb!true! \&\& \verb!false!  = \verb!false!
\verb!false! \&\& \verb!true!  = \verb!false!
\verb!false! \&\& \verb!false!  = \verb!false!

\verb!true! || \verb!true!  = \verb!true!
\verb!true! || \verb!false!  = \verb!true!
\verb!false! || \verb!true!  = \verb!true!
\verb!false! || \verb!false!  = \verb!false!

!\verb!true!  = \verb!false!
!\verb!false!  = \verb!true!
\end{center}

C++ supports the following binary boolean operators that accept numeric
values (integer or floating point types):

\begin{center}
  $<$   less than\\
  $<=$  less than or equal to\\
  $>$   greater than\\
  $>=$  greater than or equal to\\
  $==$  equal to\\
  $!=$  not equal to\\
\end{center}

The following gives the precedence rules for a boolean expression
containing the following operators:

\tab[3em]{+, - (unary) 
\tab[3em]{!}\\
\tab[3em]{*, /, \%}\\
\tab[3em]{+, - (binary)}\\
\tab[3em]{$<, <=, >, >=$}\\
\tab[3em]{$==, !=$}\\
\tab[3em]{\&\&}\\
\tab[3em]{$\mathbf{||}$ \tab[2em]{lowest precedence level}}\\

%% \begin{center}
%%   +, - (unary) \tab highest precedence level\\
%%   !\\
%%   *, /, \%\\
%%   +, - (binary)\\
%%   $<, <=, >, >=$\\
%%   $==, !=$\\
%%   \&\&\\
%%   $||$           \tab lowest precedence level\\
%% \end{center}
There is an automatic type casting between numeric types (integers and
floating point types) and boolean values. Zero is type casted to false and
vice versa. Nonzero values are typecasted to true.

\newpage\EMPHASIZE{Exercises}

\textbf{Q1.} Evaluate the following boolean expression or indicate the error:

\[1 + 2 < 2 * 2 \&\& 3 – 1 < 4 – 2 || 5 * 2 < 6 * 3\]

\textbf{Q2.} Evaluate the following boolean expression or indicate the error:

\[5 + 2 < 2 * 1 \&\& (3 / 2 < 4 \% 2 || 3 * 2 < 6 \% 4) || 3 + 3 < 5 / 3\]

\textbf{Q3.} The following declares a boolean variable that is true when z is smaller than both x, y, i.e., What's wrong with this:

\begin{console}
int x = 42;
int y = 24;
int z = 10;
bool zSmallest = (z < x && y);
\end{console}

\textbf{Q4.} You're writing software for Dr Badadviz. After 20 years of research he found that a couple is compatible if the sum of their salaries (in pennies) when dividing by the sum of the weight (in lbs) is less than the number of fingers they have. Help Dr Badaviz write a program that prompts the user for the above, sets a boolean value compatible to true exactly when the couple is compatible.

\textbf{Q5.} In order to join the "Foo CEO Club", you need to have \$1000000 in personal assets, is or has been a CEO of at least 3 companies, and the sum of your height in ft and weight in lbs must be at most 300, and finally either you have at least 5 houses or at least 2 jets. Write a program that prompts the user for the above relevant information and sets a boolean variable to true exactly when the user is eligible for membership; print the value of this variable. Before you begin, here's a test case.

\begin{center}
Test case:\\
assets = 2000000\\
companies = 5\\
height = 6\\
weight = 200\\
houses = 4\\
jet = 0\\
result = NOT ELIGIBLE\\
\end{center}
