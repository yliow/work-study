\newpage\EMPHASIZE{72. Class Templates}

\textsc{Objectives}

\begin{itemize}
\item
  Write class templates
\item
  Instantiate classes from class templates
\end{itemize}

The problem

What if we want to have a class where the only instance variable is an integer, and then we want another where the only instance variable is a character?

They both have the same kind of ``behavior''. The constructor sets the
value of the instance variable and there are get and set methods. Here's
an example. Make sure you run it.

\begin{console}
class Int
{
public:
     Int(int x0)
         : x(x0)
     {}
     int get() const { return x; }
     void set(int x0) { x_ = x0; }
private:
     int x;
};

class Char
{
public:
     Char(char x0): x(x0) {}
     char get() const { return x; }
     void set(char x0) { x = x0; }
private:
     char x;

}; 
\end{console}

The test code is:

\begin{console}
int main()
{   
    Int d(5);
    Char e(' a');
    std::cout << d.get() << ' '
              << e.get() << '\n';
    return 0;
} 
\end{console}

Note that the two classes are very similar. In fact, within the class
the only difference is the type associated with the instance variable.

\begin{consolethree}[escapeinside=||]
class Int
{
public:
     Int(|\EMPHASIZE{int}| x0)
           : x(x0)
     {}
     |\EMPHASIZE{int}| get() const { return x; }
     void set(|\EMPHASIZE{int}| x0) { x_ = x0; }
private:
     |\EMPHASIZE{int}| x;
};

class Char
{
public:
     Char(|\EMPHASIZE{char}| x0): x(x0) {}
     |\EMPHASIZE{char}| get() const { return x; }
     void set(\EMPHASIZE{char} x0) { x = x0; }
private:
     |\EMPHASIZE{char}| x;

}; 
\end{consolethree}

What a pain to type two chunks of code which are almost the same. It's
like typing unrolled for-loops!

\newpage\EMPHASIZE{Class templates}

Now we allow types to vary.

Generic Programming refers to the style of programming using parameters
for types.

\begin{consolethree}[escapeinside=||]
template < typename T >
class D {|\sidebox{typearg}{\textbf{D is called a class template.\\ T is a \EMPHASIZE{type argument}}}|
public:
     D(){}
     D(T c) : x(c) {}
     T get() const { return x; }
     void set(const T & c) { x = c; }
private:
     T x;
};|\sidebox{dintbox}{\textbf{Class template D with T= int.\\ D\textless int\textgreater is a class.}}|

int main()
{   
    |\tikzmarknode{dint}{\EMPHASIZE{D \textless int\textgreater}}| d(5);
    |\tikzmarknode{dchar}{\EMPHASIZE{D \textless char\textgreater}}| e(' a');|\sidebox{dcharbox}{\textbf{D\textless char\textgreater  class}}|
    std::cout << d.get() << ","
              << e.get() << "\n";
    return 0;
} 
\end{consolethree}
\DrawArrow[dashed,red]{dcharbox}{dchar}
\DrawArrow[dashed,red]{dintbox}{dint}
A class is generated from a class template by the compiler when you
specify the parameters.

Example:

\verb!D < int > d(5);!

If \texttt{D < char >} does not appear, then the
class \texttt{D < char >} is not generated by the
compiler. Here are some terms:

\begin{itemize}
\item
  \EMPHASIZE{Template instantiation} = generating class from class template and template arguments.
\item
  \EMPHASIZE{Specialization} = template with parameters specified
\item
  \EMPHASIZE{Template members} = members of a class template.
\end{itemize}

Template members are parameterized by the templates. So if a template
member is defined outside the class, then the class template must be
specified

\EMPHASIZE{WARNING: Everything must be placed in the header file!!! No .cpp for class template!!!}

\begin{consolethree}[escapeinside=||]
#include <iostream>

template< typename T >
class D {
public:
     D(){}
     D(T c) : x(c) {}
     T get() const;
     void set(const T &);
private:
     T x;
};

template< class T >
|\tikzmarknode{memfunc}{T D < T >::get() const}||\sidebox{memfuncbox}{Member function parameterized by \texttt{T}}|
{   
     return x;
}
|\DrawArrow{memfuncbox}{memfunc}|
template< typename T>
|\tikzmarknode{notd}{void D < T >::set(const T \& c)}||\sidebox{notdbox}{WATCH OUT! Not \texttt{D} but \texttt{D< T >}}|
{    
     x = c;
}
|\DrawArrow{notdbox}{notd}|
int main()
{   
     D < int > d(5);
     D < char > e(' a');
     std::cout << d.get() << ","
               << e.get() << "\n";
     return 0;
}
 
\end{consolethree}

Note that

\begin{console}
template< typename T >

T D < T >::get < T >() const
{    
     return x;
}
 
\end{console}

is the same as:

\begin{console}
template< typename T>

T D < T >::get() const
{    
     return x;
} 
\end{console}

i.e., within the scope of \texttt{D < T >}, T is already known.

\newpage\EMPHASIZE{Constants for template parameters}

There are three things you can specify as template parameters.
We'll talk about only two. The template parameters can be for

\begin{itemize}
\item
  types
\end{itemize}
or
\begin{itemize}
\item
  basic type values
\end{itemize}

In the above examples, the template parameters are for types:

\begin{console}
template  < typename T >
class X
{
...
private:
     T ...
...
}; 
\end{console}

Here's an example where the template parameter is a value. Run this and
study it very carefully.

\begin{consolethree}[escapeinside=||]
#include < iostream >

template < typename T, |\EMPHASIZE{int}| MAX >
class D
{
public:
     T get(int) const;
     void set(int, const T &);
private:
     T x[MAX];
};

template < typename T, int MAX>
T D < T, MAX >::get(int index) const
{    
     return x[index];
}

template < typename T, int MAX>
void D < T, MAX >::set(int index, const T & c)
{    
     x[index] = c;
};

int main()
{   
     D < int, |\EMPHASIZE{10}| > d; // d is an int array of size 10
     D< char, |\EMPHASIZE{5}| > e; // d is a char array of size 5
     d.set(1,5);
     e.set(2,' a');
     std::cout << d.get(1) << ","
               << e.get(2) << "\n";
     return 0;
}
 
\end{consolethree}

D is a class for fixed size arrays of different types. One of the template parameter is for the type of the array and the other template parameter is for the size of the array.

When instantiating the value must be a \EMPHASIZE{constant expression.}

Run this:

\begin{consolethree}[escapeinside=||]
const int x = 4;
int y = 5;
D< int, 5> d1;
D< int, x - 2> d2;
D< int, y> d3; //|\EMPHASIZE{WRONG!!! y is a variable.}|
\end{consolethree}

Type parameters are:

\begin{itemize}
\item
  Any type including basic types (int, bool) or classes.
\end{itemize}

If D is a class template

\begin{console}
template < typename T1, typename T2,
         int x, bool b >
class D{...} 
\end{console}

Then

\begin{console}
D < X, Y, 10, true > 
\end{console}

and

\begin{console}
const int x = 12;
D < X, Y, x - 2, !false > 
\end{console}

are considered the same type (if \texttt{X} and \texttt{Y} are valid types).

Recall that typedef is only an alias and does not create a new type. So if

\begin{console}
template< class X >
class D{...};
typedef int Salary;

int main()
{    
     D < int > x;       
     D < Salary > y;
}
\end{console}

then, \texttt{D < int >}, \texttt{D < Salary >} are of the same type and \texttt{x}, \texttt{y} have the same type.

Error checking can be done with two different levels: syntax errors in template and when the template parameters are being used.

In the definition of the template and class template, the template parameters are not specified yet. So the definition of

\texttt{Array < T >::print} is OK\\
\texttt{Array < int >::print} is OK\\

\begin{consolethree}[escapeinside=||]
class vec2d
{
public:
     vec2d(float x0, float y0)
         : x(x0),y(y0)
     {}
private:
     float x, y;
};

template < typename T >
class Array {
public:
     Array(int s)
         : size(s), arr(new T[s])
     {}
     void print() const;
private:
     int size; T * arr;
};

template < typename T >
void Array< T>::print()
{    
     for (int i=0; i< size; i++)
     std::cout << arr[i] << '\n';
}

int main()
{    
     Array< int> a(10); a.print();|\sidebox{whatswrongbox}{What's wrong?}|
     |\EMPHASIZE{Array < vec2d > b(10); }|
     |\EMPHASIZE{b.print();}|
     return 0;
}
 
\end{consolethree}

You can specify default values for template parameters.

The rules for default parameters are like those for default values for
function parameters.

\begin{consolethree}[escapeinside=||]
#include <iostream>

class C{};

template < typename T0, |\EMPHASIZE{typename T1=int}| >|\sidebox{defaultvaluebox}{Default values are on the right}|

class D{
public: void f(T1 a) { std::cout << a << "\n"; }
};

int main()
{    
     |\EMPHASIZE{D < C >}| obj1; obj1.f(1.1);
     |\EMPHASIZE{D < C, double >}| obj2; obj2.f(1.1);
     return 0;
}
 
\end{consolethree}

\begin{consolethree}[escapeinside=||]
#include <iostream>

class C{};

template < typename T0, typename T1=int>
class D
{
public: void f(T1);
};
|\sidebox{fdefinebox}{\textbf{Defining \texttt{f} outside the class. Like default values for function arguments, do \underline{\redtext{not}} specify default value here.}}|
|\tikzmarknode{fdefine}{template  < typename T0, typename T1 >}||\DrawArrow{fdefinebox}{fdefine}|
void D< T0, T1>::f(T1 a)
{    
     std::cout << a << ``\n'';
}

int main()
{   
     D< C> obj1;
     obj1.f(1.1);
     D< C, double> obj2;
     obj2.f(1.1);
} 
\end{consolethree}

When programming a class template, try it out for a specific type first.
After the code works, change to a generic type and include template.

WARNING: The following will give you an error.

\begin{console}
template < typename T > class C{...};
template < typename T > class D{...};

int main()
{    
     C< D< int>> c;
     return 0;
} 
\end{console}

Why? Because \texttt{>>} is an operator and for
this code:

\tab[3em]{\verb!C< D< int>> c;!}\\

you compiler will think you are trying ot do this:

\tab[3em]{\verb!...int >> c...!}\\

as if you're doing some input!!!

So write
\begin{center}
\texttt{C < D < int > > c;}
\end{center}
to prevent the above. In general when working with templates, always have a space on the right of \textless and a space to the left of \textgreater.

\newpage\EMPHASIZE{Function and struct templates}

So far we' ve talked about class templates which are templates for creating classes. But you can also have function templates and struct templates. Struct templates are very similar to class templates. Here's an example of a function template:

Run this and study it carefully:

\begin{console}
#include <iostream>

template  < typename T >
T max(T x, T y)
{    
     return (x >= y ? x : y);
}

int main()
{    
     std::cout << max < int >(5, 2) << std::endl;
     std::cout << max < double >(1.2, 3.4) << std::endl;
     return 0;
} 
\end{console}

For the case of function templates, usually the compiler can figure out
what types are intended for the type parameter. So you can run the above
test cases with this:

\begin{console}
...

int main()
{    
     std::cout << max(5, 2) << std::endl;
     std::cout << max(1.2, 3.4) << std::endl;
     return 0;
}
\end{console}

i.e., without the \texttt{ < int >} and the \texttt{ < double >}.

Like class templates, if you want to write a function template in a
separate file, then the whole function template must be a header file.

\begin{ex}
Write a min function template. Test it.

Here's another example for you to study. Add test code in your \texttt{main()} function and run it. Study it carefully. Note that in this case, the type parameter \texttt{T} appears in the body of the function template.

\begin{consolethree}[escapeinside=||]
template  < typename T >

T swap(T & x, T & y)
{    
     |\EMPHASIZE{T}| t = x;
     x = y;
     y = t;
} 
\end{consolethree}
\end{ex}
\begin{ex}
Write a print function template to print an array of type \texttt{T} values. The function should receive an array of \texttt{T} values and the number of things in the array to print starting at index 0:

\begin{console}
template  < typename T >

void print(T x[], int n)
{    
     ...
} 
\end{console}
\end{ex}

\begin{ex}
Write a linearsearch function template:

\begin{console}
template  < typename T >

int linearsearch(T x[], int n, const T & target)
{
     ...
} 
\end{console}

Test it! Make sure you test it with an array of integer values, double
values, and char values.
\end{ex}
\begin{ex}
Write a bubblesort function template.

\begin{console}
template  < typename T >
void bubblesort(T a[], int size); 
\end{console}

Test it by performing bubble sort on an array of integers and an array of doubles. Is it possible to write this version?

\begin{console}
template  < typename T >
void bubblesort(T * start, T * end); 
\end{console}
\end{ex}

\begin{ex}
Write a binarysearch function template:

\begin{console}
template  < typename T >
int binarysearch(T a[], int size, const T & target); 
\end{console}

Test it! What about this:

\begin{console}
template  < typename T >
T * binarysearch(T * start, T * end, T * target); 
\end{console}

(I have a set of notes just on function templates and just on struct templates. Study them both when you have time.)
\end{ex}

\newpage\EMPHASIZE{Typename and class}

Instead of

\begin{consolethree}[escapeinside=||]
template  < |\textbf{typename}| X >
class C{}; 
\end{consolethree}

You can say

\begin{consolethree}[escapeinside=||]
template  < |\textbf{class}| X >
class C{}; 
\end{consolethree}

They mean the same thing. However, \texttt{typename} is better.

\newpage\EMPHASIZE{Template specialization}

Suppose you have this \texttt{\textbf{Array}} class template:

\begin{console}
#include <iostream>

template < typename T, int size >
class Array
{
public:
     Array(T x[])
     {    
          for(int i = 0; i  < size; ++i)
          x_[i] = x[i];
     }
     int sum() const
     {
          int s = 0;
          for (int i = 0; i  < size; ++i)
          s += x[i];
          return s;
     }
private:
     T x_[size];
};

int main()
{    
     int x[] = {2, 3, 5, 7, 11, 13, 17, 19};
     Array < int, 4 > a(x);
     std::cout << a.sum() << '\n';
     Array < int, 3 > b(x);
     std::cout << b.sum() << '\n';
} 
\end{console}

Run it.

Then you realize that in your software that you are building, one extremely common usage of your \texttt{\textbf{Array}} library is for the case of modeling \EMPHASIZE{\texttt{int} arrays of size 3}.

A loop over an array of size 3 to compute the sum is definitely slower that unrolling the loop. The unrolled loop is going to be about twice as fast.

Hmmm \ldots can we \EMPHASIZE{speedup this case?}

Yes you can \ldots you can write a version of \texttt{\textbf{Array}} just for the case when T = \texttt\textbf{int} and size = 3. This is called a \EMPHASIZE\redtext{template specialization}.

Run this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

template < typename T, int size >
class Array
{     
     // ... same as before ...
};

|\textbf{template<>}|
|\textbf{class Array < int, 3 >}|
|\textbf{\{}|
|\textbf{public:}|
     |\textbf{Array(int x[])}|
     |\textbf{\{}|
          |\textbf{std::cout << "specialization speedup!!!\textbackslash n";}|
          |\textbf{x\_ = x[0]; y\_ = x[1]; z\_ = x[2];}|
     |\textbf{\}}|
     |\textbf{int sum() const}|    
     |\textbf{\{}|
          |\textbf{std::cout << "specialization speedup!!!\textbackslash n";}|
          |\textbf{return x\_ + y\_ + z\_;}|
     |\textbf{\}}|
|\textbf{private:}|
     |\textbf{int x\_, y\_, z\_;}|
|\textbf{\};}|

int main()
{   
     // ... same as before ...
} 
\end{consolethree}
%there is 100% a better way to do the above console, but this will work for now because im not looking for it in latextool
Template specialization is a very important idea and is used quite
frequently.

\begin{ex}
Add \texttt{\textbf{operator[]}} to both classes.
Test your code.
\end{ex}
\begin{ex}
Then you realize that \ldots{} wait a minute \ldots this specialization idea is also helpful for a \texttt{\textbf{double}} array of size 3 and a \texttt{\textbf{float}} array of size 3. Hmmm \ldots can we partially specialize? In other words can we have \texttt{\textbf{size}} = 3 but retain \texttt{\textbf{T}} as a template parameter Try to figure it out \texttt{\textbf{on your own}} before turning the page for the answer!!! You have 20 minutes ...
\end{ex}
\begin{ex}
Write a \texttt{\textbf{Matrix}} class template. A matrix is just a 2D array. Here's a sample run:

\begin{consolethree}[escapeinside=||]
#include <iostream>
|\textbf{\#include "Matrix.h"}|

int main()
{    
     int x[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
     Matrix < int, 2, 3 > m(x); // m is 2-by-3.
     std::cout << m << '\n' // prints
                            // 0 1 2
                            // 3 4 5
     Matrix < int, 2, 1 > n(x); // n is 2-by-1
     std::cout << n << '\n' // prints
                            // 0
                            // 1
    return 0;
} 
\end{consolethree}
\end{ex}
That 2-by-1 matrix is sometimes called a ``2-dimensional column vector''. Column vectors are used frequently. Furthermore processing a regular 1-dimensional array of size 2 is faster than viewing it as a 2-by-1 2D array. So \ldots speedup your \texttt{\textbf{Matrix}} library by providing a specialization for the column vector case of a \texttt{\textbf{Matrix}} object where you use a 1-dimensional array in this case The following should then work:

\begin{consolethree}[escapeinside=||]
#include <iostream>
#include "Matrix.h"

int main()
{    
     int x[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
     Matrix < int, 2, 3 > m(x); // m is 2-by-3.
     std::cout << m << '\n' // prints
                            // 0 1 2
                            // 3 4 5
     |\textbf{Matrix < int, 2 >}| n(x); // n is 2-by-1
     std::cout << n << '\n' // prints
                            // 0
                            // 1
     return 0;
} 
\end{consolethree}

Such a template library is very common in computer graphics and computer
vision. Such a library usually provide a typedef for \texttt{\textbf{Matrix < double, 4, 4 >}}, \texttt{\textbf{Matrix < int, 2 >}}, etc.. For instance there might be a typedef \texttt{\textbf{mat4x4}} for \texttt{\textbf{Matrix < double, 4, 4 >}}\textbf{, }\texttt{\textbf{mat}\textbf{f}\textbf{4x4}} for \textbf{\texttt{Matrix < float, 4, 4 >}}, and \texttt{\textbf{vec4f}} for \texttt{\textbf{Matrix < float, 4 >.}}
\newpage %solutions here
WARNING \ldots INCOMING SPOILER \ldots

Here's the (obvious?) answer to the question on the previous page:

\begin{consolethree}[escapeinside=||]
template < typename T, int size >
class Array
{
public:
     Array(T x[])
     {    
          for(int i = 0; i  < size; ++i)
          x_[i] = x[i];
     }
     int sum() const
     {    
          int s = 0;
          for (int i = 0; i  < size; ++i)
              s += x_[i];
          return s;
     }
private:
     T x_[size];
};

|\textbf{template < typename T >}|
|\textbf{class Array < T, 3 >}|           
|\textbf{\{}|
|\textbf{public:}|
     |\textbf{Array(T x[])}|
     |\textbf{\{}|
          |\textbf{std::cout << "specialization speedup!!!\textbackslash n";}|
          |\textbf{x\_ = x[0]; y\_ = x[1]; z\_ = x[2];}|
     |\textbf{\}}|
     |\textbf{int sum() const}|
     |\textbf{\{}|
          |\textbf{std::cout << "specialization speedup!!!\textbackslash n";}|
          |\textbf{return x\_ + y\_ + z\_;}|
     |\textbf{\}}|
|\textbf{private:}|
     |\textbf{T x\_, y\_, z\_;}|
|\textbf{\};}|           
\end{consolethree}
