\newpage\EMPHASIZE{25. Function Overloading}

\textsc{Objectives}
\begin{itemize}
\item Understand function signatures
\item Write overloaded functions
\end{itemize}


\newpage\EMPHASIZE{Too many function names to remember!}

This is an easy:

\begin{consolethree}[escapeinside=||]
int max(int x, int y)
{
    if (x < y) return y;
    else return x;
}
\end{consolethree}

But what if I want to compute the max of two doubles? If I use the
above:

\begin{consolethree}[escapeinside=||]
int max(int, int);

int main()
{
    std::cout << max(3, 42) << ' '
              << max(3.14, 2.718) << std::endl;
    return 0;
}

int max(int x, int y)
{
    if (x < y) return y;
    else return x;
}
\end{consolethree}

I will lose the fractional part of the true maximum (because when the function is called, \texttt{x} will have a value of 3 and y will have a value of 2.)

In other words 3.14 is typecasted to an integer before it's given to \texttt{x}.

So I have to write another max function for doubles. To make sure I don't have two functions with the same name I do this:

\begin{consolethree}[escapeinside=||]
int max(int, int);
double max2(double, double);

int main()
{
    std::cout << max(3, 42) << ' '
              << max2(3.14, 2.718) << std::endl;
    return 0;
}

int max(int x, int y)
{
    if (x < y) return y;
    else return x;
}

double max2(double x, double y)
{
    if (x < y) return y;
    else return x;
}
\end{consolethree}

Now the nightmare begins ...

What if I want the max of an array of integers? An array of doubles?

Looks like I need:

\begin{consolethree}[escapeinside=||]
int max(int, int);
double max2(double, double);
int max3(int[], int len);
double max4(double[], int len);
...
\end{consolethree}

YIKES!!! HELP ME MAMA!!!

MY HEAD IS GOING TO BLOW UP JUST REMEMBERING WHICH IS WHICH!!!


\newpage\EMPHASIZE{Function Overloading}

This is from the previous section:

\begin{consolethree}[escapeinside=||]
int max(int, int);
double max2(double, double);

int main()
{
    std::cout << max(3, 42) << ' '
              << max2(3.14, 2.718) << std::endl;
    return 0;
}

int max(int x, int y)
{
    if (x < y) return y;
    else return x;
}

double max2(double x, double y)
{
    if (x < y) return y;
    else return x;
}
\end{consolethree}

Make this change:

\begin{consolethree}[escapeinside=||]
int max(int, int);
double max(double, double);

int main()
{
    std::cout << max(3, 42) << ' '
              << max(3.14, 2.718) << std::endl;
    return 0;
}

int max(int x, int y)
{
    if (x < y) return y;
    else return x;
}

double max(double x, double y)
{
    if (x < y) return y;
    else return x;
}
\end{consolethree}

Run it.

\EMPHASIZE{:O}

How come C++ is not confused by two functions with the \textbf{\textit{same name}}?

The reason is because C++ recognizes functions by their \EMPHASIZE{names \textit{\underline{and}} the types of the parameters}. Here are the prototypes of the above function:

\begin{consolethree}[escapeinside=||]
int max(int, int);
double max(double, double);
\end{consolethree}

You can think of it this way: the integer \texttt{max()} function is identified by \texttt{(max, int, int)} and the double \texttt{max()} function is identified by \texttt{(max, double, double)}.

You see what happens is that the actual function name of \texttt{max(int, int)} might be \texttt{max\_int\_int()} and the name of \texttt{max(double, double) }might be \texttt{max\_double\_double()}. I say ``might'' because it depends on the compiler. For instance another compiler might use \texttt{max\_\_\_\_int\_\_\_\_int()} instead of \texttt{max\_int\_int()}.

This change of function name is called name mangling.

The types of the parameters is called the \EMPHASIZE{signature} of the function. So the signature of

\begin{consolethree}[escapeinside=||]
int max(int, int);
\end{consolethree}

is \texttt{(int, int)}.

The important thing to remember that a function is identified by its \EMPHASIZE{name} \textit{and} \EMPHASIZE{signature}.

Of course now that a function is determined by its name and signature, this tells you that you cannot have two different functions with the same name and signature. Therefore this is BAD:

\begin{consolethree}[escapeinside=||]
void bad(int x, double y, char z)
{
    std::cout << "first bad ..." << '\n';
    ...
}

int bad(int x, double y, char z)
{
    std::cout << "second bad ..." << '\n';
    ...
}
\end{consolethree}

Yes, yes, yes \ldots{} the return type is different \ldots{} but C++ only looks at the name and the signature when choosing a function to execute.

So we revise the way C++ searches for identifiers (i.e. names):

\begin{itemize}
\item The search for variables is still the same
\item The search for functions when they are called is different.
  \begin{quote}
  If the function name can be found and the types of the arguments
  passed in matches the function signature (the type of the parameters),
  then that function is used.
  \end{quote}
  \begin{quote}
  Otherwise, C++ will try to typecast the arguments to values that will
  match a signature.
  \end{quote}
\end{itemize}

Here's one more example. Run it.

\begin{consolethree}[escapeinside=||]
#include <iostream>

void f(int, int, int);
void f(double, double, double);

int main()
{
    f(1, 2, 3);
    f(1.1, 2.2, 3.3);
    return 0;
}

void f(int x, int y, int z)
{
    std::cout << "f(int, int, int)" << std::endl;
}

void f(double x, double y, double z)
{
    std::cout << "f(double, double, double)"
              << std::endl;
}
\end{consolethree}

When you have several functions with the same name (but different signatures!), we say that the function is \EMPHASIZE{overloaded}.

\begin{ex}
Here are two function prototypes:

\begin{consolethree}[escapeinside=||]
// computes the maximum value of the array passed in
int max(int[], int len);
double max(double[], int len);
\end{consolethree}

Implement the function bodies and test them in a \texttt{main()}.
\end{ex}

\begin{ex}
Implement the following and test your code.

\begin{consolethree}[escapeinside=||]
// Functions return the minimum of values passed in
// either through parameters or values in an array
int min(int, int);
double min(double, double);
int min(int[], int len);
double min(double[], int len);
\end{consolethree}
\end{ex}

\begin{ex}
Implement and test your functions for the following prototypes:

\begin{consolethree}[escapeinside=||]
// area functions
double area(double, double); // area of rectangle
                             // with given sides
double area(double);         // area of circle with
                             // given radius
\end{consolethree}
\end{ex}

Remember earlier in the semester when I said that there are two + operators. Example:

\verb!1 + 2! integer addition operator

\verb!1.2 + 3.4! double addition operator

At that point I told you to remember this important distinction. This is very similar to function overloading, except that these are operators and not functions. We say that + is an \EMPHASIZE{overloaded operator}. In CISS245 you will learn to define your own operators so for instance you can define your own operators including +.


\newpage\EMPHASIZE{WARNING: const int and int}

Here's a warning: ``const int'' is the same type as ``int''. The ``const'' is about the nature of the value that a variable refers to, i.e. for

\verb!const int x = 42;!

the const simply means that x is a constant variable. The type of value that x has is still an \texttt{int}. Now why is this important in the context of function overloading? Well \ldots{} the above implies that

\begin{consolethree}[escapeinside=||]
void f(int x)
{
}

void f(const int x)
{
}

int main()
{
    return 0;
}
\end{consolethree}

will not compile because the two functions \texttt{f} above have the same signature. Make sure you at least compile the above and read the error message from the compiler so that when this error bites you, you'll know why.

\begin{ex}
What about references? Are \texttt{int\&} and \texttt{int} considered the same too? In other words does the following compile:

\begin{consolethree}[escapeinside=||]
void f(int x)
{
}

void f(int & x)
{
}

int main()
{
    return 0;
}
\end{consolethree}
\end{ex}


\newpage\EMPHASIZE{Why Overloading?}

The reason why we have function (and operator) overloading is clear: Many functions perform similar operations and we want to remember fewer names.

This is also the case in Math. Not only is + used for addition of real numbers, it's also used for things like addition of functions, addition of vectors, addition of matrices, etc. So having function/operator overloading in a programming language allows us to design software to match the mathematical language/symbols that we are used to.

Even in daily use of the English language, we see the same word used similar but different situations: open a door, open a jar, open my wallet, open your mind, etc.

Overloading is a software technique for controlling software complexities.

(Some older programming languages do not have function overloading. Some don't even allow you to define your own operators. Also, there are programming languages where overloading is not allowed. In fact there are programming languages where the symbol for adding integers is different from the symbol for adding doubles.)

\newpage\EMPHASIZE{Return type warning}

I've already mentioned this \ldots{} but's it's such a common error that it's a good idea to repeat it \ldots{}

\ldots{} the \EMPHASIZE{return type is \textit{\underline{not}} part of the identification of a function}. In other words the following is \EMPHASIZE{incorrect}:

\begin{consolethree}[escapeinside=||]
int f(int);    // identified as f, int
double f(int); // identified as f, int
\end{consolethree}

Why? Because of this ...

Recall that it's OK \textit{\EMPHASIZE{not}} to use the return value of a function. For instance this is a valid piece of code:

\begin{consolethree}[escapeinside=||]
int f()
{
    return 42;
}

int main()
{
    f(); // return value is not used
    return 0;
}
\end{consolethree}

In fact even this is OK:

\begin{consolethree}[escapeinside=||]
int main()
{
    42;
    return 0;
}
\end{consolethree}

Now suppose you have a C++ compiler (called Crazy C++) that identifies function by their names, signatures \EMPHASIZE{and return types}. Then you have this \textbf{problem}:

\begin{consolethree}[escapeinside=||]
int f(int)
{}

double f(int) // should be different from above f()
{}

int main()
{
    f(42); // Crazy C++: ... which one to use???
           // the return type is not indicated!!!
    return 0;
}
\end{consolethree}

Make sure you run this program.


\newpage\EMPHASIZE{Type Casting and Ambiguous Invocation}

Recall that this is how C++ searches for functions (see above):

\begin{itemize}
\item If the function name can be found and the types of the arguments
  passed in matches the function signature (the type of the parameters),
  then that function is used.
\item Otherwise, C++ will try to typecast to something suitable.
\end{itemize}

Try this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void f(int, int, int);

int main()
{
    f(1, 2, 3);
    f(4.4, 5.5, 6.6);
    return 0;
}

void f(int x, int y, int z)
{
    std::cout << "f(int, int, int)" << std::endl;
}
\end{consolethree}

Now this:

\begin{consolethree}[escapeinside=||]
#include <iostream>

void f(int, int, int);
void f(double, double, double);

int main()
{
    f(1, 2, 3);
    f(1.1, 2.2, 3.3);
    return 0;
}

void f(int x, int y, int z)
{
    std::cout << "f(int, int, int)" << std::endl;
}

void f(double x, double y, double z)
{
    std::cout << "f(double, double, double)"
              << std::endl;
}
\end{consolethree}

So far so good \ldots{}

But now ...

\begin{ex}
Add \texttt{f(1, 2, 3.4);} to the main of the program above and run it.

\begin{consolethree}[escapeinside=||]
...

int main()
{
    f(1, 2, 3);
    f(1.1, 2.2, 3.3);
    f(1, 2, 3.4);
    return 0;
}

...
\end{consolethree}

Does it work?
\end{ex}

There are two possibilities: C++ can call

\texttt{void f(int, int, int)} type cast 3.4 to 3

\texttt{void f(double, double, double) }type cast 1 to 1.0, 2 to 2.0

If there are two or more possible function calls after attempts to type cast, C++ will choke and yell at you. This type of error is called \EMPHASIZE{ambiguous invocation}.

As mentioned before: Always be explicit in your code -- as much as possible avoid implicit typecasts that are done behind your back. Something like:

\verb!int x = 0;!

\verb!double y = x;!

should be written

\verb!int x = 0;!

\verb!double y = double(x);!

\begin{ex}
Are there any ambiguous function calls? Find and circle if any.

\begin{consolethree}[escapeinside=||]
void f(int x, int y, int z)
{}

void f(int x)
{}

void f()
{}

void f(int x, int y, double z)
{}

int main()
{
    f(1);
    f(1, 2, 3);
    f(1.1, 3.3, 4.4);
    return 0;
}
\end{consolethree}

Verify with your C++.
\end{ex}
