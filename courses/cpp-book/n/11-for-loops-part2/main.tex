% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\author{}
\date{}

\begin{document}

11. for Loops: Part 2

This is a continuation of our discussion of for-loops ...

The three parts of the for-loop

Look at the structure of the for-loop:

The statement looks like this:

for (\emph{{[}stmt1{]}}; \emph{{[}bexpr{]}}; \emph{{[}stmt2{]}})

\emph{{[}stmt3{]}}

where {[}stmt1{]}, {[}stmt2{]}, {[}stmt3{]} are statements; {[}stmt1{]}
and {[}stmt2{]} are written without a `;' since it's included in the
above notation.

{[}stmt1{]} is executed \textbf{first} and it's executed exactly
\textbf{once}.

After executing \emph{{[}stmt1{]}, {[}bexpr{]}} is evaluated.

If the resulting value is \emph{true}, \emph{{[}stmt3{]}} is executed.
After that \emph{{[}stmt2{]}} is executed. And after that we repeat by
evaluating \emph{{[}bexpr{]}.}

If the resulting value of the \emph{{[}bexpr{]}} is \emph{false}, the
program exits the \emph{for}-loop and executes the statement after the
\emph{for}-loop.

By the way, sometimes \emph{{[}stmt1{]}} is sometimes called the
\textbf{initialization} statement of the for-loop while
\emph{{[}stmt2{]}} is called the \textbf{update} statement. For the
following code:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 100; i++)

\{

std::cout \textless\textless{} i \textless\textless{} std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\emph{i} is called the \textbf{index or counter variable} of the
for-loop.

Two final terms:

Leaving things out

Refer to the diagram from the previous section.

Actually it turns out that you can leave out \emph{{[}stmt1{]}}. Try
this

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 5; i++)

\{

std::cout \textless\textless{} "i have " \textless\textless{} i
\textless\textless{} " head(s)"

\textless\textless{} std::endl;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

And now modify it as follows:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int i = 0;

for (; i \textless{} 5; i++)

\{

std::cout \textless\textless{} "i have " \textless\textless{} i
\textless\textless{} " head(s)"

\textless\textless{} std::endl;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

You can also leave the third part out as well!!!

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int i = 0;

for (; i \textless{} 5;)

\{

std::cout \textless\textless{} "i have " \textless\textless{} i
\textless\textless{} " head(s)"

\textless\textless{} std::endl;

i++;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

What if the second part is blank? Try this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int i = 0;

for (;;)

\{

std::cout \textless\textless{} "i have " \textless\textless{} i
\textless\textless{} " head(s)"

\textless\textless{} std::endl;

i++;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(Pretty gross, isn't it? ...)

This tells you that if the boolean expression is missing, C++ will
assume you want the boolean value to be \emph{\textbf{true}}. Remember
what I said before: you have to pay attention whenever C++ does
something for you automatically.

By the way, the above program is executing an \textbf{infinite loop}
(because it doesn't stop). This format of the for-loop is sometimes used
in writing games, although we'll see that there's another type of loop
called the \textbf{while-loop} that is frequently used instead. Although
in the above

\emph{for (;;)}

...

it seems like you can't get out of the loop. But, in fact, \textbf{you
can get out of the loop in another way}. We'll talk about it later.

Why scopes?

Compare the following programs:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int i = 0;

int sum = 0;

for (i = 0; i \textless{} 10; i++)

\{

sum += i;

\}

std::cout \textless\textless{} sum \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int sum = 0;

for (int i = 1; i \textless{} 11; i++)

\{

sum += i;

\}

std::cout \textless\textless{} sum \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Their goals are the same: To compute and print the sum of integers from
1 to 10.

The only difference is in the scope of variable \emph{i}. The scope of
\emph{i} is a lot smaller in the second program.

If you think about it, the variable \emph{i} is sort of like a
``scratch'' variable when compared to \emph{sum}. You don't really need
it once the computation of \emph{sum} is completed. When you read the
second program, you can very easily deduce the fact that \emph{i} is a
``scratch'' variable from it's scope: it exists only in the
\emph{for}-loop.

A complex problem is solved by breaking the problem into smaller and
simpler subproblems. Once that's done you solve the simpler subproblems
and put these subsolutions together to solve the big problem. One should
be careful of the unintended effects of a subsolution -- a small piece
of the solution overall -- on another.

Here's an example. This program prints the sum from 1 to 10 and then the
sum from 1 to 100:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int i;

int sum = 0;

for (i = 1; i \textless{} 11; i++)

\{

sum += i;

\}

// Print sum from 1 to 10

std::cout \textless\textless{} sum \textless\textless{} std::endl;

// Continue the summing process

for (; i \textless{} 101; i++)

\{

sum += i;

\}

std::cout \textless\textless{} sum \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

If you're working on a project with someone and you both have agreed
that i is a scratch variable, he might use it like this in a computation
of a formula involving a, b, c, d, e, f

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
i = a + b;

result = i + c + d + e + f;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

He might just insert this into your code:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int i;

int sum = 0;

for (i = 1; i \textless{} 11; i++)

\{

sum += i;

\}

std::cout \textless\textless{} sum \textless\textless{} std::endl;

i = a + b;

result = i + c + d + e + f;

for (; i \textless{} 101; i++)

\{

sum += i;

\}

std::cout \textless\textless{} sum \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Do you see how his work has now destroyed your computation?

In general you want to have as little ``communication'' as possible
between your subsolutions when they are meant to be independent.

One way to achieve that is to use small scopes. Look at this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\textbf{int i};

int sum = 0;

for (\textbf{int i = 1}; i \textless{} 11; i++)

\{

sum += i;

\}

std::cout \textless\textless{} sum \textless\textless{} std::endl;

i = a + b;

result = i + c + d + e + f;

for (\textbf{int i = 1}; i \textless{} 101; i++)

\{

sum += i;

\}

std::cout \textless\textless{} sum \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

There are really 3 i's. The first is outside both for-loops. The second
is created only when you enter the first for-loop; this is destroyed
when you exit the first for-loop. The third is created only when you
enter the second for-loop; this is destroyed when you exit the second
for-loop. They all live in different ``places''.

Even more examples

Now for examples where the body of the for-loop is more complicated.

Of course you can put if-statements in the for-loop. Run this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Exercise. Modify the above program by adding an else statement to the if
statement that prints \emph{i} and \emph{" is not included"}.

\textbf{Exercise.} Write a program that randomly generates 20 integers
between 0 and 3.

\textbf{Exercise.} Write a program that randomly generates 20 integers
between 10 and 20 and continually sums up all of them, printing the sum
in each iteration.

Mixing two for-loops

Of course you can put a for-loop in a for-loop to get a double for-loop:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 5; i++)

\{

std::cout \textless\textless{} "i:" \textless\textless{} i
\textless\textless{} std::endl;

for (int j = 0; j \textless{} 3; j++)

\{

std::cout \textless\textless{} " j:" \textless\textless{} j
\textless\textless{} std::endl;\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Read the output very carefully!!!

\textbf{Exercise.} Write a program that has a double for-loop and prints
this

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
3

1 2 3

4

1 2 3

5

1 2 3 \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that has a double for-loop and prints
this

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
3

0 1 2 3

4

0 1 2 3 4

5

0 1 2 3 4 5\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that has a double for-loop and prints
this

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
3

0 1 2

4

0 1 2 3

5

0 1 2 3 4\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that has a double for-loop and prints
this

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
3

0 1 2 3 4 5 6

4

0 1 2 3 4 5 6 7 8

5

0 1 2 3 4 5 6 7 8 9 10\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that has a double for-loop and prints
this

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
3

3 4 5 6

4

4 5 6 7 8

5

5 6 7 8 9 10\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise. }Write the following program that prints a calendar
month. The program prompts the user for three integers: the month, the
year, and the day-of-week for the first day of the month (with 0
representing Sunday, 1 representing Monday, etc.),. For instance, if the
user entered

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
3 2008 6\tabularnewline
\bottomrule
\end{longtable}

It means that he/she wants the calendar for March 2008 and the first day
of the month is a Saturday. The output is

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
March 2008

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

Su Mo Tu We Th Fr Sa

1

2 3 4 5 6 7 8

9 10 11 12 13 14 15

16 17 18 19 20 21 22

23 24 25 26 27 28 29

30 31\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another test case:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
3 2008 4

March 2008

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

Su Mo Tu We Th Fr Sa

1 2 3

4 5 6 7 8 9 10

11 12 13 14 15 16 17

18 19 20 21 22 23 24

25 26 27 28 29 30 31\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Of course your program should be smart enough to compute the number of
days in the month (including leap year cases for the month of February.)

Some ASCII art

Now for some (silly) ASCII art.

Try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And more ASCII art

It can only get worse ...

I want to draw a square of *. The square has width 5 and height 3. First
I draw a horizontal line:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

OK. Now, I just draw the horizontal line 3 times:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Oops! How come I get a straight line??? Well, of course after drawing a
horizontal line, I need to skip my cursor to the next line:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The boolean condition in the for-loop can be any boolean expression. So
instead of drawing 3 lines, you can prompt the user for number of lines
to draw instead.

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Exercise. Now modify the program so that it prompts the user for the
width of the square. (Obviously you must draw the square with that
width).

Unrolling the for-loop: How to see the for-loop

Sometimes it's hard to come up with the appropriate for-loop. In that
case it's always easier to \textbf{``unroll''} the for-loop for several
special cases by hand. Unrolling a for-loop is just writing down what
the program executes without using the for-loop. For instance, unrolling
the following:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 3; i++)

\{

std::cout \textless\textless{} i \textless\textless{} std::endl;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

gives us

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
std::cout \textless\textless{} 0 \textless\textless{} std::endl;

std::cout \textless\textless{} 1 \textless\textless{} std::endl;

std::cout \textless\textless{} 2 \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

For instance, suppose you want the program to draw this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
*

**

***

****\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

if the user enters 4 (this is a triangle). And if he enters 3, the
program draws:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
*

**

***\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

So just take a special case, say when the user enters 3, and write the
pseudocode \textbf{without the for-loop}:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
draw a line of length 1

draw a line of length 2

draw a line of length 3\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The pseudocode for height 4 is

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
draw a line of length 1

draw a line of length 2

draw a line of length 3

draw a line of length 4\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Of course you want to write one program and not two! The program must
work for both cases. We must find a way to ``combine'' them.

The first pseudocode ... \textbf{NOT C++!!!} ... can be written:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for i = 1, 2, 3:

draw a line of length i\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

and the second can be written:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for i = 1, 2, 3, 4:

draw a line of length i\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now they are almost the same! If the height entered by the user is kept
in variable h, then the pseudocode is

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for i = 1, 2, ..., h:

draw a line of length i\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

AHA! \textbf{This pseudocode works for both!!!}

Of course you already know how to draw a line (of stars) of length i. So
altogether the pseudocode becomes:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for i = 1, 2, ..., h:

for j = 1, 2, ..., i:

draw a star

go to the next line\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

And finally a straightforward translation to C++ gives:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 1; i \textless= h; i++)

\{

for (int j = 1; j \textless= i; j++)

\{

std::cout \textless\textless{} '*';

\}

std::cout \textless\textless{} std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now we add the icing by prompting the user for h:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int h = 0;

std::cin \textgreater\textgreater{} h;

for (int i = 1; i \textless= h; i++)

\{

for (int j = 1; j \textless= i; j++)

\{

std::cout \textless\textless{} '*';

\}

std::cout \textless\textless{} std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Unrolling the for-loop: Another example

What about this? If the user enters 3 your program has to draw:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
***

***

***\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

If the user enters 4 your program has to draw

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
****

****

****

****\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The pseudocode for the case when the user enters 3 is (without using the
for-loop):

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
draw 2 spaces

draw 3 stars

draw 1 space

draw 3 stars

draw 3 stars\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The trick is to make everything as uniform as possible. So write this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
draw 2 spaces

draw 3 stars

draw 1 space

draw 3 stars

draw 0 space

draw 3 stars\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

See the pattern yet? No?

The interleaving of two different things is confusing. Rewrite this as:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
draw 2 spaces; draw 3 stars

draw 1 space; draw 3 stars

draw 0 space; draw 3 stars\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

What if the user enters 4? The pseudocode becomes

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
draw 3 spaces; draw 4 stars

draw 2 spaces; draw 4 stars

draw 1 space; draw 4 stars

draw 0 space; draw 4 stars\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

How do you combine the above cases into one common pseudocode?

The first is

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for i = 2, 1, 0:

draw i spaces; draw 3 stars\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The second is

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for i = 3, 2, 1, 0:

draw i spaces; draw 4 stars\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now both pseudocodes are almost the same!!! Suppose the value entered by
the user is kept in a variable n. Then you can (finally!) combine both
pseudocodes into one:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for i = n-1, ..., 0:

draw i spaces; draw n stars\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now you add in the details:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for i = n-1, ..., 0:

// draw i spaces

for j = 1, ..., i

draw a space

// draw n stars

for j = 1, ..., n

draw a star

go to next line\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

And finally a straightforward translation to C++ yields:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = n - 1; i \textgreater= 0; i-\/-)\\
\{

for (int j = 1; j \textless= i; j++)

\{

std::cout \textless\textless{} ' ';\\
\}

for (int j = 1; j \textless= n; j++)

\{

std::cout \textless\textless{} '*';\\
\}

std::cout \textless\textless{} std::endl;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Adding the prompt (and some comments) we get:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n = 0;

std::cin \textgreater\textgreater{} n;

for (int i = n-1; i \textgreater= 0; i-\/-)\\
\{

// Print i spaces

for (int j = 1; j \textless= i; j++)

\{

std::cout \textless\textless{} ' ';\\
\}

// Print n stars

for (int j = 1; j \textless= n; j++)

\{

std::cout \textless\textless{} '*';\\
\}

std::cout \textless\textless{} std::endl;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that draws the following figure when
the user enters 3

***

* *

***

and when the user enters 4 it draws

****

* *

* *

****

{[}See next page for hints.{]}

\textbf{Exercise.} Write a program that draws the following figure when
the user enters 3

*

***

*****

and this when the user enters 4

*

***

*****

*******

{[}See next page for hints.{]}

WARNING: SPOILERS!!!

Here are the pseudocode (with explanations) for the last two ASCII art
problems from the previous section.

Here's the first problem \ldots{}

\textbf{Exercise.} Write a program that draws the following figure when
the user enters 3

***

* *

***

and when the user enters 4 it draws

****

* *

* *

****

and here's the pseudocode with explanation:

For n = 4:

4 stars

1 star, 2 spaces, 1 star

1 star, 2 spaces, 1 star

4 stars

For n = 5:

5 stars

1 star, 3 spaces, 1 star

1 star, 3 spaces, 1 star

1 star, 3 spaces, 1 star

5 stars

In general, we have:

n stars

n-2 of {[}1 star, n-2 stars, 1 star{]}

n stars

Therefore, the pseudocode is:

print n stars

print newline

for i = 1,..., n-2

print 1 star

print n-2 stars

print 1 star

print newline

print n stars

And after expanding some of the print statements we get:

//print n stars

for i=1 ,..., n: print '*'

print newline

for i = 1, ..., n-2

print '*'

//print n-2 stars

for j=1,..., n-2: print '*'

print '*'

print newline

//print n stars

for i=1, ..., n: print '*'

\textbf{Exercise.} Write a program that draws the following figure when
the user enters 3:

*

***

*****

and this when the user enters 4:

*

***

*****

*******

When n = 3:

2 spaces, 1 star

1 space, 3 stars

0 space, 5 stars

When n = 4:

3 spaces, 1 star

2 spaces, 3 stars

1 space, 5 stars

0 space, 7 stars

There are two columns of numbers to handle. In other words, each line
(which is the body of a loop) has two numbers. The first column is easy
-- it's just from n-1 to 0. So the pseudocode looks like this:

for i = n-1 to 0

i spaces, ??? stars

What about the second? The relationship between the second number and i
is not so direct. But note that it starts with 1 and always goes up by 2
after each iteration. So the pseudocode looks like

numStars = 1

for i = n-1 to 0

i spaces, numStars stars

numStars = numStars + 2

In more details:

numStars = 1

for i = n-1 to 0

print i spaces

print numStars stars

print newline

numStars = numStars + 2

And after expanding some print statements we get

numStars = 1

for i = n-1 to 0

//print i spaces

for j=1, \ldots, i: print ' '

// print numStars stars

for j=1, \ldots, numStars: print '*'

print newline

numStars = numStars + 2

break

Remember \emph{break} from the \emph{switch} statement? If you execute
\emph{break}, you immediately go out of the \emph{switch} block.
\emph{break} can also be used in a \emph{for}-loop.

First run this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 1000; i += 2)

\{

std::cout \textless\textless{} "entered body of
for-loop\textbackslash n";

std::cout \textless\textless{} i \textless\textless{} std::endl;

std::cout \textless\textless{} "exiting body of
for-loop\textbackslash n";

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now run this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 1000; i += 2)

\{

std::cout \textless\textless{} "entered body of
for-loop\textbackslash n";

std::cout \textless\textless{} i \textless\textless{} std::endl;

\textbf{if (i == 100) break;}

std::cout \textless\textless{} "exiting body of
for-loop\textbackslash n";

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

See the point of \emph{break}?

The \emph{break} when executed in a \emph{for}-loop will get out of that
\emph{for}-loop. That's all there is to it.

Of course some times you can avoid the break. For the above program you
can rewrite it as

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 101; i += 2)

\{

std::cout \textless\textless{} i \textless\textless{} std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

There's a general principle (or good practice) that you should
\textbf{avoid having too many exit points out of a loop}. Too many exit
points make the code difficult to trace.

It's very important to note that the execution of break only exits the
current for-loop. Make sure you trace and run try this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 5; i++)

\{

std::cout \textless\textless{} "A: " \textless\textless{} i
\textless\textless{} std::endl;

for (int j = 0; j \textless{} 5; j++)

\{

std::cout \textless\textless{} "B: " \textless\textless{} j
\textless\textless{} std::endl;

if (j == 1) break;

std::cout \textless\textless{} "C: " \textless\textless{} j
\textless\textless{} std::endl;\\
\}

std::cout \textless\textless{} "D: " \textless\textless{} i
\textless\textless{} std::endl;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

continue

Another way to control the flow of execution in a for-loop is by using
the \emph{continue} statement. Try this and tell me what it does:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int i = 0; i \textless{} 101; i += 2)

\{

std::cout \textless\textless{} "top of loop" \textless\textless{}
std::endl;

std::cout \textless\textless{} i \textless\textless{} std::endl;

if (i \textgreater{} 10) continue;

std::cout \textless\textless{} "bottom of loop" \textless\textless{}
std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

A picture tells a thousand words:

\textbf{Exercise.} Write a program that prompts the user for
\emph{start}, \emph{end}, and \emph{skip} (altogether there are three
integers) and prints the sum of all integers from start to end except
for \emph{skip}. Here's the skeleton

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int start = 0, skip = 0, end = 0;

std::cin \textgreater\textgreater{} start \textgreater\textgreater{} end
\textgreater\textgreater{} skip;

int sum = 0;

for ( ; ; )

\{

if ( ) ;

sum += ;

\}

std::cout \textless\textless{} sum \textless\textless{} std::endl;
\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

For instance, if \emph{start} is -5, \emph{end} is 10, and \emph{skip}
is 7, then your program should compute the sum of integers from -5 to 10
(inclusive) except for 7.

Divisors and primes

Quick review of divisors and primes (See previous notes on integers for
more information.)

Let n be a positive integer at least 1 and let d be a positive integer
greater than 0. We say that d \textbf{divides} n or that d is a
\textbf{divisor} of n if you can find an integer x such that dx = n.
(Yes, we've seen this before, in earlier notes and also in the
prerequisite math courses.) You already know that the statement

``d divides n''

in C++ is

\emph{n \% d == 0}

Of course for d to be a divisor of n, d must be at most n.

\textbf{Exercise.} Write a program that prompts the user for n and
prints all the (positive) divisors of a given positive integer n. For
instance, if the user entered 10 for n, the program should print

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
1

2

5

10\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

If the user entered 11, the program should print

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
1

11\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Don't forget that when the user entered 1 for n, your program should
print only one 1:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
1\tabularnewline
\bottomrule
\end{longtable}

Once you're done with your program, modify it so that if the user
entered an integer less than or equal to 0, it prints

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
Wrong input. Run again and enter a positive int.\tabularnewline
\bottomrule
\end{longtable}

A \textbf{prime} is a positive integer which is greater than 1 and is
divisible by only 1 and itself.

Let's try to get C++ to list primes.

Look at the statement: ``A prime is a positive integer which is greater
than 1 and is divisible by only 1 and itself.''

Let's say the value of the integer is in variable n. There are two
conditions to check on n

\begin{itemize}
\tightlist
\item
  n greater than 1
\item
  n is divisible by only 1 and itself
\end{itemize}

The first condition is easy. The second one is tricky. But its not too
bad.

Suppose n has value 7. We just need to check that 2, 3, 4, 5, and 6
cannot divide 7 to conclude that 7 is a prime.

Hmmm .... ``2, 3, 4, 5, and 6'' ... sure sounds like a for-loop.

What about ``cannot divide''??? Well ``i divides n'' is the same as
saying n \% i is zero. So for ``i does not divide n'', the remainder
when you divide n by i must be nonzero, i.e. n \% i is not zero. (Duh.)

Try this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n = 7;

for (int i = 2; i \textless{} n; ++i)

\{

std::cout \textless\textless{} i \textless\textless{} ' '
\textless\textless{} n \% i \textless\textless{} std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now try this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n = 25;

for (int i = 2; i \textless{} n; i++)

\{

std::cout \textless\textless{} i \textless\textless{} ' '
\textless\textless{} n \% i \textless\textless{} std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

AHA! If you do get a nonzero value, it's not a prime and you can stop
the check right?

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n = 25;

for (int i = 2; i \textless{} n; ++i)

\{

std::cout \textless\textless{} n \% i \textless\textless{} std::endl;

if (n \% i == 0) break;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

But \ldots{} of course you still need to know if your \emph{n} is a
prime!!! You can't tell from the above code. Why? Because it's possible
to get out of the loop in \textbf{two} different ways:

\begin{itemize}
\tightlist
\item
  you could have gotten out of the loop because \emph{i} reached
  \emph{n} (therefore \emph{n} is a prime); or
\item
  \emph{break} was executed (therefore \emph{n} is not a prime)
\end{itemize}

We need to \textbf{disambiguate} the exit condition of the for-loop!!!

To do that, we create a variable that tells us why we are out of the
for-loop. Let's call it \emph{flag}. I'll let our program get the value
of \emph{n} from us so that it's easier to test the program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n;

std::cin \textgreater\textgreater{} n;

int flag;

for (int i = 2; i \textless{} n; ++i)

\{

std::cout \textless\textless{} n \% i \textless\textless{} std::endl;

if (n \% i == 0)

\{

flag = 1; // flag equals 1 means n not prime

break;

\}

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

But what if \emph{n} is indeed a prime? It would pass all the tests
(i.e.the body of the if statement will not execute). In that case
\emph{flag} will not be assigned a value!!! We had better give
\emph{flag} an initial value:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n = 25;

int flag = 0; // flag equals 0 means n is prime

for (int i = 2; i \textless{} n; ++i)

\{

std::cout \textless\textless{} n \% i \textless\textless{} std::endl;

if (n \% i == 0)

\{

flag = 1; // flag equals 1 means n not prime

break;

\}

\}

// At this point ...

// if flag is 0, then n is prime

// if flag is 1, then n is not prime\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Let's insert a print statement after the loop:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n = 25;

int flag = 0; // flag equals 0 means n is prime

for (int i = 2; i \textless{} n; ++i)

\{

std::cout \textless\textless{} n \% i \textless\textless{} std::endl;

if (n \% i == 0)

\{

flag = 1; // flag equals 1 means n not prime

break;

\}

\}

std::cout \textless\textless{} (flag == 0 ? "prime" : "not prime")

\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(Review the ternary operator if you have forgotten about it.)

Go ahead and test your program with a couple of values for n.

Note that \emph{flag} only needs to have two possible values because the
only purpose of \emph{flag} is to tell us why we exit the loop and there
are only two reasons for exiting the for-loop. Although the program
works, the variable \textbf{name} \emph{flag} can be better. The
\textbf{purpose} of \emph{flag} is to tell if \emph{n} is a
\emph{prime}. So ...

I will use a \emph{\textbf{bool}} variable \emph{\textbf{isprime}}
instead. Why boolean? Because this variable only needs to take on
\textbf{two possible values}. Of course if there are three exit points
in the for-loop, then you should not use a boolean variable.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n = 25;

bool isprime = true;

for (int i = 2; i \textless{} n; ++i)

\{

std::cout \textless\textless{} n \% i \textless\textless{} std::endl;

if (n \% i == 0)

\{

isprime = false;

break;

\}

\}

std::cout \textless\textless{} (isprime ? "prime" : "not prime")

\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Let us now remove the print statement in the for-loop:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int n = 25;

bool isprime = true;

for (int i = 2; i \textless{} n; ++i)

\{

if (n \% i == 0)

\{

isprime = false;

break;

\}

\}

std::cout \textless\textless{} (isprime ? "prime" : "not prime")

\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Study the above program very carefully. Make sure you see that the
choice of the name of the variable \emph{isprime} makes the program
easier to understand.

Note that it's possible to remove the \emph{break} statement; study this
program very carefully:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
bool isprime = true;

for (int i = 2; i \textless{} n \&\& isprime; i++)

\{

if (n \% i == 0)

\{

isprime = false;

\}

\}

std::cout \textless\textless{} (isprime ? "prime" : "not prime")

\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Note that the loop keeps running as long as

i \textless{} n \&\& isprime

is \emph{true}. The only way to get out of the for-loop is when the
boolean expression

i \textless{} n \&\& isprime

evaluates to false which is when \emph{i} reaches \emph{n} or when
\emph{isprime} is \emph{false}.

\textbf{Exercise.} Print all the primes from 2 to 100. (Recall that 1 is
not a prime.) The pseudocode is

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for n running from 2 to 100:

if n is prime, print n \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(Don't forget that a C++ int variable can take values up to about 2
billion.) And of course you know how to check ``n is prime'' using the
code I've shown you above. Rework your program so that it prompts the
users for int values for int variables a and b and prints the primes
from a to b. Run your program, listing the primes in the range from
1,000,000,000 to 2,000,000,000. Observe the speed/performance of your
program.

Note that it's obvious that, for instance when you're testing if n = 87
is a prime, you need \textbf{not} test if 86 is a divisor of n = 87. 86
is obviously too big to divide 87!!!

It can be proven that instead of testing i from 2 to n -- 1, you really
only need to test up to the \emph{\textbf{square root of n}}. (I won't
prove this. You can take, for instance, a class on cryptography to find
out why.)

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
bool isprime = true;

for (int i = 2; i \textbf{\textless= sqrt(n)} \&\& isprime; ++i)

\{

if (n \% i == 0)

\{

isprime = false;

\}

\}

std::cout \textless\textless{} (isprime ? "prime" : "not prime")

\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(Don't forget: if you want to use the \emph{sqrt} function, you must add
\emph{\#include \textless cmath\textgreater{}} at the top of your code.
Also don't forget that if you're using MS VS, you might need to convert
the value of \emph{n} to a \emph{double}, i.e. you should use
\emph{sqrt(double(n))} instead of \emph{sqrt(n)}.)

Now, for instance when you test if 1023457 is prime, your program will
run \emph{i} from 2 to 1011 instead of from 2 to 1023456. That's quite a
lot of CPU time saved!!!

\textbf{Exercise.} Redo your earlier primes printing program using this
improved algorithm. Run your program, listing the primes in the range
from 1,000,000,000 to 2,000,000,000. Observe the improved
speed/performance of your program.

But there's still something else you can do. Note that \emph{sqrt(n)} is
computed many times, once every time the boolean expression in the
for-loop is evaluated. We can compute and store the square root of n to
avoid recomputation:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
bool isprime = true;

int sqrtn = sqrt(n);

for (int i = 2; i \textbf{\textless= sqrtn} \&\& isprime; ++i)

\{

if (n \% i == 0)

\{

isprime = false;

\}

\}

std::cout \textless\textless{} (isprime ? "prime" : "not prime")

\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Redo your earlier primes printing program using this
improved algorithm. Run your program, listing the primes in the range
from 1,000,000,000 to 2,000,000,000. Observe the improved
speed/performance of your program.

There's yet another thing we can do. Note that \emph{sqrtn} is used only
in the for-loop. We can actually declare \emph{sqrtn} at the
initialization part of the for-loop so that the scope of \emph{sqrtn}
stays inside the loop:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
bool isprime = true;

for (int i = 2\textbf{, sqrtn = sqrt(n)}; i \textless= sqrtn \&\&
isprime; ++i)

\{

if (n \% i == 0)

\{

isprime = false;

\}

\}

std::cout \textless\textless{} (isprime ? "prime" : "not prime")

\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Note that this does not improve the speed of your program. It simply
shrinks the scope of variable \emph{sqrtn}.

\textbf{Exercise.} Write a program that prompts the user for n and
prints p and p + 2 where p and p + 2 are both primes and at most n. For
instance, if the user entered 20 your program should print

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
1. 3 5

2. 5 7

3. 11 13

4. 17 19\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

For instance, note that 5 and 7 are both primes and 7 is 5 + 2. Note
however that 7 and 9 are not printed since 9 is not a prime. These pairs
of primes are called ``twin primes''. It has been conjectured for more
than 150 years that there are infinitely many twin primes. This is one
of the most famous open questions in Math. The largest known twin primes
(as of 2010) have more than 100000 decimal digits. If you find something
bigger than that let me know. Don't forget that with what you know now,
you can't handle integers significantly larger than 2 billion, i.e. your
int variables can't handle more than 10 digits!!!

\textbf{Exercise.} Write a program that prompts the user for n and
prints the longest chain of consecutive composite integers at most n. A
composite integer is an integer greater than 1 that is not a prime. For
instance, if the user entered 10 for n, then the following are the
numbers from 2 to n with the composites underlined:

2, 3, \emph{4,} 5, \emph{6,} 7, \emph{8, 9, 10}

The longest chain of composites is 8, 9, 10. Therefore your program
should print

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
8 9 10\tabularnewline
\bottomrule
\end{longtable}

Brute force search

Computer Science, like Mathematics, seeks to find solutions to problems.
One way to look for solutions is through ``brute-force'' search. This
means going over all possible candidates and seeing which ones are the
right solutions.

Let's try one. Suppose you want to find \textbf{integer} solution(s) to
this equation:

x\textsuperscript{3} = 729

If x is a negative integer, x\textsuperscript{3} is negative. So we are
definitely only interested in positive integers. Furthermore x must be
less than 729 (well ... a lot less!). So we can try x = 0, 1, 2, ...,
729 and see which one satisfies the above equation.

WHOA!!!

That sure looks suspiciously like a for-loop to me ...

\textbf{Exercise.} Write a for-loop with an index variable running from
0 to 729 to find (and print ... of course!) solution(s) to the equation

x\textsuperscript{3} = 729

Well \ldots{} the above example is kind of silly since we could have
computed the cube root of 729 and see if it's an integer value \ldots{}
but what if you have \emph{\textbf{two}} variables in the equation?
Suppose you want to solve for positive integers x and y satisfying

x\textsuperscript{2} + y\textsuperscript{2 }= 13\textsuperscript{2}

Well first of all each x and y must be at most 13, right? So all you
need to do is to check all possible 0, ..., 13 for x and 0, ..., 13 for
y. In other words you need to check all the following cases:

x = 0, y = 0

x = 0, y = 1

x = 0, y = 2

...

x = 0, y = 13

x = 1, y = 0

x = 1, y = 1

x = 1, y = 2

...

x = 1, y = 13

x = 2, y = 0

x = 2, y = 1

x = 2, y = 2

...

x = 2, y = 13

...

...

...

x = 13, y = 13

That sure looks like a double-nested for-loop to me! Here's the program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int x = 0; x \textless= 13; ++x)

\{

for (int y = 0; y \textless= 13; ++y)

\{

if (x * x + y * y == 13 * 13)

\{

std::cout \textless\textless{} x \textless\textless{} ','
\textless\textless{} y \textless\textless{} '\textbackslash n';\\
\}\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now note that you see some ``repetitions''. I'm saying that if x = a, y
= b is a solution, then x = b, y = a is also a solution because in the
equation above, you can switch x and y. What if you do not want to
include such repetitions? One way would be to ensure x \textless= y. In
other words you try to get your program to run through these values of
x,y:

x = 0, y = 0

x = 0, y = 1

x = 0, y = 2

...

x = 0, y = 13

x = 1, y = 1(note that y starts with 1 and not 0)

x = 1, y = 2

x = 1, y = 3

...

x = 1, y = 13

x = 2, y = 2(note that y starts with 2 and not 0)

x = 2, y = 3

x = 2, y = 4

...

x = 2, y = 13

...

...

...

x = 13, y = 13

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int x = 0; x \textless= 13; ++x)

\{

for (int y = \textbf{x}; y \textless= 13; ++y)

\{

if (x * x + y * y == 13 * 13)

\{

std::cout \textless\textless{} x \textless\textless{} ','
\textless\textless{} y \textless\textless{} '\textbackslash n';\\
\}\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Of course you realize that x\textsuperscript{2} + y\textsuperscript{2 }=
13\textsuperscript{2 }gives the solution of the right-angle triangle
with hypotenuse of length 13 and integer sides. Why not find all such
triangles with hypotenuse from 1 to 100??? This means solving

x\textsuperscript{2} + y\textsuperscript{2 }= z\textsuperscript{2}

where 1 \textless= z \textless= 100.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
for (int z = 1; z \textless= 100; ++z)

\{

for (int x = 0; x \textless= z; ++x)

\{

for (int y = x; y \textless= z; ++y)

\{

if (x * x + y * y == z * z)

\{

std::cout \textless\textless{} x \textless\textless{} ','
\textless\textless{} y \textless\textless{} ','

\textless\textless{} z \textless\textless{} '\textbackslash n';\\
\}\\
\}\\
\}

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

This prints the sides of all right angle triangles with integer sides
where the hypotenuse is between 1 to 100.

\textbf{Exercise.} Can you improve the performance of the above program?

Exercise. Find all integer solutions to the equation

x\textsuperscript{4} + 2y\textsuperscript{4} = 10001

\textbf{Exercise. }Here's something from wikipedia.org:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\textbf{1729} is known as the \textbf{Hardy-Ramanujan number}, after a
famous anecdote of the British mathematician
\href{http://en.wikipedia.org/wiki/G._H._Hardy}{G. H. Hardy} regarding a
hospital visit to the Indian mathematician
\href{http://en.wikipedia.org/wiki/Srinivasa_Ramanujan}{Srinivasa
Ramanujan}. In Hardy's words:

`` I remember once going to see him when he was ill at
\href{http://en.wikipedia.org/wiki/Putney}{Putney}. I had ridden in taxi
cab number 1729 and remarked that the number seemed to me rather a dull
one, and that I hoped it was not an unfavorable
\href{http://en.wikipedia.org/wiki/Omen}{omen}. "No," he replied, "it is
a very interesting number; \textbf{it is the smallest number expressible
as the sum of two cubes in two different ways}."

The quotation is sometimes expressed using the term "positive cubes", as
the admission of negative perfect cubes (the cube of a
\href{http://en.wikipedia.org/wiki/Negative_and_non-negative_numbers}{negative}
\href{http://en.wikipedia.org/wiki/Integer}{integer}) gives the smallest
solution as \href{http://en.wikipedia.org/wiki/91_\%28number\%29}{91}
(which is a factor of 1729):

91 = 6\textsuperscript{3} + (5)\textsuperscript{3} =
4\textsuperscript{3} + 3\textsuperscript{3}

Of course, equating "smallest" with "most negative", as opposed to
"closest to zero" gives rise to solutions like 91, 189, 1729, and
further negative numbers. This ambiguity is eliminated by the term
"positive cubes".

Numbers such as

1729 = 1\textsuperscript{3} + 12\textsuperscript{3} =
9\textsuperscript{3} + 10\textsuperscript{3}

that are the smallest number that can be expressed as the sum of two
cubes in \emph{n} distinct ways have been dubbed
\href{http://en.wikipedia.org/wiki/Taxicab_number}{taxicab numbers}.
1729 is the second taxicab number (the first is 2 = 1\textsuperscript{3}
+ 1\textsuperscript{3}). The number was also found in one of Ramanujan's
notebooks dated years before the incident.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Find all positive integer solutions to the equation

x\textsuperscript{3} + y\textsuperscript{3} = 1729

(Hint: Write a double for-loop.)

\textbf{Exercise.} The above exercise verified that there are exactly
two integer solutions. It does not verify that 1729 is the
``\textbf{smallest number expressible as the sum of two cubes in two
different ways}''. To do that you need to solve this:

x\textsuperscript{3} + y\textsuperscript{3} = z

Of course you should print out x, y, and z. Look at all the solutions
and find the value of z with exactly two integer solutions. Is it 1729?
(Or is Ramanujan totally wrong all these years ...)

Exercise. Write a program that prints all positive fractions m/n from 0
to 5 where m and n are positive and at most 10. The fractions need not
be reduced or in any particular order or unique.

Brute force search: polynomial factorization

Here's another brute force search program. Let's write a program to
factorize a degree 2 polynomial into two polynomials with integer
coefficients. For instance

x\textsuperscript{2} -- 1 = (x + 1)(x -- 1)

Therefore when the user enters 1 0 -1 for polynomial
x\textsuperscript{2} -- 1, the program produces (x + 1)(x -- 1). Here's
an execution of the program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
1 0 -1

1x\^{}2 + 0x + -1 = (1x + 1)(1x + -1)\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Assume that your program will only handle coefficients from -20 to 20.

We know that

(ax + b)(cx + d) = acx\textsuperscript{2} + (ad + bc)x + bd

Suppose the user entered A, B, C for polynomial

Ax\textsuperscript{2} + Bx + C

then we basically want to find a, b, c, d such that

(ax + b)(cx + d) = acx\textsuperscript{2} + (ad + bc)x + bd =
Ax\textsuperscript{2} + Bx + C

which is the same as saying:

A = ac

B = ad + bc

C = bd

For instance in the case of the polynomial x\textsuperscript{2} -- 1, we
want to find a, b, c, d such that

1 = a * c

0 = a * d + b * c

-1 = b * d

Here's the program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int A, B, C;

std::cin \textgreater\textgreater{} A \textgreater\textgreater{} B
\textgreater\textgreater{} C;

int a, b, c, d;

bool found = false;

for (a = -20; a \textless= 20 \&\& !found; ++a)

\{

for (b = -20; b \textless= 20 \&\& !found; ++b)

\{

for (c = -20; c \textless= 20 \&\& !found; ++c)

\{

for (d = -20; d \textless= 20 \&\& !found; ++d)

\{

if (a * c == A

\&\& B == a * d + b * c

\&\& b * d == C)

\{

found = true;

\}

\}

\}

\}

\}

if (found)

\{

std::cout \textless\textless{} a \textless\textless{} ' '
\textless\textless{} b \textless\textless{} ' '

\textless\textless{} c \textless\textless{} ' ' \textless\textless{} d
\textless\textless{} '\textbackslash n'; \\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Of course you can change the range of values for a, b, c, d if you like.
In fact, it's a good idea to create a constant, say N, for 20 in the
above program so that a, b, c, d ranges from -N to N and you can change
the value of N easily.

Note that this is a \textbf{brute force} search for a factorization of
the given polynomial because it's \textbf{not smart}. For instance, if
the given polynomial is

15x\textsuperscript{2} + \ldots{}

then since you want

15x\textsuperscript{2} + \ldots{} = (ax + b)(cx + d) = acx\^{}2 + (ad +
bc)x + bd

then of course

15 = ac

and the right thing to do is to factorize 15. You would get 15 = 1x15 =
3x5 = 5x3 = 15x1 = -1x-15 = -3x-5 = -5x-3 and then a and c can only be

a = 1, c = 15

a = 3, c = 5

a = 5, c = 3

a = 15, c = 1

a = -1, c = -15

a = -3, c = -5

a = -5, c = -3

a = -15, c = -1

The above program however tries 41 possible values for a (i.e., from -20
to 20) and also 41 possible values for c. This means that the program
actually tries 41 x 41 possible cases for a and c. Including b and d,
the program tries

41 x 41 x 41 x 41 = 2825761

cases!!! This is no big deal for a modern-day computer of course. But if
we want to allow more values for a, b, c, d, say from -100 to 100, then
there are about

201 x 201 x 201 x 201 = 1632240801

You can try this range of values for the above program. You'll see that
the program will run very slowly. Brute force algorithms are not smart
at all.

\textbf{Exercise.} Write a program that prompts the user for n and if n
is even, attempts to rewrite n as a sum of at most two primes. For
instance if the user entered 2, the program prints:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
2

2\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

If the user entered 4 the program prints

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
4

2 + 2\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

If the user entered 12, the program prints

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
12

5 + 7\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Using your program, attempt to answer this question: Are there even
integers which are not a sum of at most two primes? (For more
information, google for ``Goldbach conjecture''. This is also a very
famous conjecture in Math that is as yet unproven.)

Summary

The following summarizes the pre- and post-increment operators:

\emph{++i}increments the value of \emph{i}

\emph{i++}increments the value of \emph{i}

\emph{j = (++i)}increments the value of i and then assign new value of
\emph{i} to \emph{j}

\emph{j = (i++)}give the value of \emph{i} to \emph{j} and then
increments the value of \emph{I\\
}

The following summarizes the pre- and post-decrement operators

\emph{-\/-i}decrements the value of \emph{i}

\emph{i-\/-}decrements the value of \emph{i}

\emph{j = (-\/-i)}decrements the value of i and then assign new value of
\emph{i} to \emph{j}

\emph{j = (i-\/-)}give the value of \emph{i} to \emph{j} and then
decrements the value of \emph{i}

The following summarizes the augmented assignment operators: suppose
\emph{{[}op{]}} is an operator such as +, -, *, /, \%, then

\emph{x {[}op{]}= y }is the same as\emph{x = x {[}op{]} y}

For instance x += y is the same as x = x + y. The augmented assignment
operator returns the new augmented value. For instance:

\emph{z = (x += y)}

The for-loop statement looks like this:

for (\emph{{[}stmt1{]}}; \emph{{[}bool expr{]}}; \emph{{[}stmt2{]}})

\emph{{[}stmt3{]}}

where \emph{{[}stmt3{]}} can be either a statement of a block of
statements. The for-loop statement executes as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Execute \emph{{[}stmt1{]}}, go to 2.
\item
  If the \emph{{[}bool expr{]}} is true, go to 3, otherwise goto 5
\item
  Execute \emph{{[}stmt3{]}}, go to 4.
\item
  Execute \emph{{[}stmt2{]}}, go to 2.
\item
  Exit the for-loop statement to the statement after the for-loop.
\end{enumerate}

Of course since \emph{{[}stmt3{]}} can be any statement or a block, a
for-loop can contain an if statement, if-else statement, a switch-case
statement, or even a for-loop.

The scope of a variable is from its point of declaration to the end of
the smallest block where it was declared.

Exercises

Q1. Find all positive integer solutions to the equation

x\textsuperscript{3} + y\textsuperscript{4} = 1729

(Hint: Write a double for-loop.)

Q2. Write a program that draws the following figure when the user enters
3

*

**

***

and when the user enters 4 it draws

*

**

***

****

Q3. Write a program that draws the following figure when the user enters
3

*

**

***

and this when the user enters 5

*

**

***

****

*****

and this when the user enters 6

*

**

***

****

******

*******

Q4. Write a program that draws the following figure when the user enters
3

***

* *

***

and when the user enters 5 it draws

*****

* *

* * *

* *

*****

and when the user enters 7 the program draws this:

*******

* *

* *** *

* * * *

* *** *

* *

*******

and when the user enters 9 the program draws this:

*********

* *

* ***** *

* * * *

* * * * *

* * * *

* ***** *

* *

*********

Etc.

Q5. Write a program that draws the following figure when the user enters
3

+

/ \textbackslash{}

\textbar{} \textbar{}

-\/-\/-

and when the user enters 5 it draws

+

\textbar{}

/ \textbackslash{}

/ \textbackslash{}

\textbar{} \textbar{}

\textbar{} \textbar{}

-\/-\/-\/-\/-

and when the user enters 7 the program draws this:

+

\textbar{}

\textbar{}

/ \textbackslash{}

/ \textbackslash{}

/ \textbackslash{}

\textbar{} \textbar{}

\textbar{} \textbar{}

\textbar{} \textbar{}

-\/-\/-\/-\/-\/-\/-

Etc.

Q6. Write a program that draws the following figure when the user enters
7 it draws

** **

*******

*******

*****

***

*

and when the user enters 9 it draws

*** ***

*********

*********

*******

*****

***

*

and when the user enters 11 it draws

**** ****

***********

***********

*********

*******

*****

***

*

Q7. Write a program that draws the following given 2 and 2:

**********

* *

* X *

* *

* *

* *

* *

* *

* *

**********

and this when the user enters 7 and 3:

**********

* *

* *

* *

* *

* *

* *

* X *

* *

**********

Q8. Write a program that prompts the user for n and computes

1 + 1/(1) + 1/(1x2) + 1/(1x2x3) + 1/(1x2x3x4) + \ldots{} +
1/(1x2x3x...xn)

Q9. Write a program that prompts the user for a double d and computes
the largest n such that n\textsuperscript{2} + n is at most d.

Q10. Write a program that prompts the user for an integer n and displays
all the non-squares from 1 to n and print the number of these integers.
(An integer is a non-square if it is not the square of another integer.
For instance 9 is a square since it is the square of 3, however 6 is not
a square.)

Q11. A number n is said to be perfect if it is the sum of all its
divisors less then n. For instance 6 is perfect since the divisors of 6
are 1, 2, 3, 6 and the sum of the divisors less than 6 is 1 + 2 + 3 = 6.
Write a program that prompts the user for n and prints all perfect
numbers from 1 to n.

\end{document}
