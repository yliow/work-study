% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\author{}
\date{}

\begin{document}

01. Print Statements and C-Strings

Objectives

\begin{itemize}
\tightlist
\item
  Print strings and characters using \emph{std::cout}
\item
  Use the \emph{\textbackslash n,} \emph{\textbackslash t,
  \textbackslash", \textbackslash', \textbackslash\textbackslash{}}
  characters
\item
  Use \emph{std::endl} to force newline
\item
  Write multiple print statements
\end{itemize}

In this set of notes, we learn to print strings and characters.

A quick advice to ease the pain of learning your first programming
language: Type the program \textbf{exactly} as given. Even your spaces
and blank lines must match the spaces and blank lines in my programs.

Let's begin ...

Hello world

Go ahead and run your first program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

... commercial break ... go to notes on software tool(s) for writing and
running a program ...

Now let's go back to the C++ code. Right now, you should think of the
stuff in bold as the program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Therefore you can treat this as a template:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

I will not explain things like ``\emph{\#include
\textless iostream\textgreater{}}'' or ``\emph{int main()}'' until
later. (Technically, they \emph{are} also part of the program.)

Try this

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that prints the following:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
hello columbia\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that gets the computer to greet you:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
hello dr. liow, my name is c++.\tabularnewline
\bottomrule
\end{longtable}

(replace my name with yours ... you're probably not ``dr. liow'').

Exercise. Debug (i.e., correct) this program by hand and then verify by
running it with your C++ compiler.

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Statement

Here's the first jargon. Look at our program again:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The line in bold is a \textbf{statement}. In C++, statements must
terminate with a \textbf{semi-colon}. Note that the semi-colon
\emph{\textbf{is}} part of the statement.

At this point you should think of a statement as something that will
cause your computer to perform some operation(s) when you run the
program.

If you like, you can think of a statement as a sentence and the
semicolon as a period. When you're told to write a C++ statement, don't
forget the semicolon!!! That would be like writing a sentence without a
period (or question mark or exclamation mark) in an english essay.

\textbf{Exercise.} Modify your program by removing the first semicolon
to get this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run it. Does it work? Fix it. Test to make sure it works (that means:
run the program.)

\textbf{Exercise.} Replace the semicolons by periods.

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run it. Does it work? Fix it.

See what I mean by this advice:

A quick advice to ease the pain of learning your first programming
language: Type the program \textbf{exactly} as given. Even the spaces
and blank lines must match my programs.

Computers are dumb (and picky about details.) We are the smart ones. So
\ldots{} when you communicate with your computer, you have to be exact
and explicit in your programs.

\textbf{Exercise.} Now write a program that prints any message (example:
``do you want green eggs and ham?'') ... close your notes first. Peek at
your notes only when you have problems.

C-strings

The stuff in quotes is called a \textbf{C-string} or just a
\textbf{string}:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

You can think of a string as textual data. (Soon I'll talk about numeric
data for numeric computations. Got to have that for computer games,
right?)

Double quotes are used to mark the beginning and ending of the string.
So technically they are \emph{\textbf{not}} part of the string. That's
why when you run the above program, you do not see double-quotes.

\textbf{Exercise.} Does it work without the double-quotes?

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

In the string \emph{"Hello, world!\textbackslash n"}, \emph{H} is a
\textbf{character}. The next character is \emph{e}. Etc. When we talk
about characters we enclose them with single-quotes. So I should say
character \emph{'H'} rather than \emph{H} or \emph{"H"}. You can think
of the character as the smallest unit of data in a string.

The string \emph{"Hello, world!\textbackslash n"} contains characters
\emph{'H'} and \emph{'e'} and \emph{'l'} and \emph{'l'} and \ldots{}
However a character such as \emph{'H'} can contain one and only one unit
of textual data. So you \emph{\textbf{cannot}} say that \emph{'Hello'}
is a character.\emph{ }

Note that a string can contain as many characters as you like: 10, 20,
50, 100, etc. There's actually a limit, but we won't be playing around
with a string with 1,000,000 characters anyway for now -- that would be
a pain to type!!! Note that a string can contain no characters at all:
\emph{""}. Of course a string can contain exactly one character. For
instance, here's a string with one character:\emph{ "H"}.

Note that \emph{"H"} is a string with one character whereas \emph{'H'}
is a character. You just have to look at what quotes are used to tell if
the thingy is a string or a character. That's all.

\textbf{Exercise.} Does it work with single-quotes?

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

\textbf{Exercise.} Can you also print characters?? (You did think about
this, right?) Try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

\textbf{Exercise.} Which of the following is a string, a character, or
neither:

\emph{"I"}

like

\emph{'green'}

\{eggs\}

\emph{"and"}

\emph{'ham'}

'.'

Case sensitivity

Is C++ case sensitive?

\textbf{Exercise.} Modify your program by changing \emph{std} to
\emph{Std}:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run it. Does it work? Fix it.

\textbf{Exercise.} Modify your program by changing \emph{return} to
\emph{RETURN}:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Does it work? Fix it.

Now answer this question:

Is C++ case sensitive? (Circle one) YES NO

(duh ... I'm not taking answers in class.)

Whitespaces

A whitespace is ... well \ldots{} a white space.

Spaces, tabs, and newlines are whitespaces.

\textbf{Exercise.} Modify your program by inserting some spaces:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Does it work?

\textbf{Exercise.} Modify your program by inserting some newlines:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

In general you can insert whitespaces between ``basic words'' understood
by C++. These ``basic words'' are called \textbf{tokens}. (Oooooo
another big word.)

If you think of statements as sentences, semi-colons as periods, then
you can think of tokens as words.

For instance the following are some tokens from the above program:
\emph{int}, \emph{return} and even \emph{\{}.

We say that C++ \textbf{ignores whitespace.}

\textbf{Exercise.} Try this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

std :: cout \textless\textless{} "Hello,
world!\textbackslash n"\textbf{;}

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

std: :cout \textless\textless{} "Hello,
world!\textbackslash n"\textbf{;}

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Does it work?

This shows you that \emph{::} is a token -- you cannot break it down.

\textbf{Exercise.} Try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Does it work?

Try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The whitespaces between tokens are removed when your computer runs your
C++ program. So, to the computer, it doesn't matter how many whitespaces
you insert between tokens -- it still works.

However spaces in a \emph{\textbf{string}} are \emph{\textbf{not}}
removed before the program runs. The space characters \emph{' '} (there
are 10 in the above string) are actually characters within the string.

Note that although you can insert whitespaces, in general, good spacing
of a program makes it easier to read. Therefore you must follow the
style of spacing shown in my notes. In particular, I \textbf{don't} want
to see monstrous programs like this (although the program does work):

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

or this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And don't try to be cute this like ...

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The above examples are excellent candidates for the F grade. The correct
coding style produces this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The left trailing spaces of a statement is called the indentation of the
statement:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

It's a common programming style to use 4 spaces for indentation.

Special characters

Hmmmm ... you don't see the \emph{\textbackslash n} printed out. In fact
\ldots{} what's it for???

Try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And this

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And finally this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

So you can think of the print cursor as jumping to the next line
whenever a \emph{\textbackslash n} is encountered.

As a matter of fact you cannot separate the \emph{\textbackslash{}} from
the \emph{n}. \emph{\textbackslash n} is consider \emph{\textbf{one}}
single character. So technically I should write
\emph{'\textbackslash n'}. \emph{'\textbackslash n'} is called the
\textbf{newline character}.

\textbf{Exercise.} Write a program that prints this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The \emph{'\textbackslash t'} move the print cursor to the next tab
position. \emph{'\textbackslash t'} is also a character. It's called the
\textbf{tab character}. You should not use the tab character. There are
better ways to use the tab character to create a tabulation of data.

Special characters like the above (the newline and the tab characters)
are not printable and so we have to use some special notation to say
``the newline character'' or the ``the tab character''. Computer
scientists decided (long time ago) to use \textbackslash{} to indicate a
special character. These are called \textbf{escape characters}.

Now recall that \emph{"} is used to mark the beginning and end of a
string. What if you want to print something like this:

.....".....

Try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Doesn't work right? Do you see why?

Now try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

So in a string, \emph{\textbackslash"} will let you print \emph{"}.

\emph{'\textbackslash"'} is actually a character.\emph{ }There are two
\emph{'\textbackslash"'} characters in the above string \emph{"He
shouted, \textbackslash"42!\textbackslash"\textbackslash n"}.

\textbf{Exercise.} Write a program that prints this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
She said, \emph{"}I would rather marry a pig.\emph{"}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that prints this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
Here's a standard formula:

2 2 2

(x + y) = x + 2xy + y\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

There are two \emph{' '} characters on each side of the \emph{'='}
character.

\textbf{Exercise.} Write a program that prints this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
d 3 2

-\/- x = 3x

dx\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} How would you print the character '. Let me tell you
that

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
std::cout \textless\textless{} ''';\tabularnewline
\bottomrule
\end{longtable}

won't work.

Exercise. Write a program that print the backslash character, i.e.
\textbackslash.

Exercise. Write a program that prints this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
He said, "I am! I'm a pig! Really!"\tabularnewline
\bottomrule
\end{longtable}

Exercise. Write a program that prints this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
Get the Gold!

+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-+

\textbar{} \textbar{}

\textbar{} -\/-\/-\/-\/-\/-\/-\/-+ \textbar{} \textbar{}

\textbar{} \textbar{} \textbar{} \textbar{}

\textbar{} +-\/-\/-+ \textbar{} \textbar{} \textbar{} \textbar{}

\textbar{} \textbar G \textbar{} \textbar{} \textbar{} \textbar{}

\textbar{} +-+ +-+ \textbar{} \textbar{} \textbar{}

\textbar{} \textbar{} \textbar{} \textbar{} \textbar{}

\textbar{} \textbar{} +-\/-\/-\/-\/-+-+ \textbar{}

\textbar{} \textless-\/-\/-

+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-+\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Exercise. Write a program that prints this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

std::cout \textless\textless{} "Hello, world!\textbackslash n"\textbf{;}

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The number of characters is a string is called length of the string. For
instance the string

"Hello, world!\textbackslash n"

has a length of 14 and not 15.

Exercise.

What is the number of characters (i.e., the length) of the following
strings?

(a) \emph{"columbia"}

(b) \emph{""}

(c) \emph{"columbia,mo"}

(d) \emph{"columbia, mo"}

(e) \emph{"ma ma mia!"}

(f) \emph{"ma ma mia!\textbackslash n"}

(g)
\emph{"ma\textbackslash tma\textbackslash tmia!\textbackslash n\textbackslash n"}

(You'll see much later that in every string, there's actually an extra
secret character. This is however not included in the count of the
length of the string. Don't worry about this for now. I will be coming
back to this later.)

Printing more than one string or character

Try this

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

By the way you should try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

"" is an \textbf{empty string} (also called a \textbf{null string}):
it's a string with no characters.

\textbf{Exercise.} The output of the following program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

is

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

True or false? (Verify with your C++ compiler.)

\textbf{Exercise.} The output of the following program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

is

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

True or false? (Verify with your C++ compiler.)

Of course you can also print multiple characters. Try this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Here's a tiring hello world program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

You can also mix printing strings and characters in a single statement:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Another way to go to the next line

Let's go back to our hello world program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run yours and make sure there are no errors.

First let's make a separate string out of the newline character:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run it and make sure the effect is still the same.

Now do this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run it.

The \emph{std::endl} acts like a newline character. It's actually more
than that. We'll talk about this when we talk about files. Anyway for
the time being just remember that \emph{std::endl} forces a newline when
you print it.

\textbf{Exercise.} Read this program and, without running it, write down
the output in the grid provided below. Once you're done writing down the
output, run the program and verify that you output from reading the
program matches the output you get when running the program.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

std::cout \textless\textless{} "Lives: 3" \textless\textless{} std::endl

\textless\textless{} "Energy: 15000" \textless\textless{} std::endl

\textless\textless{} "Score: 0" \textless\textless{} std::endl;

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Output (one per character):

\begin{longtable}[]{@{}llllllllllllllllllll@{}}
\toprule
\endhead
& & & & & & & & & & & & & & & & & & &\tabularnewline
& & & & & & & & & & & & & & & & & & &\tabularnewline
& & & & & & & & & & & & & & & & & & &\tabularnewline
& & & & & & & & & & & & & & & & & & &\tabularnewline
& & & & & & & & & & & & & & & & & & &\tabularnewline
\bottomrule
\end{longtable}

Multiple statements

Exercise. Run this program

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

This tells you that you can have \textbf{more than one statement} in
your program. (Actually the \emph{return 0;} is also a statement, but
we'll ignore that for now.)

Furthermore C++ executes from \textbf{top to bottom} (at least right
now!)

\textbf{Exercise.} The following program has three print statements:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run it. Rewrite it so that it has only one print statement.

\textbf{Exercise.} True or False? The output of this program (when you
run it of course)

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

is

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

\textbf{Exercise.} Continuing with the previous program, rewrite it so
that each sentence is printed on a separate line; use only one
statement.

The \emph{using namespace std} business

Instead of our hello world program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

in many books you will see this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

All the

\emph{using namespace std;}

does is that after it, instead of

\emph{std::cout}

you can write

\emph{cout}

i.e. without the

\emph{std::}

That's all. I'll talk about ``namespaces'' later (actually much much
much later \ldots{} in CISS245). So don't worry too much about it.

Exercise. Does the following program work?

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

using namespace std;

int main()

\{

cout \textless\textless{} "Hello, world!" \textless\textless{} endl;

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

So not only can you replace \emph{std::cout} with \emph{cout} after
doing the

\emph{using namespace std;}

you can also replace \emph{std::endl} with \emph{endl}.

Summary

A \textbf{statement} is something that will cause your computer to
perform some operation(s). In C++ statements must terminate with a
\textbf{semi-colon}.

C++ is \textbf{case-sensitive}.

C++ \textbf{ignores whitespace} (between tokens).

Something that looks like \emph{"Hello, World!\textbackslash n"} (i.e.
characters within double quotes) is called a \textbf{string} or a
\textbf{C-string.}

A string is either empty (the null string), i.e. \emph{""}, or it is
made up of characters. For instance the first character of the string
\emph{"Hello, World!\textbackslash n"} is \emph{'H'}.

There are special characters: \emph{'\textbackslash n'} causes the
cursor to jump to a new line while \emph{'\textbackslash t'} moves to
the next tab position, \emph{'\textbackslash"'} is the double-quote
character, and \emph{'\textbackslash''} is the single-quote character.
The backslash character is \emph{'\textbackslash\textbackslash'}. These
are called \textbf{escape characters}.

To print a string, you execute the following statement:

std::cout \textless\textless{} \emph{{[}some string{]}};

You can print more than one string in a single print statement:

std::cout \textless\textless{} \emph{{[}string1{]}} \textless\textless{}
\emph{{[}string2{]}}

\textless\textless{} {[}string3{]} \textless\textless{} {[}string4{]};

Printing one or more characters is the same:

std::cout \textless\textless{} \emph{{[}some character{]}};

std::cout \textless\textless{} \emph{{[}character1{]}}
\textless\textless{} \emph{{[}character2{]}}

\textless\textless{} {[}character3{]} \textless\textless{}
{[}character4{]};

You can mix print strings and characters. For instance

std::cout \textless\textless{} \emph{{[}some character{]}}

\textless\textless{} {[}some string{]};

or

std::cout \textless\textless{} \emph{{[}some string{]}}

\textless\textless{} {[}some character{]};

You can force a newline by printing \emph{std::endl}:

std::cout \textless\textless{} std::endl;

If your program has two or more statements like this:

\emph{{[}statement 1{]}};

\emph{{[}statement 2{]}};

\emph{{[}statement 3{]}};

then C++ executes top to bottom (for now).

Exercises

1. Write a C++ program that produces the following output:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Use one print statement.

2. True or false: The output of

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

is

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Verify with your C++ compiler.

3. Find all the errors in this program (without using the C++ compiler):

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The expected output is

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

When you're done, verify your correction with your C++ compiler. If your
program does not compile, continue correcting the program until the
program is error-free and runs correctly.

4. Will this program get an A from the instructor?

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Why? What about this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

5. What is the length of the following string:

"Ablee, \textbackslash tAblee, \textbackslash tAblee,
\textbackslash t... That's all folks!!!\textbackslash n"

6. A string with length 0 is called an empty string or a \_\_\_\_\_
string.

7. All C++ statements must end with a
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_.

8. Write the shortest program that produces the following output:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
8 5 3

+ 3 8 2

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

1 2 3 5

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\end{document}
