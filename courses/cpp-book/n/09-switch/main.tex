% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\author{}
\date{}

\begin{document}

09. switch

Objectives

\begin{itemize}
\tightlist
\item
  Write switch statements
\item
  Write switch statements where cases do not have breaks
\item
  Write switch statements where the default case is missing
\end{itemize}

The if and if-else statements allow us to decide if we want to execute a
statement. It allows us to write programs that can make decisions. There
is another way of doing that.

This is the switch statement.

Diagram of flow of execution of\emph{ if} statements

Here's the big picture for if.

Before the if statement, the code in main executes one statement at a
time. For example:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

int x = 1;

int y = 2;

int z = x * y + 3;

Now with the if statement we have:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

int x = 1;

int y = 2;

if (x + y \textless{} 10)

true

y = 0;

false

x = 3;

Of course it's just as easy to visualize the flow of execution for
if-else. If you have:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

then

int x = 1;

int y = 2;

if (x + y \textless{} 10)

true

y = 0;

else

false

y = 1;

x = 3;

Note that the path of execution is determined by the \textbf{boolean
value} of a boolean expression.

switch

Now I'll show you something that's very similar to the if and if-else
statement. Watch out! There are \textbf{subtle differences} ....

OK. First run this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run this with x = 0, x = 1, x = 2, x = 3, x = 4. No surprises right?

Note that all the conditions uses the == boolean operator and it is used
to compare integer values.

Modify the above:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run it again.

The \emph{switch} statement is like a switchboard, directing the flow of
execution based on the integer value of a variable. The flow of
execution is passed to the case whose value matches the value of the
variable.

Now modify it again by getting rid of the \emph{break} statement in case
2:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

What does the \emph{break} statement do? If you do \textbf{not} have a
\emph{break} statement, execution will actually \textbf{go to the
statements of the next case without checking the value for that case!!!}

There are \textbf{two} ways to get \textbf{out} of a \emph{switch}:
either through a \emph{\textbf{break}} statement or when execution has
reached the \textbf{end of the }\emph{\textbf{switch}}\textbf{ block}.

By now, I don't have to tell you that you can put any statement in the
switch statement. You can put an if or an if-else into the switch. You
can put a switch into a switch. You can put a switch into an if-else,
etc. Isn't life ever so colorful?

Why? Why? Why?

So why do we need the switch when it's clear that a switch can be
written as a nested if-else?

The reason is because the switch statement is extremely fast when there
are many cases when compared to the if-else statement.

Note that for a nested if statement:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

each time a boolean condition is false you have to go to the nested
level in the if-else stack. This means that for instance to go into the
final else block, C++ must evaluate three boolean expressions.

(One optimization trick used by C/C++ programmers is therefore to always
put the most likely case first in the stack of if-else statements.)

This is however not the case for the switch statement. If the above is
converted to the switch statement, the time taken to get to any case is
the same. Even if you have 100 cases, the time to get to the first case
is usually the same as the time to get to the last.

Combining cases

Now run this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The above is a useful trick when two cases execute the same statements.
The above has the same effect as the following (although the following
is probably slower):

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

One more example to make sure you get it:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run it with several values for \emph{x}.

No default

You can leave out the default case:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Run this with several values for x including for instance x = 0 and x =
100.

Gotchas

Here are some gotchas ... and good source of trick questions for the
instructor :)

Each of the following exercises shows you a gotcha for beginning C/C++
programmer. Make sure you find it.

Exercise. Find the bug:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Exercise. Find the bug:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Exercise. Bug, bug, bug! Find it! ...

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Exercise. Where's that sneaky bug??

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

\textbf{Exercise.} Recall that a character is the ``atom'' of a string.
The name of the character type is \emph{char}. You can declare character
variables, get character values from the keyboard, and print the
character value of a character variable. Try this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
char x = ' ';

std::cin \textgreater\textgreater{} x;

std::cout \textless\textless{} x \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now here's the question: Can you use characters for the cases?

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x, y;

char op;

std::cout \textless\textless{} "x: ";

std::cin \textgreater\textgreater{} x;

std::cout \textless\textless{} "y: ";

std::cin \textgreater\textgreater{} y;

std::cout \textless\textless{} "operator (+ or -): ";

std::cin \textgreater\textgreater{} op;

switch (op)

\{

case '+':

std::cout \textless\textless{} x + y \textless\textless{} std::endl;

break;

case '-':

std::cout \textless\textless{} x - y \textless\textless{} std::endl;

break;

default:

std::cout \textless\textless{} "no such op!" \textless\textless{}
std::endl;

break;

\}

std::cout \textless\textless{} "out of switch" \textless\textless{}
std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Add all the binary integer operators you know so far to the above
program.

Coding style

Good::

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

This is also perfectly OK: :

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

More information

Actually you can use the value of an \textbf{integer expression} and not
just a variable to determine the flow of execution:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

And although you cannot use variables for the case values, you can use
\textbf{integer constants} or even \textbf{constant integer
expressions:}

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Summary

The statement looks like this:

switch (\emph{{[}int expr{]}})

\{

case \emph{{[}const int expr{]}}:

\emph{ {[}stmt{]}}

...\\
\}

or

switch (\emph{{[}int expr{]}})

\{

case \emph{{[}const int expr{]}}:

\emph{ {[}stmt{]}}

...

default:

\emph{ {[}stmt2{]}}\\
\}

where \emph{{[}stmt{]}} and \emph{{[}stmt2{]}} are either statements or
blocks of statements. \emph{{[}int expr{]}} is an expression that can be
evaluated to an integer and \emph{{[}const int expr{]}} is a constant
integer expression.

Once the flow of execution enters a case, it will execute all the
statements in that case until a break or end of switch block is reached.
If there is no break, execution will continue with the statements of the
next case without checking the value for that case, if there is one.

On executing the \emph{break} statement in a \emph{switch} statement,
flow of control will resume to the statement immediately after the
\emph{switch} statement.

Exercise.

Q1. Read this program carefully. Determine which part of the program can
be rewritten using the switch statement. Rewrite it and test it.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int numHeads = 0;

std::cout \textless\textless{} "How many heads do you have? ";

std::cin \textgreater\textgreater{} numHeads;

if (numHeads \textless{} 1)

\{

std::cout \textless\textless{} "Huh?" \textless\textless{} std::endl;

\}

else

\{

if (numHeads == 1)

\{

std::cout \textless\textless{} "Let me introduce you to our "

\textless\textless{} "surgeons." \textless\textless{} std::endl;

\}

else

\{

if (numHeads == 2)

\{

std::cout \textless\textless{} "Are you Zaphod?";

\}

else

\{

std::cout \textless\textless{} "You have way too many."

\textless\textless{} std::endl;

\}

\}

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Q2. Rewrite the nested if-else statement using the switch statement:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 0;

std::cin \textgreater\textgreater{} x;

int y = 0;

if (x == 0)

\{

y = 5;\\
\}

else if (x == 1 \textbar\textbar{} x == 2 \textbar\textbar{} x == 3)

\{

y = 7;\\
\}

else if (x == 6 \textbar\textbar{} x == 7 \textbar\textbar{} x = 42)

\{

y = 0;\\
\}

std::cout \textless\textless{} y \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Avoid code duplication!

Q3. Write a program that declares four integer constants N, S, E, W.
with values 0, 1, 2, 3 respectively. Generates a random integer from 0
to 3. If the random integer is N, print ``go north''. If the random
integer is S, print ``go south''. If the random integer is E, print ``go
east''. If the random integer is W, print ``go west''. Use a
\emph{switch} statement.

\end{document}
