% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\author{}
\date{}

\begin{document}

Objectives

\begin{itemize}
\tightlist
\item
  Write function prototypes
\item
  Write header files and build a multifile project
\end{itemize}

Function Prototypes

\textbf{Exercise.} What's wrong with the program. You have 2 seconds.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

f(1);

return 0;

\}

void f(int x)

\{

std::cout \textless\textless{} x \textless\textless{} std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Correct it. Verify with C++.

Now try this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

void f(int);

int main()

\{

f(1);

return 0;

\}

void f(int x)

\{

std::cout \textless\textless{} x \textless\textless{} std::endl;

return;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

A \textbf{function prototype} basically tells C++ that the function does
exist. The information contained in a function prototype includes:

\begin{itemize}
\tightlist
\item
  \textbf{name} of the function
\item
  the \textbf{return type} and
\item
  the \textbf{types of the parameters}.
\end{itemize}

The function prototype is the minimal amount of information needed to
get your C++ compiler to work with your C++ file.

Why?

Well C++ needs to compile \emph{main()} to work which means from the
side of \emph{main()}, the \emph{main()} function needs to know what to
push onto the stack to communication with \emph{f()} and also what value
(if any) is expected from the return of calling \emph{f()}. As far as
\emph{main()} is concerned, all \emph{main()} needs is the
``communication infrastructure'' of \emph{f()}. \emph{main()} doesn't
need to know how \emph{f()} carries out its duty. We'll come back to
this again later.

The format of a function prototype is exactly the same as the header of
a function except for the following:

\begin{itemize}
\tightlist
\item
  a function prototype must end with a semicolon
\item
  the parameter names can be left out. (You can retain them if you
  wish).
\end{itemize}

Here's another example. First the program without prototype:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int sum(int start, int end, int step)

\{

int sum = 0;

if (step \textgreater{} 0)

\{

for (int i = start; i \textless= end; i += step)

\{

sum += i;

\}

\}

else if (step \textless{} 0)

\{

for (int i = start; i \textgreater= end; i += step)

\{

sum += i;

\}\\
\}

return sum;\\
\}

int main()\\
\{

std::cout \textless\textless{} sum(1, 10, 1) \textless\textless{}
std::endl;

std::cout \textless\textless{} sum(2, 10, 4) \textless\textless{}
std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

And now the program with prototype:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int sum(int, int, int);

int main()\\
\{

std::cout \textless\textless{} sum(1, 10, 1) \textless\textless{}
std::endl;

return 0;\\
\}

int sum(int start, int end, int step)

\{

int sum = 0;

if (step \textgreater{} 0)

\{

for (int i = start; i \textless= end; i += step)

\{

sum += i;

\}

\}

else if (step \textless{} 0)

\{

for (int i = start; i \textgreater= end; i += step)

\{

sum += i;

\}\\
\}

return sum;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Exercise. Write a function prototype for the given function. Run the
program to make sure it works.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// put prototype of isNiceNumber() here

int main()

\{

std::cout \textless\textless{} isNiceNumber(1) \textless\textless{}
std::endl;

std::cout \textless\textless{} isNiceNumber(42) \textless\textless{}
std::end;\\
\}

bool isNiceNumber(int x)

\{

return (x == 42);\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Exercise. Write a function prototype for the given function. Run the
program to make sure it works.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// put prototype for predictGoogleStockPrice here

int main()

\{

std::cout \textless\textless{} predictGoogleStockPrice(1, 1, 2008)

\textless\textless{} '\textbackslash n'

\textless\textless{} "don't count on it ..."

\textless\textless{} std::endl;

return 0;\\
\}

int predictGoogleStockPrice(int mth, int day, int yr)

\{

if (yr \textgreater= 2004)

\{

return 450 * (yr -- 2004)

+ (mth \% 2) * (day -- 2);\\
\}

else

\{

return 0;\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Exercise. Write a function that accepts an array x of integers and an
integer i, computes and returns the sum of values in an array from index
position 0 to index position i.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// put prototype here

int main()

\{

int x{[}10{]} = \{0, 2, 4, 6, 8, 1, 3, 5, 7, 9\};

for (int i = 0; i \textless{} 10; i++)

\{

std::cout \textless\textless{} sum(x, i);\\
\}

return 0;\\
\}

// put function definition (actual function) here\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now you might ask: ``Why bother? Why not just put the function
\emph{f()} before \emph{main()}?''

There are two reasons.

First read this program and figure out what the program is trying to do:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

void f(int x)

\{

std::cout \textless\textless{} "in f() ..." \textless\textless{}
std::endl;

if (x \textgreater{} 0) g(x -- 1);

return;\\
\}

void g(int x)

\{

std::cout \textless\textless{} "in g() ..." \textless\textless{}
std::endl;

if (x \textgreater{} 0) f(x -- 1);

return;\\
\}

int main()

\{

f(5);

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Next tell me why it won't work. You have 5 seconds ...

And finally, tell me why moving functions around won't help!!! The point
is that \emph{f()} and \emph{g()} calls each other!!!

Now try this ...

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

void g(int);

void f(int x)

\{

std::cout \textless\textless{} "in f() ... x = " \textless\textless{} x
\textless\textless{} std::endl;

if (x \textgreater{} 0) g(x -- 1);

return;\\
\}

void g(int x)

\{

std::cout \textless\textless{} "in g() ... x = " \textless\textless{} x
\textless\textless{} std::endl;

if (x \textgreater{} 0) f(x -- 1);

return;\\
\}

int main()

\{

f(5);

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Do you see now that for this scenario, you \textbf{must} have a function
prototype to make this program work?

For the above situation, we say that \emph{f()} and \emph{g()} are
\textbf{mutually recursive}. A function say \emph{h()} can also call
itself; we say that \emph{h()} is \textbf{recursive}. I don't want to
spend any more time on recursion since there will be a set of notes for
that later. The point here is to show you that there are cases where you
have to untangle function dependencies using function prototypes.

Before I go on to the second reason, you should know that the standard
``layout'' of a C/C++ program looks like this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
... documentation (comments) ...

... \#includes ...

... global constants ...

... function prototypes ...

int main()

\{

...

\}

... function definitions ...\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(There are other parts but we haven't talked about them yet.)

So our above program can be professionally (ahem ...) written like this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// This program demonstrates the use of prototypes

// with two mutually recursive functions.

\#include \textless iostream\textgreater{}

void g(int);

void f(int);

int main()

\{

f(5);

return 0;\\
\}

void f(int x)

\{

std::cout \textless\textless{} "in f() ... x = " \textless\textless{} x
\textless\textless{} std::endl;

if (x \textgreater{} 0) g(x -- 1);

return;\\
\}

void g(int x)

\{

std::cout \textless\textless{} "in g() ... x = " \textless\textless{} x
\textless\textless{} std::endl;

if (x \textgreater{} 0) f(x -- 1);

return;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(Actually moving the function bodies below \emph{main()} is not that
crucial).

Once again in C/C++, a function, say \emph{func1()}, can call another,
say \emph{func2()}, if \emph{func1()} knows the ``communication
structure'' of \emph{func2()}. \emph{func1()} does not need the
definition or body of \emph{func2()}. And the communication structure is
made up of the types of the parameters of \emph{func2()} and the return
type of \emph{func2()}. That's why I drew this picture for you earlier
showing the types of data passed in and the type of value returned.

The function prototype of \emph{func2()} is sometimes called the
\textbf{interface} of \emph{func2()}. Why? Because that is how
\emph{func2()} interfaces with the outside world.

Exercise. Rewrite the following program using function prototypes and
moving the function bodies below \emph{main()} and making all constants
global to remove duplicate constants declarations.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

void printRules()

\{

const int MIN\_HEADS = 2;

const int MAX\_HEADS = 10;

std::cout \textless\textless{} "To join MENSA you need at least "

\textless\textless{} MIN\_HEADS \textless\textless{} " and at most "

\textless\textless{} MAX\_HEADS \textless\textless{} std::endl;

return;\\
\}

int getHeads()

\{

int heads;

std::cout \textless\textless{} "How many heads to you have? ";

std::cin \textgreater\textgreater{} heads;

return heads;\\
\}

bool passMinTest(int heads)

\{

const int MIN\_HEADS = 2;

if (heads \textless{} MIN\_HEADS)

\{

std::cout \textless\textless{} "Too few! Try again!"

\textless\textless{} std::endl;

return false;\\
\}

else

return true;\\
\}

bool passMaxTest(int heads)

\{

const int MAX\_HEADS = 10;

if (heads \textgreater{} MAX\_HEADS)

\{

std::cout \textless\textless{} "Don't show off! Try again!"

\textless\textless{} std::endl;

return false;\\
\}

else

return true;\\
\}

bool passTest(int x)

\{

return passMinTest(x) \&\& passMaxTest(x);\\
\}

int main()

\{

int heads = 0;

printRules();

heads = getHeads();

while (!passTest(heads))

\{

heads = getHeads();\\
\}

std::cout \textless\textless{} "OK. You can join MENSA."

\textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now for the second reason ...

Header Files and Multi-file Compilation

Remember the first week of class when I told you not to worry about

\#include \textless iostream\textgreater{}

and I told you we will come to it? Now's the time. In this section I'll
explain the purpose of this \#include business. I'll also explain, at a
very high level, the compilation and linking process that your compiler
performs on your program in order to produce a machine executable code.
Your C++ files are human readable; the machine (your
PC/laptop/cellphone/etc) can only understand machine code.

And there's no better way to understand this \#include business than to
do an example.

First here's a program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

int max(int, int);

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

return 0;\\
\}

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

return y;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Make sure it works.

Now create a new cpp file called \emph{mymath.cpp} that contains the
\emph{max()} function. (Follow the instructions given in class -- the
process depends very much on the software you use to write programs).

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: mymath.cpp

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

return y;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now remove the \emph{max()} function in \emph{testmax.cpp} -- do not
remove the function prototype. Altogether, now you have two cpp files:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

int max(int, int);

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

and

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: mymath.cpp

int max(int, int);

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

return y;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Run your program and you'll find that it works.

When I say ``compile and run your program'', the compiler software you
use actually performs (at least) two things to build a machine
executable code. Each cpp file (and you have two in this case) produces
an \textbf{object code}. In our example \emph{testmax.cpp} and
\emph{mymath.cpp} produce \emph{testmax.obj} and \emph{mymath.obj}. This
step is called \textbf{compilation}.

The next step involves combining both object code into a single machine
executable code, \emph{testmax.exe}.

You see the function prototype in \emph{testmax.cpp}:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

int max(int, int);

int main()

...\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

tells \emph{main()} how to communicate with \emph{max()} - what types
and values should be sent to \emph{max()} and what type and value (if
any) is to be received. This is all built into \emph{testmax.obj}.
However \emph{testmax.obj} does not contain the logic to actually
execute \emph{max()} since the logic is in \emph{mymath.obj}.

The next thing the compiler software does is called \textbf{object code
linking}. It takes \emph{testmax.obj} and \emph{mymath.obj} and produces
\emph{testmax.exe}. Here's a picture to help you:

When the computer runs the program, the file that is executed is
actually \emph{testmax.exe}.

Now I want to explain another step in the whole compilation process. And
this will explain the \#include business.

Now create a \textbf{header file} \emph{mymath.h} (follow the
instructions given in class -- the process depends very much on the
software you use to write programs). It includes some boilerplate code
and the function prototype from \emph{testmax.cpp}:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: mymath.h\\
\#ifndef MYMATH\_H

\#define MYMATH\_H

int max(int, int);

\#endif\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(remember to add a blank line at the end -- it's important!) and your
cpp file containing \emph{main()} should now look like this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

\#include "mymath.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Do the same for \emph{mymath.cpp}:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: mymath.cpp

\#include "mymath.h"

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

return y;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Altogether you have now three files:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: mymath.h\\
\#ifndef MYMATH\_H

\#define MYMATH\_H

int max(int, int);

\#endif\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

\#include "mymath.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: mymath.cpp

\#include "mymath.h"

int max(int x, int y)

\{

if (x \textgreater= y)

return x;

else

return y;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Run your program and make sure it works.

What's the point of \emph{\#include "mymath.h"}?

When you compile your program, the compiler software copies all the
contents of the file \emph{mymath.h} (excluding the boilerplate code) to
the places where you have \emph{\#include "mymath.h"}. I'm not going to
explain the boilerplate code in bold:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: mymath.h\\
\textbf{\#ifndef MYMATH\_H}

\#define MYMATH\_H

int max(int, int);

\#endif\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

All you need to know is that if you header file is named \emph{xyz.h},
then the boilerplate code should look like this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: xyz.h\\
\textbf{\#ifndef XYZ\_H}

\#define XYZ\_H

...

\#endif\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

This step is called \textbf{preprocessing. }For our example, after
preprocessing the \emph{testmax.cpp} file

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// Name: testmax.cpp

\#include \textless iostream\textgreater{}

\#include "mymath.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

it becomes the following in the memory of the compiler software (the
actual testmax.cpp file is \emph{\textbf{not}} changed).

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// testmax.cpp

\#include \textless iostream\textgreater{}

int max(int, int);

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Anyway ... the compilation process is now actually made up of three
steps:

To learn more about issues like machine code (in the file
\emph{testmax.exe}) you need to take CISS360 (Assembly Language and
Computer Systems.)

\textbf{Exercise. }Add a \emph{min()} function to \emph{mymath.cpp}, add
a function prototype for \emph{min()} in \emph{mymath.h}. Finally modify
your \emph{main()} as follows:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// testmax.cpp

\#include \textless iostream\textgreater{}

\#include "mymath.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

std::cout \textless\textless{} min(3, 5) \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Run the program.

So what have we done?

In our previous example I told you that a function prototype for
function \emph{func2()} is like its interface with the outside world. If
\emph{func1()} calls \emph{func2()} we have this picture:

For our current example, we placed our functions into a separate cpp
file called \emph{mymath.cpp} and put all the function prototypes of
functions in \emph{mymath.cpp} into \emph{mymath.h}. We can then call
the functions in \emph{mymath.cpp} from our main source file (say it's
called testmax.cpp)

Of course any function in \emph{testmax.cpp} (not just \emph{main()})
can call the functions in \emph{mymath.cpp}.

We have basically broken up our original program into two cpp file. The
header file \emph{mymath.h} provides an interface for \emph{mymath.cpp}.

Why is that good?

Because if one day you need the \emph{max()} and \emph{min()} functions
in another project, say the main source file is called \emph{main2.cpp}
then you can copy \emph{mymath.cpp} and \emph{mymath.h} to the project
space of \emph{main2.cpp} and you have the functions in
\emph{mymath.cpp} available to \emph{main2.cpp}.

\textbf{Exercise.} Create a brand new project, copy \emph{mymath.cpp}
and \emph{mymath.h} to the new project folder. Add these files to your
project. Create a \emph{main()} that calls \emph{min()} and
\emph{max()}.

OK. Let's step back and take a look at what we've done. Previously we
``re-use'' the code for \emph{max()} and \emph{min()} by creating a
function from chunks of code. This reduces code duplication.

But this is code reduction for \textbf{one single cpp file}.

To make the functions \textbf{more re-usable}, we took those out and put
them into a new cpp file. We need a header file too.

This allows us to re-use code easily for two totally separate programs.

(Actually you don't even need to copy \emph{mymath.cpp} and
\emph{mymath.h} to the new project. You can have one single copy of
\emph{mymath.h} and \emph{mymath.cpp} but I don't want to go into that
for CISS240.)

OK but what about

\#include \textless iostream\textgreater{}

For header files for C++ standard cpp files you should write

\#include \textless iostream\textgreater{}

which is actually the same as

\#include "iostream.h"

So in other words

\#include \textless...\textgreater{} // for C++ standard header files

\#include "..." // for your header files

And remember that when you use \textless...\textgreater{} you do not
have the .h part of the header filename.

You might say, ``Well why doesn't the compiler just search for the
function I'm calling? Just scan the hard disk for all cpp and header
files and look for the function.''

True.

But compilers don't work that way because it could potentially take half
an hour before the compiler reports an error that the function can't be
found on your hard drive!!! Your hard drive is pretty huge, you know.
For a really huge hard drive it might take even more time.

Exercise.\textbf{ }Here's a previous program. Move all the function
bodies to \emph{heads.cpp} and create a header file (pun?)
\emph{heads.h}. Run your program and make sure it works. The global
constants should be in the header file.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

void printRules()

\{

const int MIN\_HEADS = 2;

const int MAX\_HEADS = 10;

std::cout \textless\textless{} "To join MENSA you must have at "

\textless\textless{} "least " \textless\textless{} MIN\_HEADS

\textless\textless{} " and at most "

\textless\textless{} MAX\_HEADS \textless\textless{} std::endl;

return;\\
\}

int getHeads()

\{

int heads;

std::cout \textless\textless{} "How many heads to you have? ";

std::cin \textgreater\textgreater{} heads;

return heads;\\
\}

bool passMinTest(int heads)

\{

const int MIN\_HEADS = 2;

if (heads \textless{} MIN\_HEADS)

\{

std::cout \textless\textless{} "Too few! Try again!"

\textless\textless{} std::endl;

return false;\\
\}

else

return true;\\
\}

bool passMaxTest(int heads)

\{

const int MAX\_HEADS = 10;

if (heads \textgreater{} MAX\_HEADS)

\{

std::cout \textless\textless{} "Don't show off! Try again!"

\textless\textless{} std::endl;

return false;\\
\}

else

return true;\\
~\\
\}

bool passTest(int x)

\{

return passMinTest(x) \&\& passMaxTest(x);\\
\}

int main()

\{

int heads = 0;

printRules();

heads = getHeads();

while (!passTest(heads))

\{

heads = getHeads();\\
\}

std::cout \textless\textless{} "OK. You can join MENSA."

\textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

``Why do I sometimes see Parameter Names for Function Prototypes?''

I already told you that function prototypes only need the name of the
functions and the various types: the parameter types and return types.

However sometimes you see parameter names. For instance instead of this
prototype:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
int getSalary(int, int);\tabularnewline
\bottomrule
\end{longtable}

you might have this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
int getSalary(int employeeId, int overtime);\tabularnewline
\bottomrule
\end{longtable}

The reason for giving parametric names in function prototypes even
though they are ignored by C++ is that they make the function prototype
\textbf{easier to read and use}. This is especially the case where the
prototype has many parameters of the same type. For instance this

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
int getSalary(int employeeId, int overtime);\tabularnewline
\bottomrule
\end{longtable}

is more useful than this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
int getSalary(int, int); \tabularnewline
\bottomrule
\end{longtable}

Giving parameter names also allows the programmer to document the
function:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

// The getSalary() function accepts \textbf{employeeId} and

// \textbf{overtime} (in number of minutes) and returns the

// salary (in cents). Note that a valid \textbf{employeeId}

// ranges from 10000 to 99999.

// If the \textbf{employeeId} is not valid or if the \textbf{overtime}

// is negative the return value is -1.

//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

int getSalary(int employeeId, int overtime);\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Exercise: integer array library

Write an integer array library that has files \emph{IntArray.h} and
\emph{IntArray.cpp }that has the following features.

array\_init(x, x\_len, val, n)

copy integer val into x from index 0 to index n -- 1 and set x\_len to
n.

array\_assign(x, x\_len, y, y\_start, y\_end)

copy y from index y\_start to y\_end -- 1 to x starting at index 0.
x\_len is set accordingly.

array\_concat(x, x\_len, y, y\_start, y\_end)

concatenate the subarray of y from index y\_start to y\_end -- 1 to x
beginning at index x\_len. x\_len is changed accordingly.

array\_isequal(x, x\_start, x\_end, y, y\_start, y\_end)

return true if and only if x from index x\_start to x\_end -- 1 is the
same as y from index y\_start to y\_end -- 1.

array\_replace(x, x\_start, x\_end, source, target)

replace all occurrences of integer source in x from index start to end
-- 1 with integer target.

array\_count(x, x\_start, x\_end, target)

returns the number of times integer target occurs in x from index
x\_start to x\_end -- 1.

array\_max(x, x\_start, x\_end)

return maximum value of x from index x\_start to x\_end -- 1.

array\_min(x, x\_start, x\_end)

return minimum value of x from index x\_start to x\_end -- 1.

array\_max\_index(x, x\_start, x\_end)

return index of maximum value of x from index x\_start to x\_end -- 1.

array\_min\_index(x, x\_start, x\_end)

return index of minimum value of x from index x\_start to x\_end -- 1.

array\_isascending(x, x\_start, x\_end)

return true if and only if x from index x\_start to x\_end -- 1 is
sorted in ascending order.

array\_bubblesort(x, x\_start, x\_end)

perform bubblesort on x from index x\_start to x\_end -- 1.

array\_linearsearch(x, x\_start, x\_end, target)

perform linear search on x from index x\_start to x\_end -- 1 searching
for integer target and return its index in x.

array\_binarysearch(x, x\_start, x\_end, target)

perform binarysearch on x from index x\_start to x\_end -- 1 searching
for integer target and return its index in x.

Exercise: C-string library

Look at the chapter 18 Characters and C-strings. There are a bunch of
useful C-string functions in the C-string library. Implement your own
C-string library in files \emph{mystring.h} and \emph{mystring.cpp}.

strlen(s)

returns the string length of C-string s

strcpy(s, t)

copy string t to s

strclear(s)

after calling this function s becomes "". This is the same as strcpy(s,
"").

strcat(s, t)

concatenate t to s

strcmp(s, t)

returns 0 if C-strings s and t are the same strings

strreplace(s, source, target)

replace all occurrences of character source by character target. For
instance if s is "hello world", after calling strreplace(s, 'l', 'm'), s
becomes "hemmo wormd".

strleftstrip(s)

remove all whitespace characters (' ', '\textbackslash n',
'\textbackslash t') on the left of s. For instance if s is " abc ",
after calling strleftstrip(s), s becomes "abc ".

strrightstrip(s)

remove all whitespace characters (' ', '\textbackslash n',
'\textbackslash t') on the right of s. For instance if s is " abc ",
after calling strrightstrip(s), s becomes " abc".

There are actually a lot more C-string functions that comes with your
C/C++ compiler.

Summary\\

A function prototype is a statement that looks like the header of a
function. For instance the prototype of the function

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
double f(int x, int y, char z)

\{

if (z == 'a')

\{

return x + y;\\
\}

else

\{

return x * y;\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

is just

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
double f(int, int, char);\tabularnewline
\bottomrule
\end{longtable}

Once a prototype of a function f is given, the program can call the
function; the body of f need not be defined before f is called.

Prototypes of functions can be kept in a file and then ``\#include'' in
a cpp file. The definition of the functions can be kept in a different
cpp file.

\end{document}
