% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\author{}
\date{}

\begin{document}

08. \emph{if} and \emph{if-else}: Part 2

This is a continuation of ``if and if-else: Part 1''.

Enough said. Move on!!!

\emph{if}-\emph{else} statements

Run this twice by entering 42 and then 24 for input:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

You want to either do one thing or another based on whether a boolean
condition is true or false (respectively). The above does work ...
\emph{but} it is the \textbf{WRONG} way of doing it.

Now change the above to this:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

You should \textbf{NEVER} have a program like the earlier one with two
if's with opposite conditions next to each other:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

In other words if you can rewrite a bunch of ifs with if-else, then you
should. Why? Because this avoids evaluating boolean expressions
unnecessarily and hence speed up your program. (There are other
reasons).

The \textbf{second} way (the if-else) is the \textbf{right} way:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

The format of the if-else statement is

if (\emph{{[}bool expr{]}})

\emph{{[}stmt1{]}}

else

\emph{{[}stmt2{]}}

If \emph{{[}bool expr{]}} evaluates to \emph{true}, \emph{{[}stmt1{]}}
executes. When that's completed, the else part is bypassed. If
\emph{{[}bool expr{]}} evaluates to \emph{false} \emph{{[}stmt2{]}} is
executed.

Obviously you can't write an else statement without an if!!!

\textbf{Exercise.} Here's the first if-else warm up exercise. No sweat
required to finish it. First try running this program so that you know
what it does:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Next modify it to use if-else instead of two if's. Run the program and
test it. Here are some tests:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
How many heads do you have? \textbf{1}

You are not Zaphod\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

And here's an execution of the same program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
How many heads do you have? \textbf{2}

Are you Zaphod?\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Run the following program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Rewrite the program using if-else.

\textbf{Exercise.} Write a program that prompts the user for an integer
and tells you if the input is even or odd. Here's an execution:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

Here's another:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

\textbf{Exercise.} No skeleton code here. This is a slight modification
of a previous program. Write a program that prompts the user for his/her
height (in ft) and weight (in lbs) and prints ``you will live more than
100 years!!!'' if the product of the height and weight is at least
200.45. (This is not supported by any form of research.) Otherwise it
prints ``you will not live more than 100 years''. Here's an execution of
the program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
6.1 180.180

you will live more than 100 years!!!\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
3.4 23.4

you will not live more than 100 years\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that prompts the user for his
employee code which is either 0 or 1. If the employee code is 0, his/her
hourly rate is \$123.45. If the employee code is 1, his/her hourly rate
is \$7.99. Prompt the user for the number of hours he/she worked this
week. Finally print the total amount he/she made this week. Here's an
informal description of the program that you should follow (obviously
you have to translate this to C++!!!):

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
Declare constant HOURLY\_RATE\_0 and initialize it to 123.45.

Declare constant HOURLY\_RATE\_1 and initialize it to 7.99.

Declare variable employee\_code.

Get employee\_code from user.

Declare variable hourly\_rate.

If employee\_code is 0:

set hourly\_rate to HOURLY\_RATE\_0

Otherwise:

set hourly\_rate to HOURLY\_RATE\_1

Get number\_of\_hours from user.

Print total pay for this week.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Mental picture: flow of execution for \emph{if}

-else

The following picture shows you the flow of execution of a simple
program containing the if-else statement.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 0;

std::cin \textgreater\textgreater{} x;

if (x \textgreater{} 0)

std::cout \textless\textless{} "spam!" \textless\textless{} std::endl;

else

std::cout \textless\textless{} "ham!" \textless\textless{} std::endl;

std::cout \textless\textless{} "eggs" \textless\textless{}
std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 0;

std::cin \textgreater\textgreater{} x;

if (x \textgreater{} 0)

std::cout \textless\textless{} "spam!" \textless\textless{} std::endl;

else

std::cout \textless\textless{} "ham!" \textless\textless{} std::endl;

std::cout \textless\textless{} "eggs" \textless\textless{}
std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Multiplication game: Part 2

Recall our multiplication game that tests if the user can multiply 97
and

94. Here's an execution of the program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
What is the product of 97 and 94? \textbf{1}\tabularnewline
\bottomrule
\end{longtable}

Here's another:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 97 and 94? \textbf{9118}

You smart dawg!\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's the pseudocode:

Declare integer variable guess

Print a prompt string to user

Prompt user for integer value for guess

If guess is 9118

print congratulatory message

Now improve the program so that it does the following:

Declare integer variable guess

Print a prompt string to user

Prompt user for integer value for guess

If guess is 9118

print congratulatory message

Otherwise

print the correct answer

Here's an execution:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 97 and 94? \textbf{1}

Nope ... it's 9118.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 97 and 94? \textbf{9118}

You smart dawg!\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Multiplication game: Part 3

We're going to sell our multiplication game. But no one is going to buy
it if all it does is to ask the same question again and again!

Modify your program so that the program prompts the user for the product
of two integers between 90 and 99. The integers should be randomly
generated.

The pseudocode becomes:

Generate two random integers between 90 and 99

and give the values to variables x and y

Print a prompt string to user to guess the

product of x and y

Declare integer variable guess

Prompt user for integer value for guess

If guess is \textbf{the product of x and y}

print congratulatory message

Otherwise

print \textbf{the product of x and y}

Note the value of the product of x and y occurs twice. We can compute
the product just once and store it in a variable:

Generate two random integers between 90 and 99

and give the values to variables x and y

Store the product of x and y in variable answer

Print a prompt string to user to guess the

product of x and y

Declare integer variable guess

Prompt user for integer value for guess

If guess is \textbf{answer}

print congratulatory message

Otherwise

print \textbf{answer}

To test your program you need to know the answer. So just get the
program to print the answer temporarily before prompting the user. You
can get rid of revealing the answer when you have fully tested your
code.

Here's an execution of the program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 91 and 94? (answer: 8554) \textbf{1}

Nope ... it's 8554\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another execution of the same program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 96 and 94? (answer: 9024) \textbf{9024}

You smart dawg!\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Of course after it works you get rid of the \emph{(answer: ...)} output
and the execution becomes::

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 91 and 94? \textbf{1}

Nope ... it's 8554\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 96 and 94? \textbf{9024}

You smart dawg!\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

if-else blocks

It should not be too surprising that you can execute blocks for if-else.
You can have a block controlled by the if-part, or a block controlled by
the else-part, or both.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
std::cout \textless\textless{} "Head Surgery Cost
Planner\textbackslash n"

\textless\textless{} "First 3: \$100 each.\textbackslash n"

\textless\textless{} "After that: \$2 each.\textbackslash n"

\textless\textless{} "Less than 3: extra 500 charge"

\textless\textless{} std::endl;

int extraHeads = 0;

int cost = 0;

std::cout \textless\textless{} "How many extra heads do you want? ";

std::cin \textgreater\textgreater{} extraHeads;

if (extraHeads \textless= 3)

\{

cost = extraHeads * 100 + 500;

std::cout \textless\textless{} "Please go to Cheapskate Room."

\textless\textless{} std::endl;\\
\}

else

\{

cost = 3 * 100 + (extraHeads -- 3) * 2;

std::cout \textless\textless{} "Please go to Deluxe Room."

\textless\textless{} std::endl;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Once you see code like the above you immediately ask
yourself this question: How many constants do you see in the above
program? (I can see four). Rewrite it with constants instead of
hard-coding integer values.

\textbf{Exercise.} Write a program that computes the area of either a
circle or a right-angle triangle. Recall that you can declare character
variables. It turns out that you can compare character values too, using
the \emph{==} operator. The type for the character values is
\emph{char}. Here's a code skeleton for you:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
std::cout \textless\textless{} "Area Calculator!!!\textbackslash n";

std::cout \textless\textless{} "I can do circles or
triangles!\textbackslash n"

\textless\textless{} "Option (c or t): ";

char option;

std::cin \textgreater\textgreater{} option;

if (option == 'c')

\{

// Prompt the user for radius and display the

// area of the circle with the given radius.

\}

else // if it's not 'c', assume it is 't'

\{

// Prompt the user for the base and height of

// the right-angled triangle and display the

// area.

\emph{\}} \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Coding style for \emph{if} and \emph{if}-\emph{else}

ONE SPACE AFTER if:

BAD (but practiced by some)

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if(x \textless{} 0)

foo = 1; \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

GOOD

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

foo = 1; \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

ONE-LINE if:

It's OK to write a one-line if statement if the body is a short
statement and not a block and it improves readability.

OK BUT YUCKY:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
x = 0;

if (x \textless{} 0)

y = 0;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

BETTER

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
x = 0;

if (x \textless{} 0) y = 0;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Maximum/minimum computation

Trace this (very very very important program by hand). Understand what
it does. Finally rewrite it using the one-line if format.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int w = 1, x = 3, y = 0, z = 5;

int max;

max = w;

if (max \textless{} x)

max = x;

if (max \textless{} y)

max = y;

if (max \textless{} z)

max = z;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Note that you can also use the bubblesort algorithm to compute the
maximum value in w, x, y, z. However the above maximum computation
algorithm does not require swapping values (the values in w, x, y, z are
not changed) and therefore it uses less computation.

\textbf{Exercise.} Write a program that prompts the user for 6 integer
values, prints the 6 values, and then prints the maximum of the 6
values.

\textbf{Exercise.} Refer to the previous exercise. What happens when you
change all the \textless{} to the \textgreater{} operator? (This is also
very very very important).

Coding style for blocks

ALIGN BLOCK DELIMITERS TO HEADER:

BAD (but used by some and is common in Java):

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int main() \{

return 0;

\} \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

and

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0) \{

foo = 42;

bar = 43;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

HORRIFYING:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

\{

foo = 42;

bar = 43;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

ABOMINABLE:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

\{

foo = 42;

bar = 43;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

GOOD:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int main()

\{

return 0;

\} \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

and

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

\{

foo = 42;

bar = 43;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The same applies to if-else:

BAD

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0) \{

foo = 42;

bar = 43;

\}

else \{

foo = 43;

bar = 42;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

GOOD

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

\{

foo = 42;

bar = 43;

\}

else

\{

foo = 43;

bar = 42;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

ALWAYS USE BLOCKS IF NOT ONE-LINERS:

C/C++ programmers tend to use blocks even when the block has only one
statement except when using the one-line if style. This creates a
unified look and prevents difficult-to-find bugs caused by ``dangling
else'' (see later).

OK BUT NOT COMMON:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

foo = 42;

else

foo = 24;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

COMMON:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

\{

foo = 42;

\}

else

\{

foo = 24;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Boolean expressions again

We started with boolean expressions such as

x \textgreater{} 0

and went on to expressions such as

x \textgreater{} y

and then to

x * x + y * y != 0

and finally to

\emph{a * a + b * b \textless{} c * c + d * d}

i.e.

\emph{{[}expr1{]} {[}boolop{]} {[}expr2{]}}

where \emph{{[}expr1{]}} and \emph{{[}expr2{]}} are boolean expressions
and \emph{{[}boolop{]}} is a binary boolean operator accepting two
numeric values. Let's recall a few more binary operators.

First of all let's not forget that we also have the unary ! operator.
The following prints x if \textbf{it is not true that x is 0}.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 0;

std::cin \textgreater\textgreater{} x;

if (\textbf{!(x == 0)})

std::cout \textless\textless{} x \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Rewrite the above program so that the ! operator is
not used. Your resulting program therefore has to evaluate one boolean
operator and not two.

\textbf{Exercise.} Simplify the boolean expression in the program so
that the program behaves the same after your modification:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 0;

std::cin \textgreater\textgreater{} x;

if (!(x \textless= 42) \textbar\textbar{} !(x \textgreater= 42))

std::cout \textless\textless{} x \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

But note you should not simplify expressions (boolean or numeric) if by
doing so it makes your program harder to read. Furthermore, modern-day
compilers are actually smart enough to simplify it for you
automatically!

Of course we also have the boolean operators \emph{\&\&} and
\emph{\textbar\textbar{}}. So we can have the following boolean
expression:\\
~\\
\emph{(x \textless{} y) \&\& (y \textless{} z)}

Note that \emph{(x \textless{} y)} and \emph{(y \textless{} z)} are
boolean expressions. So in general we can have

{[}boolexpr1{]} {[}boolop{]} {[}boolexpr2{]}

where \emph{{[}boolexpr1{]}} and \emph{{[}boolexpr2{]}} are boolean
expressions and \emph{{[}boolop{]}} is either \&\& or \textbar\textbar.

This should be a DIY review:

\textbf{Exercise.} Complete the truth table for \emph{\&\&}:

true \&\& trueis\_\_\_\_\_

true \&\& falseis\_\_\_\_\_

false \&\& trueis\_\_\_\_\_

false \&\& falseis\_\_\_\_\_

\textbf{Exercise.} Complete the truth table for
\emph{\textbar\textbar{}}:

true \textbar\textbar{} trueis\_\_\_\_\_

true \textbar\textbar{} falseis\_\_\_\_\_

false \textbar\textbar{} trueis\_\_\_\_\_

false \textbar\textbar{} falseis\_\_\_\_\_

You should check with your previous notes.

\textbf{Exercise.} You qualify for free head surgery if you have one
head, less than three arms, more fingers on your left than you right
hand, and finally either you are from Earth or the product of your
highest level reached on Pacman and Galaxian is less than 6 (obviously
you need an extra head in that case ...) Of course if you have not
played Pacman, your high level is 0; likewise for Galaxian. Complete
this program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int numHeads = 0;

int numArms = 0;

int numLeftFingers = 0;

int numRightFingers = 0;

bool earthling = true;

int pacManLevel = 0;

int galaxianLevel = 0;

// prompt for values for all variables

// For boolean variable enter 1 for true and 0 for false

if ( )

std::cout \textless\textless{} "You qualify for our free head surgery!"

\textless\textless{} std::endl;

else

std::cout \textless\textless{} "Try again at newheads.com"
\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

You should create some test cases by hand and then test your code
against your test cases.

Nested \emph{if}-\emph{else}

Now the plot thickens. Since we can put any statement inside an
\emph{if} or an \emph{else}, and \emph{if} and \emph{if}-\emph{else} are
themselves statements, that means that we can nest if and if-else
statements.

That's mind-boggling. Let's have an example.

Run this with input 1. Run it again with input 2. Repeat that with 3.
Finally try it with -1.

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

\textbf{Exercise.} Draw a picture showing the flow of execution of the
above code segment.

Here's another example. Run this with inputs 1, 2, 3, -1.

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

\textbf{Exercise.} What is the output when x has value 0.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 5)

\{

std::cout \textless\textless{} "1" \textless\textless{} std::endl;\\
\}

else

\{

if (x == 0)

\{

std::cout \textless\textless{} "2" \textless\textless{} std::endl;\\
\}

else

\{

if (x \textgreater{} 42)

\{

std::cout \textless\textless{} "3" \textless\textless{} std::endl;

\}\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

By the way look at this program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (score \textless{} 100)

\{

std::cout \textless\textless{} "lousy gamer" \textless\textless{}
std::endl;\\
\}

else

\{

if (100 \textless= score \&\& score \textless{} 200)

\{

std::cout \textless\textless{} "not bad" \textless\textless{}
std::endl;\\
\}

else

\{

if (200 \textless= score)

\{

std::cout \textless\textless{} "great!" \textless\textless{} std::endl;

\}\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Do you see why the above is the same as:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (score \textless{} 100)

\{

std::cout \textless\textless{} "lousy gamer" \textless\textless{}
std::endl;\\
\}

else

\{

\textbf{if (score \textless{} 200)}

\{

std::cout \textless\textless{} "not bad" \textless\textless{}
std::endl;\\
\}

else

\{

if (200 \textless= score)

\{

std::cout \textless\textless{} "great!" \textless\textless{} std::endl;

\}\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that prompts the user for his/her
age. If the age is less than 10, print ``read the hobbit'', if it's
between 11 and 15, print ``read lord of the ring'', if it's 16, print
``read hitchhiker's guide to the galaxy'', and otherwise, print ``read
chica chica boom boom''.

\textbf{Exercise.} Write a program that converts a numeric grade to a
letter grade. The program prompts the user for a double, and if the
double is less than 60, it prints 'F'; if it is at least 60 but less
than 70, it prints 'D';if it is at least 70 but less than 80, it prints
'C';if it is at least 80 but less than 90, it prints 'B'; and if it's at
least 90, it prints 'A'.

The dangling else problem

Here's a trick question (and it's another reason why C/C++/Java
programmers use \{ \} even when the block has only one statement). So
...

PAY ATTENTION

First figure out the output (without a compiler) when x has a value of
0.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

if (x == -2) std::cout \textless\textless{} "1" \textless\textless{}
std::endl;

else

std::cout \textless\textless{} "2" \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Now run the program.

Mamamia ... ?!?

This is called the ``dangling else'' problem.

What actually happens is that an \emph{else} always follows the closest
\emph{if}. This means that the above code is better indented this way:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

if (x == -2) std::cout \textless\textless{} "1" \textless\textless{}
std::endl;

else

std::cout \textless\textless{} "2" \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Of course the C++ compiler doesn't care about whitespaces. However this
version of indentation makes it easier for human beings to follow the
logic.

Now if what I intended was actually something like the previous version,
then I would have to do this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

\{

if (x == -2) std::cout \textless\textless{} "1" \textless\textless{}
std::endl;

\}

else

std::cout \textless\textless{} "2" \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

In this case, the closest if-part that the else-part can attach to is
the if-part on the first line since the else-part cannot ``go inside''
the block.

This is the reason why it's a good practice to ALWAYS use blocks even
when the if-part or the else-part has only one line to execute. It
prevents the misleading dangling else problem. So if I write this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

\{

if (x == -2)

\{

std::cout \textless\textless{} "1" \textless\textless{} std::endl;

\}

\}

else

\{

std::cout \textless\textless{} "2" \textless\textless{} std::endl;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

there will be no confusion.

Coding style for nested \emph{if}-\emph{else}

NOT SO GOOD:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 5)

\{

foo = 42;\\
\}

else

\{

if (x \textless{} 8)

\{

foo = 43;\\
\}

else

\{

if (x == 9)

\{

foo = 44;

\}

else

\{

foo = 45;\\
\}\\
\}\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

GOOD:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 5)

\{

foo = 42;\\
\}

else if (x \textless{} 8)

\{

foo = 43;\\
\}

else if (x == 9)

\{

foo = 44;

\}

else

\{

foo = 45;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Rewrite your previous program:

\begin{longtable}[]{@{}@{}}
\toprule
\endhead
\bottomrule
\end{longtable}

using the above format.

Multiplication game: Part 4

Here comes one more improvement to our multiplication game. We're going
to give the user a second chance. Furthermore we'll give a hint. We will
tell him/her is his/her answer is too high or too low. If the user gets
the correct answer the first time, we'll give 2 points. If the user gets
it right the second time, we'll give 1 point. Otherwise we'll give zero.
(What else can you give anyway?)

Here's the pseudocode:

Generate two random integers between 90 and 99

and give the values to variables x and y

Store the product of x and y in variable answer

Print a prompt string to user to guess the

product of x and y

Declare integer variable score and initialize it

to 0

Declare integer variable guess

Prompt user for integer value for guess

If guess is answer

Print congratulatory message

score = 2

Otherwise if guess is less than the answer:

Tell user the guess is too low

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

Otherwise if guess is greater than the answer:

Tell user the guess is too high

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

Print user's score

Here are several executions to give you a feel for what the program
should do:

Case: correct

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 91 and 94? (answer: 8554) \textbf{8554}

You smart dawg!

Score: 2\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Case: low-low

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 91 and 94? (answer: 8554) \textbf{1}

Too low!

What is the product of 91 and 94? (answer: 8554) 1

Nope ... it's 8554

Score: 0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Case: low-correct

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 91 and 94? (answer: 8554) \textbf{1}

Too low!

What is the product of 91 and 94? (answer: 8554) 8554

You smart dawg!

Score: 1\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Case: low-high

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 91 and 94? (answer: 8554) \textbf{1}

Too low!

What is the product of 91 and 94? (answer: 8554) 9000

Nope ... it's 8554

Score: 0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Case: high-low

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 91 and 94? (answer: 8554) \textbf{9000}

Too high!

What is the product of 91 and 94? (answer: 8554) 1

Nope ... it's 8554

Score: 0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Case: high-correct

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
What is the product of 91 and 94? (answer: 8554) \textbf{9000}

Too high!

What is the product of 91 and 94? (answer: 8554) 8554

You smart dawg!

Score: 1\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Cleanup -- refactoring

In writing software, even when you're done, you should look at your code
to see if you can improve on it. You do not want to change the behavior
of the code. Rather you want to reorganize the code to make it easier to
read or to make it more efficient. Such an activity is called
\textbf{refactoring}.

This is something that all problem-solving processes involve, not just
software development. In particular, this occurs a lot in fundamental
research as well. For instance mathematicians always rewrite their
proofs to improve the readability. Sometimes mathematicians will even
derive different proofs of the same result in order to see things in a
totally different way. Anyway, let's get back to programming.

You realized that there is a lot of duplicate code. There is a lot of
duplication when the program gives the user a second try:

Generate two random integers between 90 and 99

and give the values to variables x and y

Store the product of x and y in variable answer

Print a prompt string to user to guess the

product of x and y

Declare integer variable score and initialize it

to 0

Declare integer variable guess

Prompt user for integer value for guess

If guess is answer

Print congratulatory message

score = 2

Otherwise if guess is less than the answer:

Tell user the guess is too low

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

Otherwise if guess is greater than the answer:

Tell user the guess is too low

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

Print user's score

Not everything is similar between the two chunks of code. But you can
see that the similarities is around this spot:

If guess is answer

Print congratulatory message

score = 2

Otherwise if guess is less than the answer:

Tell user the guess is too low

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

Otherwise if guess is greater than the answer:

Tell user the guess is too low

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

We want to write one chunk of code and not two. To combine the chunks
(they reside under two different boolean conditions right now) we need
to have a common condition for both -- and that's when the first guess
is incorrect:

If guess is answer

Print congratulatory message

score = 2

Otherwise

\textbf{If guess is less than the answer:}

Tell user the guess is too low

Otherwise

Tell user the guess is too high

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

Print user's score

Now using this pseudocode, clean up your program and see how many lines
of code shorter your program gets.

Find computation

Suppose you're a bunch of integer values in variables, say

\emph{a}, \emph{b}, \emph{c}, \emph{d}

and you're interested in who has a particular value. If the target value
is in a, you want to print 0. If it's in b, you want to print 1, etc. In
other words, we think of a has having position 0 and if the target value
is found in a, we think of the target at position 0. I will save the
position in the variable \emph{index}. The code would look like this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (target == a)

\{

index = 0;\\
\}

else if (target == b)

\{

index = 1;\\
\}

else if (target == c)

\{

index = 2;\\
\}

else if (target == d)

\{

index = 3;\\
\}

std::cout \textless\textless{} index \textless\textless{}
'\textbackslash n';\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

If the target is not found in a, b, c, d, we will set \emph{index} to
-1:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (target == a)

\{

index = 0;\\
\}

else if (target == b)

\{

index = 1;\\
\}

else if (target == c)

\{

index = 2;\\
\}

else if (target == d)

\{

index = 3;\\
\}

else

\{

index = -1;\\
\}

std::cout \textless\textless{} index \textless\textless{}
'\textbackslash n';\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Complete the program by prompting the user for
\emph{a}, \emph{b}, \emph{c}, \emph{d} and target and print
\emph{index}.

\textbf{Exercise.} Do the same as above but prompt the user for 5
integer values \emph{a}, \emph{b}, \emph{c}, \emph{d}, \emph{e}.

\textbf{Exercise.} Note that the above finds the position of a value by
searching from the first variable to the last (\emph{a} to \emph{d}).
What if you search backwards? For instance if the target value is found
in both \emph{a} and \emph{d}, your program should print 3 and not 0.

Make sure you understand and remember this algorithm.

Count computation

Suppose you have 4 integer variables (say \emph{a}, \emph{b}, \emph{c},
\emph{d}) and you want to count the number of times a value (say in
\emph{target}) occurs in these integer variables. The pseudocode would
look like this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
count = 0

if target == a:

increment count by 1

if target == b:

increment count by 1

if target == c:

increment count by 1

if target == d:

increment count by 1

print count\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that prompts the user for 4 integers,
stores them in variables, \emph{a}, \emph{b}, \emph{c}, \emph{d}. The
program then prompts the user for an integer value and stores it in
\emph{target}. Convert the above pseudocode into C++ and print
\emph{count}.

Make sure you understand and remember this algorithm.

Typecast between \emph{bool} and \emph{int}s

And don't forget that, when needed, C++ will automatically type cast
boolean values to integers by casting the value true to 1 and false to
0. C++ will also can also type cast numeric values (ints, doubles,
floats) to boolean values by casting nonzero values to true and zero to
false:

bool→int

true1

false0

numeric (int/double/float)→\emph{bool}

nonzero (example: 1, 2.3)\emph{true}

zero (example: 0, 0.0)\emph{false}

Try this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (1)

std::cout \textless\textless{} "i'm the queen of england"

\textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Change 1 to 4 and run the program again.

(The above is not a random example. It's important because we're going
into loops very soon.)

\textbf{Exercise.} What is the boolean value of 1 \&\& 2? What about 1
\&\& 0? Do it ``by hand''. Next verify your computation by running this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
std::cout \textless\textless{} (1 \&\& 2) \textless\textless{}
std::endl;

std::cout \textless\textless{} (1 \&\& 0) \textless\textless{}
std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

I also warn you again that type casting does not change the value of a
variable:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 42;

std::cout \textless\textless{} (x \&\& 1) \textless\textless{}
std::endl;

std::cout \textless\textless{} x \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(The value of \emph{x} is type cast to \emph{true}. \emph{x} is still
42.\emph{)}

This is really the same as calling the \emph{sqrt()} (square root)
function with a variable. The value of the variable is not changed.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
double x = 2.0;

std::cout \textless\textless{} x \textless\textless{} std::endl;

std::cout \textless\textless{} sqrt(x) \textless\textless{} std::endl;

std::cout \textless\textless{} x \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Assignment based on conditions

Here's a trick to simplify an assignment via an \emph{if}-\emph{else}
statement. Suppose you have this program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
bool newMember = true;

double loanRate = 0.0;

if (newMember)

loanRate = 0.01;

else

loanRate = 0.20;

// Yeah that's what credit cards companies do ...\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

You can rewrite this as:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
bool newMember = true;

double loanRate = 0.01;

if (!newMember)

loanRate = 0.20;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Yet another way to do this is:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
bool newMember = true;

double loanRate = newMember * 0.01

+ (!newMember) * 0.20;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

There is however a \textbf{problem} with this technique and some
disapprove of it. That is, you're using a boolean value (true or false)
as a numeric value (1 or 0). Some people believes that automatic type
casting like this is dangerous and misleading and that \textbf{types
should be kept as separate as possible}.

To make such people happy (example: your tech leader / manager might be
one) and also not to mislead the reader, you should always
\textbf{explicitly type cast}. For instance above should be written:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
bool newMember = true;

double loanRate = int(newMember) * 0.01

+ int(!newMember) * 0.20;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Write a program that gives the variable
\emph{heartAttackRate} 0.01, 0.02, 0.03, and 0.94 depending on whether
\emph{numHeads} is 1, 2, 3 or at least 4 (respectively). Complete this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int numHeads = 0;

std::cin \textgreater\textgreater{} numHeads;

double heartAttackRate =
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

\emph{std::cout \textless\textless{} heartAttackRate
\textless\textless{} std::endl;} \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The ternary operator

So far our operators accept one value, for example:

\emph{--y}

!b

or two values, for example:

x + y

b1 \&\& b2

There is a curious operator that accepts \emph{\textbf{three}}. Try this
program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 5;

std::cout \textless\textless{} (x == 5 ? 42 : 0) \textless\textless{}
std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Run this with different values for variable x.

Get the point of the \emph{(?:)} operator yet? The format looks like
this:

(\emph{{[}bool expr{]}} ? \emph{{[}expr1{]}} : \emph{{[}expr2{]}})

Basically, if the \emph{{[}bool expr{]}} (a boolean expression)
evaluates to \emph{true}, C++ will evaluate \emph{{[}expr1{]}} and give
you its value; otherwise it gives you the value from \emph{{[}expr2{]}}.

Here's another example. First try to guess what the program does. Next
run it to verify.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 0, y = 1, z = 2;

int a = (x + y \textless{} z ? x : y + z);

std::cout \textless\textless{} a \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Do you see that it does the same thing as this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x = 0, y = 1, z = 2;

int a = 0;

if (x + y \textless{} z)

\{

a = x;

\}

else

\{

a = y + z;

\}

std::cout \textless\textless{} a \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another example. Try this die game:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int die\_roll = 1 + rand() \% 6 ;

std::cout \textless\textless{} "value of die roll: "
\textless\textless{} die\_roll

\textless\textless{} '\textbackslash n';

std::cout \textless\textless{} "You "

\textless\textless{} (die\_roll == 6 ? "win!" : "lose")

\textless\textless{} '\textbackslash n';\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Get it?

\textbf{Exercise.} Write a dice game. Roll two dice. If the dice both
give you the same number, print ``win''. Otherwise your program prints
``lose''. Your program should also print the values of the dice roll.
Use the ternary operator.

\textbf{Exercise.} Write a dice-coin game. First, you roll the dice. If
the dice values are the same you gain \$1.50 and the game ends.
Otherwise you pay \$1. However you have a second chance: you toss a
coin. If you get a head (use random integer value of 0) you gain \$1,
otherwise (i.e., for a tail), you gain \$0.50. Your program prints all
the dice values and the result of the coin toss and finally your gain
(which can be positive or negative). Run this program 10 times. What is
you average gain? Use the ternary operator whenever possible.

\textbf{Exercise.} Rewrite the following code fragment so that it's
cleaner

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int x, y;

std::cin \textgreater\textgreater{} x \textgreater\textgreater{} y;

if (x \textgreater= 42)

\{

std::cout \textless\textless{} x \textless\textless{} ' ';

if (y \textless{} 10)

\{

std::cout \textless\textless{} y \textless\textless{} ' ';

\}

else

\{

std::cout \textless\textless{} '-' \textless\textless{} ' ';

\}

\}

else

\{

std::cout \textless\textless{} '*' \textless\textless{} ' ';

if (y \textless{} 10)

\{

std::cout \textless\textless{} y \textless\textless{} ' ';

\}

else

\{

std::cout \textless\textless{} '-' \textless\textless{} ' ';

\}

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Summary

The if and if-else statement looks like these:

if (\emph{{[}bool expr{]}})

\emph{{[}stmt{]}}

if (\emph{{[}bool expr{]}})

\emph{{[}stmt1{]}}

else

\emph{{[}stmt2{]}}

where \emph{{[}bool expr{]}} is a boolean expression and
\emph{{[}stmt{]}, {[}stmt1{]}}, and \emph{{[}stmt2{]}} are either
statements or blocks of statements.

The else statement will always be associated with the closest if
statement. In other words

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

if (x == -2) std::cout \textless\textless{} "1" \textless\textless{}
std::endl;

else

std::cout \textless\textless{} "2" \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

is better written this way:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (x \textless{} 0)

if (x == -2)

std::cout \textless\textless{} "1" \textless\textless{} std::endl;

else

std::cout \textless\textless{} "2" \textless\textless{} std::endl;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The \emph{rand()} function returns a ``random'' integer between 0 and
\emph{RAND\_MAX}. Number. The \emph{srand()} function ``seeds'' the
\emph{rand()} function. You might need to ``\emph{\#include
\textless cstdlib\textgreater{}}'' to use the \emph{srand()} and
\emph{rand()} functions. One way to seed rand() is to call

\emph{srand((unsigned) time(0))}

in which case you need to ``\#include \textless ctime\textgreater''.

double(rand()) / RAND\_MAX

will generate ``random'' doubles between 0 and 1. To generate a random
integer between a and b (two integers with a \textless= b), you can use

\emph{int(double(rand()) / RAND\_MAX * (b -- a)) + a}

or

rand() \% (b -- a + 1) + a

(The second method is not as general nor as random as the first. For
instance you cannot use it to generate random number between 0 and
1000000 in MS .NET STUDIO).

The following code segment swaps the values in \emph{a} and \emph{b}
(and \emph{t} has the value of \emph{a}):

t = a;a = b;b = t;

Using the ``swapping trick'', you can always ensure that a pair of
variables are in ascending (or descending order):

\emph{if (a \textgreater{} b)}

\{

t = a;

a = b;

b = t;

\}

Given for instance four variables \emph{a}, \emph{b}, \emph{c}, and
\emph{d}, you can apply the above to the pairs \emph{a},\emph{b} and
\emph{b},\emph{c} and \emph{c},\emph{d} to ensure that the largest value
among \emph{a}, \emph{b}, \emph{c}, \emph{d} is in \emph{d:}

if (a \textgreater{} b) \{ swap values of a and b \}

if (b \textgreater{} c) \{ swap values of b and c \}

if (c \textgreater{} d) \{ swap values of c and d \}

This is called one pass of the sorting process. You can then apply the
process to a, b, c for a second pass, and then to a, b for a third pass.
This will sort the values of \emph{a}, \emph{b}, \emph{c}, \emph{d} into
ascending order.

Just as there is automatic type casting from int to double, there is
also automatic type type casting between bool and int or double:

bool→int

true1

false0

numeric (int/double/float)→\emph{bool}

nonzero (example: 1, 2.3)\emph{true}

zero (example: 0, 0.0)\emph{false}

For instance the following is a valid C++ statement:

if (1)

std::cout \textless\textless{} "that's all folks";

The ternary operator looks like this:

(\emph{{[}bool expr{]}} ? \emph{{[}expr1{]}} : \emph{{[}expr2{]}})

This whole expression evaluates to \emph{{[}expr1{]}} if \emph{{[}bool
expr{]}} is true; otherwise it evaluates to \emph{{[}expr2{]}}.

Repetition code and breaking deeply nested code and deep expressions

(There are some solutions are the end of this pdf.)

Here's one way to compute sum from 1 to 5 is

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
int s = 1 + 2 + 3 + 4 + 5;\tabularnewline
\bottomrule
\end{longtable}

Another way to do this is to do this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int s = 0;

s = s + 1;

s = s + 2;

s = s + 3;

s = s + 4;

s = s + 5;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

And to make all repetition code exactly the same, you do this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int i = 1;

int s = 0;

s = s + i;

i = i + 1;

s = s + i;

i = i + 1;

s = s + i;

i = i + 1;

s = s + i;

i = i + 1;

s = s + i;

i = i + 1;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

You have already seen this before.

The reason why you want to think/write your code using repeating code is
because later we can use loop controls to tell C++ to repeat a block of
code by giving the loop structure just one block of the code.

\textbf{Exercise.} Compute the sum of squares from 1 to 25, i.e., s =
1*1 + 2*2 + 3*3 + 4*4 + 5*5 using the same idea as above.

\textbf{Exercise.} Get an integer n from the user and then compute the
sum of the rightmost 4 digits of n. Do this with repetition code.

Maximum/minimum computation

Recall I have already talked about the max/min computation. There are
two ways of doing it.

Here's the max computation that you have already seen:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int w = 1, x = 3, y = 0, z = 5;

int max;

max = w;

if (max \textless{} x)

max = x;

if (max \textless{} y)

max = y;

if (max \textless{} z)

max = z;\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Notice that other than the first statement, the rest of the code is more
or less a repetition of the same kind of code:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
max = w;

if (max \textless{} {[}variable{]})

max = {[}variable{]};\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

There's another \textbf{TERRIBLE} way to do the above:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int w = 1, x = 3, y = 0, z = 5;

if (w \textgreater= x \&\& w \textgreater= y \&\& w \textgreater= z)

max = w;

else

\{

if (x \textgreater= w \&\& x \textgreater= y \&\& x \textgreater= z)

max = x;

else

\{

if (y \textgreater= w \&\& y \textgreater= x \&\& y \textgreater= z)

max = y;

else

max = z;

\}

\} \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Of course you can try to make it ``neater'':

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int w = 1, x = 3, y = 0, z = 5;

if (w \textgreater= x \&\& w \textgreater= y \&\& w \textgreater= z)

max = w;

else if (x \textgreater= w \&\& x \textgreater= y \&\& x \textgreater=
z)

max = x;

else if (y \textgreater= w \&\& y \textgreater= x \&\& y \textgreater=
z)

max = y;

else

max = z; \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

But you are computing way too many boolean conditions. If z is the
maximum value, how many boolean operators are you evaluating? Compare
this to the first max computation.

Secondly, and this is probably even more important:

\textbf{Exercise.} Suppose you need to add another variable to your w,
x, y, z for max computation:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
int w = 1, x = 3, y = 0, z = 5, a = 7;

int max;

// ... max computation ...\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Complete this using the first method and then using the second method.
Do I need to explain anymore that the first method is way better?

Part of the problem is that the boolean expression in

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (w \textgreater= x \&\& w \textgreater= y \&\& w \textgreater= z)

max = w; \strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

depends on a huge number of variables.

The earlier better solution is to consider one variable at a time.

In general if the boolean is made up of expressions which \textbf{do not
depend on each other}, it's usually best to process them
\textbf{separately}.

Count computation

Here's the pseudocode for the count computation again:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
count = 0

if target == a:

increment count by 1

if target == b:

increment count by 1

if target == c:

increment count by 1

if target == d:

increment count by 1

print count\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Again, you see repetition of code.

Another way to do the above, a \textbf{TERRIBLE} way, is to do this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
count = 0

if target != a \&\& target != b \&\& target != c \&\& target != d

count = 0

else if target == a \&\& target != b \&\& target != c \&\& target != d

count 1

else if target != a \&\& target == b \&\& target != c \&\& target != d

count 1

else if target != a \&\& target != b \&\& target == c \&\& target != d

count 1

else if target != a \&\& target != b \&\& target == c \&\& target != d

count 1

else if target != a \&\& target != b \&\& target != c \&\& target == d

count 1

else if target == a \&\& target == b \&\& target != c \&\& target != d

count 2

\ldots.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

I don't even want to complete this!!! This is clearly a really TERRIBLE
algorithm. There is a total of 2\textsuperscript{4} = 16 boolean
expressions. (Why?) YIKES!

And furthermore, if I add another variable e to the above, I would have
to change a lot of code, as well as adding some more code.

\textbf{Exercise.} Get integer \emph{x}, \emph{y} from the user and
print \emph{x}, \emph{y}, except that if \emph{x }is negative you print
\emph{0} instead of \emph{x} and if \emph{y} is negative you print
\emph{0} instead of \emph{y}. Here's a test case

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
2 3

2 3\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another test case

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
-1 3

0 3\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

and another test:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
2 -2

2 0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

and finally

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
-5 -2

0 0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

You can write your program with boolean conditions where each boolean
condition involves \textbf{both} \emph{x} and \emph{y}. But instead of
that, write your program so that you have boolean expressions where each
boolean expression involves only \textbf{one} variable.

Multiplication game: Part 4

Here's the pseudocode:

Generate two random integers between 90 and 99

and give the values to variables x and y

Store the product of x and y in variable answer

Print a prompt string to user to guess the

product of x and y

Declare integer variable score and initialize it

to 0

Declare integer variable guess

Prompt user for integer value for guess

If guess is answer

Print congratulatory message

score = 2

Otherwise if guess is less than the answer:

Tell user the guess is too low

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

Otherwise if guess is greater than the answer:

Tell user the guess is too low

Print a prompt string to user to guess

the product of x and y

If guess is answer

print congratulatory message

score = 1

Otherwise

print answer

Print user's score

Sometimes, you have deeply nested code. What if the above, where you
give the user at most 2 chances to answer a question, if changed to
allowing the user to have \textbf{3} chances or even \textbf{4} chances?
If you use the above method, you would have a very deeply nested code
structure.

Another way to allow the user 3 chances is to avoid deeply nested code
as follows. First, since you do not want to nest the 3 cases, you want
something like this:

ask user for an answer

ask user for an answer

ask user for an answer

But of course you want the second ``ask user for an answer'' to know if
the first ``ask user for an answer'' gave rise to a correct answer or
not.

ask user for an answer

if first answer is not correct:

ask user for an answer

ask user for an answer

Likewise the third ``ask user for an answer'' also need to know if a
correct answer was given. So instead of ``first answer is not correct'',
we probably want ``\,``answer is not correct'' that can be used or the
second and third ``answer user for an answer''.

ask user for an answer

if answer is not correct

ask user for an answer

if answer is not correct

ask user for an answer

Let's make ``answer is not correct'' into a boolean variable:

bool answer\_is\_correct

ask user for an answer

if answer from user is correct,

answer\_is\_correct = true

if !answer\_is\_correct:

ask user for an answer

if answer from user is correct,

answer\_is\_correct = true

if !answer\_is\_correct:

ask user for an answer

if answer from user is correct,

answer\_is\_correct = true

You want to think of \emph{answer\_is\_correct} as a
\textbf{communication device} from the first ``answer user for an
answer'' with the second and third, and also from the second to the
third. For this example, the repeated blocks of code are \textbf{not
completely independent}. Other than the first block, subsequent blocks
need to know if the user has given a correct answer.

Get it?

\textbf{Exercise.} Write the multiplication game that allows the user to
have at most 3 tries.

\textbf{Exercise.} Get an integer n from the user and then compute the
sum of the rightmost 4 digits of n. Once a digit 0 is added, you should
stop the summation. Do this with repetition code. Here's a test case

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\textbf{1534315}

13\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\textbf{1534015}

6\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(after adding \emph{5} and \emph{1}, on seeing a \emph{0}, the summation
stops. Therefore the sum is 6) and another

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\textbf{1534205}

5\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Solutions

\textbf{Exercise.} Compute the sum of squares from 1 to 25, i.e., s =
1*1 + 2*2 + 3*3 + 4*4 + 5*5 using the same idea as above.

\protect\hypertarget{anchor}{}{}Solution.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

int s = 0;

int i = 1;

s = s + i;

i = i + 1;

s = s + i;

i = i + 1;

s = s + i;

i = i + 1;

s = s + i;

i = i + 1;

s = s + i;

i = i + 1;

std::cout \textless\textless{} s \textless\textless{}
'\textbackslash n';

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Get an integer n from the user and then compute the
sum of the leftmost 4 digits of n. Do this with repetition code.

\protect\hypertarget{anchor-1}{}{}Solution.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

int n;

std::cin \textgreater\textgreater{} n;

int s = 0;

s = s + n \% 10;

n = n / 10;

s = s + n \% 10;

n = n / 10;

s = s + n \% 10;

n = n / 10;

s = s + n \% 10;

n = n / 10;

std::cout \textless\textless{} s \textless\textless{}
'\textbackslash n';

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Get integer \emph{x}, \emph{y} from the user and
print \emph{x}, \emph{y}, except that if \emph{x }is negative you print
\emph{0} instead of \emph{x} and if \emph{y} is negative you print
\emph{0} instead of \emph{y}. Here's a test case

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
2 3

2 3\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another test case

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
-1 3

0 3\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

and another test:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
2 -2

2 0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

and finally

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
-5 -2

0 0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

You can write your program with boolean conditions where each boolean
condition involves both \emph{x} and \emph{y}. But instead of that,
write your program so that you have boolean expressions where each
boolean expression involves only one variable.

\protect\hypertarget{anchor-2}{}{}Solution.

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

int x, y;

std::cin \textgreater\textgreater{} x \textgreater\textgreater{} y;

if (x \textless{} 0)

\{

x = 0;

\}

std::cout \textless\textless{} x \textless\textless{} ' ';

if (y \textless{} 0)

\{

y = 0;

\}

std::cout \textless\textless{} y \textless\textless{} ' ';

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Exercise.} Get an integer n from the user and then compute the
sum of the rightmost 4 digits of n. Once a digit 0 is added, you should
stop the summation. Do this with repetition code. Here's a test case

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\textbf{1534315}

13\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's another:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\textbf{1534015}

6\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(after adding \emph{5} and \emph{1}, on seeing a \emph{0}, the summation
stops. Therefore the sum is 6) and another

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\textbf{1534205}

5\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Here's the idea. First here's the code to sum the 4 rightmost digits:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

int n;

std::cin \textgreater\textgreater{} n;

int s = 0;

s = s + n \% 10;

n = n / 10;

s = s + n \% 10;

n = n / 10;

s = s + n \% 10;

n = n / 10;

s = s + n \% 10;

n = n / 10;

std::cout \textless\textless{} s \textless\textless{}
'\textbackslash n';

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Each block needs to know if a zero was encountered. So \ldots{}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

int n;

std::cin \textgreater\textgreater{} n;

int s = 0;

bool zero\_not\_found = true;

if (zero\_not\_found)

\{

s = s + n \% 10;

n = n / 10;

\}

if (zero\_not\_found)

\{

s = s + n \% 10;

n = n / 10;

\}

if (zero\_not\_found)

\{

s = s + n \% 10;

n = n / 10;

\}

if (zero\_not\_found)

\{

s = s + n \% 10;

n = n / 10;

\}

std::cout \textless\textless{} s \textless\textless{}
'\textbackslash n';

return 0;

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Get it? Think about what will happen if you don't use this communication
device \emph{zero\_not\_found}. You will most likely have a deeply
nested if-else structure in your code:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
if (n \% 10 != 0) // 1st digit != 0

\{

s = s + n \% 10;

n = n / 10;

if (n \% 10 != 0) // 2nd digit != 0

\{

s = s + n \% 10;

n = n / 10;

if (n \% 10 != 0) // 3rd digit != 0

\{

s = s + n \% 10;

n = n / 10;

if (n \% 10 != 0) // 4th digit != 0

\{

s = s + n \% 10;

n = n / 10;

\}

\}

\}

\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Later when I talk about loops and all the repeating blocks of code are
placed in a loop structure, you'll see that your can control a loop to
make it stop ``prematurely''.

Exercise

You have more than enough exercises in these notes already. Make sure
you go over all of them on your own.

Some Mental Math (DIY)

This section has nothing to do with programming. It's just for fun.

Suppose I told you that it's possible to multiply 98 and 97 very quickly
without paper and pencil or calculators or C++. Would you believe me? It
does require some practice, but there is a way to multiply two values a
little less than 100 very quickly.

Let me show you how with the 98 x 97 example. You subtract the numbers
from 100. So 100 -- 98 = 2 and 100 -- 97 = 3. Write this down on a piece
of paper:

9897

23

Now look at 98 and 3. Compute 98 -- 3. This is 95. You will need this
number. Note that 97 -- 2 is also 95. So there are two different ways of
getting 95 with the two diagonals. Write this down:

9897\textbf{95}

23

Now look at the 2 and 3. Multiply them together. You get 6. Write this
down:

989795\textbf{06}

23

That's it. Here's another example: 96 x 95. First you have:

9695

45

\hfill\break
Next you get

9695\textbf{91}

45

and finally

969591\textbf{20}

45

The answer is 9120. With some practice you will be able to do the
computation in your head. (Using algebra, you can actually prove that
the method does work.) So now you can show it off to your math teacher.

\end{document}
