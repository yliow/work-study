% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\author{}
\date{}

\begin{document}

23. Inline Functions

Objectives

\begin{itemize}
\tightlist
\item
  Write inline functions
\item
  Understand the difference between an inline function and a non-inline
  function
\item
  Write inline functions for multi-file compilation
\end{itemize}

This is a very short chapter because the concept of inline function is
pretty simple from a beginner programmer's point of view. But later on
you'll actually see inline functions popping up in many places (but in
an implicit and hidden way) especially in C++ templates, generic
programming, lambdas, metaprogramming. So understanding this concept is
very important for \emph{other} C++ features.

Inline functions

You have seen this before:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int max(int x, int y)

\{

if (x \textless{} y) return y;

else return x;\\
\}

int main()

\{

int m = max(3, 5);

std::cout \textless\textless{} m \textless\textless std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(For very simple if-else statements, the above style is OK.)

Now add one single keyword:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

\textbf{inline} int max(int x, int y)

\{

if (x \textless{} y) return y;

else return x;\\
\}

int main()

\{

int m = max(3, 5);

std::cout \textless\textless{} m \textless\textless std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Note that it's common to see this coding style:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
inline

int max(int x, int y)

\{

if (x \textless{} y) return y;

else return x;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

I suggest you use this style.

In terms of what a function can \textbf{do}, it doesn't make any
difference if a function is inlined or not. The only difference is
really in the speed of execution of the code.

An \textbf{inline function} is not exactly a function. When you compile
a program with an inline function, what happens is that the compiler
(more or less) copies the code to the place where you called the inline
function. In other words, when you get C++ to compile the following
program:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

inline

int max(int x, int y)

\{

if (x \textless{} y) return y;

else return x;\\
\}

int main()

\{

int m = max(3, 5);

std::cout \textless\textless{} m \textless\textless std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

your compiler reads the program into its memory and changes it to this:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

int main()

\{

int m;

if (3 \textless{} 5) m = 5;

else m = 3;

std::cout \textless\textless{} m \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

before generating the executable. There is really no \emph{max()}
function. In other words, an inline function is like a rubber stamp for
a chunk of code.

If your code calls the inline \emph{max()} function 100 times, the body
of \emph{max()} is copied 100 times.

Note that the copying of the body of the function to the places where
the function is called is done when the compiler builds an executable
file. Your actual cpp file is not changed; the above modification is
done in the compiler's memory. You do not see the code duplicated in
your source file.

\textbf{Exercise. }Write an inline \emph{min()} function. Test your
function.

Why inline functions?

Why do we have inline functions?

Like I said it's faster (see caveat later). Why?

Because there is some CPU cost in just making a function call. Look at
the notes on Functions. Recall that to make a function call, the CPU
must set up a stack which contains at least information on how to go
back to the caller function. That takes time. It's the same when a
function call returns. In other words, just \textbf{the act of calling
the function and returning from a function call} (i.e. not including the
computation done in the body of function called) \textbf{takes time}. In
fact it's even possible that the cost of making a function call and
returning from the call takes more time than the actual computation in
the body of the function!!!

Inline functions calls do \emph{\textbf{not}} involve function calls at
all because the inline function's body has already been copied to the
place where you make the function call.

``When should I inline a function?''

Now you might say: ``In that case, let's inline every function! That
will make my program super fast!''

Well ...

Yes, you can inline any function.

The problem is that the your program might become larger than what it
should be.

Good choices for functions to be changed to inline functions are those
which are very small, especially those which are used frequently.
Function bodies with only one or two lines of code are good candidates.

Now for some caveats \ldots{}

\begin{itemize}
\tightlist
\item
  If the compiler feels that the function body is too huge, it might
  actually ignore your request to inline a function. So an inline
  function is only a \emph{\textbf{request}} to the compiler to inline
  the function.
\item
  Some C++ compilers actually honor inline requests unless told it to do
  otherwise.
\item
  If too many functions are inlined, the executable binary code can be
  huge, which of course means that you need more memory to run the code
  which means that you might be slowing it down!!! If the executable
  binary code is too huge it might cause memory thrashing where memory
  pages constantly gets swapped in and out of your computer memory.
\end{itemize}

Multi-file compilation

Although an inline function is similar to a regular function, there is
\textbf{one difference} if you want to use inline functions in a
multi-file project.

The whole inline function (with the function body) goes into the header
file. You do NOT write prototypes for inline functions.

Here's our max example using a header file and a separate cpp file. It
\emph{\textbf{won't}} work. Try it now and look at the error message:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

\#include "test.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// test.h

\#ifndef TEST\_H

\#define TEST\_H

inline

int max(int x, int y); // prototype of max

\#endif\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// test.cpp

\#include "test.h"

inline

int max(int x, int y) // definition of max

\{

if (x \textless{} y) return y;

else return x;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Do this instead:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
\#include \textless iostream\textgreater{}

\#include "test.h"

int main()

\{

std::cout \textless\textless{} max(3, 5) \textless\textless{} std::endl;

return 0;\\
\}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// test.h

\#ifndef TEST\_H

\#define TEST\_H

inline

int max(int x, int y)

\{

if (x \textless{} y) return y;

else return x;\\
\}

\#endif\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

(You can get rid of the test.cpp file) Now it works.

Remember that if you want to have multi-file projects and your inline
functions are not in your main cpp file, then the \textbf{inline
function bodies must be in header files}. Don't you forget that!

Note that you can have prototypes for inlined function:

\begin{longtable}[]{@{}l@{}}
\toprule
\endhead
\begin{minipage}[t]{0.97\columnwidth}\raggedright
// test.h

\#ifndef TEST\_H

\#define TEST\_H

int max(int x, int y);

inline

int max(int x, int y)

\{

if (x \textless{} y) return y;

else return x;\\
\}

\#endif\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The inline keyword follows the function definition. You do not need the
inline keyword for the prototype. Make sure you run this so that you
remember how to write inlined prototypes. It will be very important when
you get into very complex modern C++ programming.

You can also check that if you do use the inline keyword for the
prototype, your compiler most likely will not give you an error.

\textbf{Exercise.} In the above, add an inline \emph{min} function in
the header file to compute the minimum of two integer functions and then
an inline \emph{swap} function to swap the values of two integer
variables.

\end{document}
