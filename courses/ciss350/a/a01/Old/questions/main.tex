%-*-latex-*-
\input{myassignmentpreamble.tex}
\input{yliow}
\input{ciss350}
\renewcommand\TITLE{Assignment 1}

\begin{document}

\topmatter


\textsc{Objectives}
\begin{enumerate}[topsep=0pt]
\item Review of CISS240/CISS245 including variables, input/output, branching, 
loops, arrays, pointers, functions.
\end{enumerate}

The format of your program must look like this:

\begin{Verbatim}[frame=single]
// Name: smaug
// File: a01q01.cpp

#include <iostream>

int main()
{
    *** YOUR WORK HERE ***
    return 0;
}
\end{Verbatim}
replacing \lq\lq smaug'' with your name.
In particular:
\begin{enumerate}
\item You must have your name and the name of the file at the top of each 
C++ source file as shown above.
\item The last thing printed must be a newline.
\end{enumerate}

Read the questions carefully before diving in.

Note that you should create a new project for each question. 
For easy maintenance of your assignments, 
I suggest you have a folder \verb!ciss350! somewhere in your 
\verb!Documents!, 
and in that you have a folder 
\verb!a!, 
and in folder a you have a folder 
\verb!a01!, 
and you have solutions folders 
\verb!a01q01!,
\verb!a01q02!, etc. in the folder 
\verb!a01!:

\begin{verbatim}
  .
  .
  .
  ciss350
  |
  +- a
     |
     +- a01
        |
        +- a01q01
        |
        +- a01q02
\end{verbatim}

All the relevant files (cpp and header files) for question 1 
must be in folder \verb!a01q01!. Etc.

Some test cases are included in the problems.
You are strongly advised to add more test cases on your own.
\newpage


\newpage
Q1.
\input{../a01q01/question/main.tex}



\newpage
Q2.
\input{../a01q02/question/main.tex}


\newpage
Q3. 
\input{../a01q03/question/main.tex}

\newpage
The next two questions involve the computation of magic squares.
First, google and read up about magic squares.

For us an $n$-by-$n$ magic square  is an $n$-by-$n$ grid filled with the 
numbers $1, 2, 3, ..., n^2$ such that each row and each column
and each of the two diagonals add up to the same number.
Here's a 3-by-3 magic square:
\begin{longtable}{|c|c|c|}
\hline
2 & 7 & 6 \\ \hline
9 & 5 & 1 \\ \hline
4 & 3 & 8 \\ \hline
\end{longtable}

Our goal is to find magic squares. 

One way (a very bad way) to find magic squares say for a 3-by-3 grid
is to run through all the numbers 1--9 for each cell in the grid.
Here's such a list of potential magic squares (including 0s as well):
\begin{longtable}{|c|c|c|}
\hline
0 & 0 & 0 \\ \hline
0 & 0 & 0 \\ \hline
0 & 0 & 0 \\ \hline
\end{longtable}
\begin{longtable}{|c|c|c|}
\hline
0 & 0 & 0 \\ \hline
0 & 0 & 0 \\ \hline
0 & 0 & 1 \\ \hline
\end{longtable}
\begin{longtable}{|c|c|c|}
\hline
0 & 0 & 0 \\ \hline
0 & 0 & 0 \\ \hline
0 & 0 & 2 \\ \hline
\end{longtable}
\[ ... \]
\begin{longtable}{|c|c|c|}
\hline
9 & 9 & 9 \\ \hline
9 & 9 & 9 \\ \hline
9 & 9 & 7 \\ \hline
\end{longtable}
\begin{longtable}{|c|c|c|}
\hline
9 & 9 & 9 \\ \hline
9 & 9 & 9 \\ \hline
9 & 9 & 8 \\ \hline
\end{longtable}
\begin{longtable}{|c|c|c|}
\hline
9 & 9 & 9 \\ \hline
9 & 9 & 9 \\ \hline
9 & 9 & 9 \\ \hline
\end{longtable}
Note that this 
is the same as running over the following sequence of arrays
\begin{verbatim}
   0,0,0,0,0,0,0,0,0
   0,0,0,0,0,0,0,0,1
   0,0,0,0,0,0,0,0,2
   ...
   9,9,9,9,9,9,9,9,7
   9,9,9,9,9,9,9,9,8
   9,9,9,9,9,9,9,9,9
\end{verbatim}
For each array, you simply check that if conditions for being a magic 
square are satisfied. If so, you have found a 3-by-3 magic square.

The above is an example
of solving a problem by searching.
This method is obviously not very smart therefore is not fast.
In CS there are (at least) three general methods to search for solutions:
brute force search, branch-and-bound search, and heuristic search.
The above is a brute force search.
In CISS350, we might have some search
examples but we will not cover heuristic search -- that's covered in 
the AI class.
For another example of brute force search, look for the perfect number 
problem in the review problems set.

To use the above (bad) technique, we will need to 
generate the list
\begin{verbatim}
   0,0,0,0,0,0,0,0,0
   0,0,0,0,0,0,0,0,1
   0,0,0,0,0,0,0,0,2
   ...
   9,9,9,9,9,9,9,9,7
   9,9,9,9,9,9,9,9,8
   9,9,9,9,9,9,9,9,9
\end{verbatim}
This is only for the case of 1-9 for each cell, i.e., for the
3-by-3 magic square case.
To find 4-by-4 magic squares, we need to fill the 
cells with values from 1 to 16.
etc.
Q4 deals with this problem.

Q5 then uses Q4 to generate potential magic squares and 
prints out only those that are really magic squares.

The point of the next two questions is just to practice 
computations using arrays (and to also introduce 
a particular search problem in CS.)


\newpage
Q4. 
If you run a for-loop on \verb!i! running from 0 to 100 and print out the
values, you see the following where I've separated the digits of \verb$i$
by commas and also I've padded the integer so that there are exactly
4 digits:
\begin{console}
0,0,0
0,0,1
0,0,2
...
0,0,9
0,1,0
0,1,1
0,1,2
0,1,3
...
0,9,8
0,9,9
1,0,0
\end{console}
Note that once a column $c$ reaches \verb!9!, the next number
will result in that column being reset to \verb!0! and a carry
to the next column, i.e., column $c$ + 1.
You can also go through the same process but instead of performing a carry
after \verb!9!, you can have a carry after \verb!15!:
\begin{console}
0,0,0
0,0,1
0,0,2
...
0,0,9
0,0,10
0,0,11
0,0,12
0,0,13
0,0,14
0,0,15
0,1,0
0,1,1
0,1,2
0,1,3
...
0,15,14
0,15,15
1,0,0
\end{console}
And of course you can have more than 3 columns, say 4 columns:
\begin{console}
0,0,0,0
0,0,0,1
0,0,0,2
...
0,0,0,9
0,0,0,10
0,0,0,11
0,0,0,12
0,0,0,13
0,0,0,14
0,0,0,15
0,0,1,0
0,0,1,1
0,0,1,2
0,0,1,3
...
0,0,15,14
0,0,15,15
0,1,0,0
\end{console}
You are basically working with base 16 numbers, i.e., hexadecimals.
In the above case, the base is said to be 16.
In our usual \lq\lq human'' number system, we use base 10.
Let's put the digits into an array.
For instance \verb!0,0,15,14! can obviously be placed in an array
\verb!digits! of size 4 so that
\begin{verbatim}
    digits[0] = 14, digits[1] = 15, digits[2] = 0, digits[3] = 0
\end{verbatim}

Write a function
\begin{console}[commandchars=\\\{\}]
void increment(int digits[], int len_digits, int base);
\end{console}
that modifies the array \verb!digits! to give you the next one
as in the above list. 
So for instance if \verb!digits! is the above array
\begin{verbatim}
    digits[0] = 14, digits[1] = 15, digits[2] = 0, digits[3] = 0
\end{verbatim}
then after calling
\begin{console}
increment(digits, 4, 16)
\end{console}
we have
\begin{verbatim}
    digits[0] = 15, digits[1] = 15, digits[2] = 0, digits[3] = 0
\end{verbatim}
and calling it one more time gives us
\begin{verbatim}
    digits[0] = 0, digits[1] = 0, digits[2] = 1, digits[3] = 0
\end{verbatim}
Here's the skeleton:
\begin{console}[commandchars=\~\!\@]
#include <iostream>

void increment(int digits[], int len_digits, int base)
{
}

void print(int digits[], int len_digits)
{
    for (int i = len_digits - 1; i >= 1; --i)
    {
        std::cout << digits[i] << ',';
    } 
    std::cout << digits[0] << std::endl;
}

int main()
{
    int digits[4] = {0};
    for (int i = 0; i < 100; ++i)
    {
        print(digits, 4);
        increment(digits, 4, 16);
    }
    return 0;
}
\end{console}


\newpage
Q5. (Do not use \verb!std::vector!.)

The following gives you the format that you must follow:
\begin{console}
+--+--+--+ 
| 2| 7| 6| 
+--+--+--+ 
| 9| 5| 1|
+--+--+--+ 
| 4| 3| 8|
+--+--+--+
+--+--+--+ 
| 4| 9| 2| 
+--+--+--+ 
| 3| 5| 7|
+--+--+--+ 
| 8| 1| 6|
+--+--+--+ 
\end{console}
(This is \textit{not} the complete list for $3$-by-$3$ case --
it's just for me to show you the format of the printout.)
Of course in the case of a 4-by-4 magic square you have to fill each
cell with numbers from 1 to $4^2 = 16$.

Write a program that accepts a value for $n$ and prints all the
$n$--by--$n$ magic squares using the above method according to the 
above display format. You will of course need Q4 so that
you can loop through all the potential $n$--by--$n$ magic squares.

(You need to think about when to stop the loop.
And you should think a little about improving on the method
to improve the performance of the program.)

\end{document}
