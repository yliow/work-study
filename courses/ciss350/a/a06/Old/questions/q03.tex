%-*-latex-*-
Implement a list-based stack.
As mentioned in class, a singly linked list can be used where the 
top of the stack corresponds to the head (not the tail!)
The following is what you can do:
\begin{console}[fontsize=\footnotesize,commandchars=\\\{\}]
Stack< int > stack;
stack.push(5);            // Top of stack is 5
stack.push(6);            // Top of stack is 6 (5 is below 6)
stack.push(4);            // Top of stack is 4 (6 is below 4)
stack.pop();              // Top of stack is 6 (5 is below 6)
int x = stack.top();      // x has value 6
stack.top() = 7;          // Top of stack is 7 (5 is below 7)
int size = stack.size();  // size has value 2
bool b = stack.is_empty();// b has value false
stack.clear();            // stack.size is 0
                          // Calling stack.pop() here will
                          // result in the throwing of an 
                          // UnderflowError object
\end{console} 
Here's the skeleton:
\begin{console}[fontsize=\footnotesize]
// Stack.h
class UnderflowError      // An UnderflowError object is thrown if
{};                       // you execute pop() on an empty stack.

template < typename T >
class Stack
{
public:

private:
    SLList< T > list_;
};
\end{console}
(I'm using composition instead of inheritance.)

Once the singly linked list is done, the stack class is extremely easy.
So you must finish the singly linked list class first.
