\textsc{Sieve of Eratosthenes}

The sieve of \href{https://en.wikipedia.org/wiki/Eratosthenes}{Eratosthenes} is a method to compute
primes up to a certain positive integer $n$.
The following illustrates the idea.

Let's compute all the prime up to 99.
Create an array \verb!x! of size 100, i.e.,
you have
\verb!x[0]!,
\verb!x[1]!,
\verb!x[2]!, ...
\verb!x[99]!.
After we're done with the computation, 
\verb!x[i]! will be \verb!1! if \verb!i! is a prime.
For instance when the computation ends,
the first 7 values in \verb!x! which are \verb!1! are
\verb!x[2]!,
\verb!x[3]!,
\verb!x[5]!,
\verb!x[7]!,
\verb!x[11]!,
\verb!x[13]!,
\verb!x[17]!.
Therefore from the array, you can tell that
\verb!2!,
\verb!3!,
\verb!5!,
\verb!7!,
\verb!11!,
\verb!13!,
\verb!17!
are all primes.
However
\verb!x[0]!,
\verb!x[1]!,
\verb!x[4]!,
\verb!x[6]!,
\verb!x[8]!,
\verb!x[9]!,
\verb!x[10]!,
\verb!x[12]!,
\verb!x[14]!,
\verb!x[15]!,
\verb!x[16]!
and all \verb!0! because
\verb!0!,
\verb!1!,
\verb!4!,
\verb!6!,
\verb!8!,
\verb!9!,
\verb!10!,
\verb!12!,
\verb!14!,
\verb!15!,
\verb!16!
are not primes.
By counting the number of \verb!1!'s in \verb!x!, you will then have
the number of primes up to \verb!99!.

Here's the idea of the algorithm.
First initialize 
\verb!x[0]! and 
\verb!x[1]! to \verb!0! (since \verb!0! and \verb!1! are not
primes)
and all other values of \verb!x! to \verb!1!.
Now we begin.

The first value of \verb!x! that is \verb!1! is at index \verb!2!.
Therefore \verb!2! is a prime.
Call it a killer prime.
\verb!2! will now kill off all the multiple of \verb!2! except for \verb!2!,
i.e.,
you set
\verb!x[4]!,
\verb!x[6]!,
\verb!x[8]!,
\verb!x[10]!,...
\verb!x[98]! to \verb!0!.
Remember that you are at index \verb!2!.

Now for the next stage, from index \verb!2!, go to the next
index \verb!i! such that \verb!x[i]! is \verb!1!.
This would be \verb!x[3]!.
So \verb!3! is the next killer prime.
\verb!3! will kill of all the multiples of \verb!3! except for \verb!3!, i.e., 
you set
\verb!x[6]!,
\verb!x[9]!,
\verb!x[12]!,
\verb!x[15]!,...,
\verb!x[99]! to \verb!0!.
(Note that \verb!x[6]! was already set to \verb!0! by
killer prime \verb!2!.
So \verb!x[6]! is set to \verb!0! twice.)
Recall that you are at index \verb!3!.

Now from index \verb!3!, go to the next
index \verb!i! such that \verb!x[i]! is \verb!1!.
This would be \verb!x[5]!.
So \verb!5! is the next killer prime.
\verb!5! will kill of all the multiples of \verb!5! except for 5, i.e., 
you set
\verb!x[10]!,
\verb!x[15]!,
\verb!x[20]!,
\verb!x[25]!,...
\verb!x[95]! to \verb!0!.

Go to the next
index \verb!i! such that \verb!x[i]! is \verb!1!.
This would be \verb!x[7]!.
So you set
\verb!x[14]!,
\verb!x[21]!,
\verb!x[28]!,
\verb!x[35]!,...
\verb!x[98]! to \verb!0!.

If you keep doing this, you'll see that
an index value \verb!i! is a prime exactly when
\verb!x[i]! is \verb!1!.
By counting all such \verb!i! values, you will then
have all the primes from 0 to 99.

Another thing to note is that you don't have to
locate the killer primes all the way up to 99.
You can in fact stop the search for killer primes
beyond $\sqrt{99} \approx 9.95$.
For instance, if you continue algorithm above beyond \verb!7!,
the next killer prime would have been \verb!11!.
But the multiples of \verb!11! greater than \verb!11!
are
\verb!22!,
\verb!33!,
\verb!44!,
\verb!55!,
\verb!66!,
\verb!77!,
\verb!88!, and
\verb!99!,
and these are already killed by
\verb!2!,
\verb!3!,
\verb!2!,
\verb!5!,
\verb!2!,
\verb!7!,
\verb!2!,
\verb!3!.

(Extra challenge especially if you have taken discrete 1, MATH225,
you should try to prove
that for the general case of performing Erathothenes sieve on $n$,
the algorithm does find all the primes when the search for kill primes
terminate at $\sqrt{n}$.)

You should trace the above on paper, then write down the pseudocode,
and then translate into \cpp.
You are also strongly advised to create more test cases.

(Instead of using an integer array that contains
\verb!0!'s
and
\verb!1!'s,
another option is to use
an array of boolean values.)
