\texttt{\bf operator==}

Note that if \verb!x! and \verb!y! are \verb!Fraction! values, then
\begin{console}
x == y
\end{console}
is the same as
\begin{console}
operator==(x, y)
\end{console}

The prototype of \verb!operator==()! is
\begin{console}
bool operator==(const Fraction &, const Fraction &);
\end{console}

Define \verb!operator==! so that when \verb!operator==! is called with two
\verb!Fraction! variables, the return value is true exactly when the
\verb!Fraction! values have the same mathematical value.

Mathematically, two fractions
\[
\frac{a}{b} \text{ \ \ \ and \ \ \ }
\frac{c}{d}
\]
are the same, i.e.,
\[
\frac{a}{b} =
\frac{c}{d}
\]
if
\[
ad = bc \tag{A}
\]

Note that this is \textit{not} the same as
\[
           a = c \text{ \ \ \ and \ \ \ } b = d
           \tag{B}
\]
which is \textit{incorrect}. For instance, the fractions $\frac{1}{2}$ and
$\frac{2}{4}$ are the same which is correctly detected by condition (A) but
not (B).

You are to print out the boolean value resulting from the comparison between
fractions.

Add the prototype to \verb!Fraction.h! and the following test code to
\verb!main()!:
\begin{console}[commandchars=\~\!\@]
void test_eq()
{
    int n0, d0;
    int n1, d1;
    std::cin >> n0 >> d0 >> n1 >> d1;
    Fraction f = {n0, d0};
    Fraction g = {n1, d1};
    std::cout << (f == g) << std::endl;
    return;
}
\end{console}
This is test option 6. Here is a test case:

\textbf{Test 1:}
\begin{Verbatim}[frame=single, commandchars=\\\{\}]
\underline{6 1 3 2 6}
1
\end{Verbatim}

Add more test cases to \verb!stdin.txt!.
