%-*-latex-*-
The concept of an array can simulate the notation of a \lq\lq container".
A container is conceptually a data structure (i.e., variable(s) and 
function(s) together) that allows us to hold values and we can either put
values into or get values out from the container. A container starts off by
being empty:
\[[\,\,]\]
Suppose we put $5$ into the container. Conceptually the container now looks
like this:
\[[\,\,5\,\,]\]
At this point, suppose we want to put $9$ into the container. Where will it
go? After putting the value $9$ into the container, the container can be either
\[[\,\,9,\,\,5\,\,]\]
or
\[[\,\,5,\,\,9\,\,]\]

So we need to be more precise about describing the operation. Note also that
our concept of an array has a fixed size whereas a container's size can change.
How do we use an array to model a container? We need an array and another
variable to denote the number of things already placed in the array. Let's call
our array \verb!x! and suppose that it's an array of integer values of size
$5$. Let's say we initialize the array with zeroes. Let's call the number of
things in the container \verb!len! (for length). For instance,

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,5,\,\,9\,\,]$ & \hspace{3 cm}\verb!x = {5, 9, 0, 0, 0},  len = 2!
\end{longtable}

On the left we see the concept we want to model and on the right we see the
actual implementation in a programming language (for instance C++.) Of course,
array \verb!x! actually has $5$ values. But the \verb!len! variable tells us
that we should only consider \verb!x[0]! and \verb!x[1]! as values we put into
the container; we simply ignore other values
\verb!x[2]!,
\verb!x[3]!,
\verb!x[4]!.
Since we ignore \verb!x[2]!,
\verb!x[3]!,
\verb!x[4]!.
This could work too:

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,5,\,\,9\,\,]$ & \hspace{3 cm}\verb!x = {5, 9, 78, 79, 80},  len = 2!
\end{longtable}

If the
container has values $5, 3, 6, 2$ then

\begin{longtable}{ll} 
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,5,\,\,3,\,\,6,\,\,2\,\,]$ & \hspace{3 cm}\verb!x = {5, 3, 6, 2, 0},  len = 4!
\end{longtable}

Since \verb!len! has value \verb!4!, we only consider
\verb!x[0]!,
\verb!x[1]!,
\verb!x[2]!, and
\verb!x[3]! values in the container and
ignore \verb!x[4]!.
The following works too:

\begin{longtable}{ll} 
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,5,\,\,3,\,\,6,\,\,2\,\,]$ & \hspace{3 cm}\verb!x = {5, 3, 6, 2, 99},  len = 4!
\end{longtable}

From now on, I will write \verb!?! for values in the array that
we will ignore.
So in the previous example above, I will write this:

\begin{longtable}{ll} 
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,5,\,\,3,\,\,6,\,\,2\,\,]$ & \hspace{3 cm}\verb!x = {5, 3, 6, 2, ?},  len = 4!
\end{longtable}

Remember that when you see \verb!?! it does not mean that there's no
value there -- there \textit{is} a value.
It's just a value we don't care about.

There are two main things you can do to a container:
you can put something into the container and the you
take something out of the container.
Let me explain these two operations.

Let's call the operation to put a value into the container \lq\lq insert".
Initially, the container looks like this:

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,]$ & \hspace{3 cm}\verb!x = {?, ?, ?, ?, ?},  len = 0!
\end{longtable}

In other words, initially, the container has nothing.

We can insert a value into the container.
To do so, we have to specify the index position.
For instance when we insert a $5$ at index position $0$ we get this:

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,5\,\,]$ & \hspace{3 cm}\verb!x = {5, ?, ?, ?, ?},  len = 1!
\end{longtable}

Now the container has one value, i.e., $5$ at index 0.
If we now insert $9$ at index position $0$ we get this:

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,9,\,\,5\,\,]$ & \hspace{3 cm}\verb!x = {9, 5, ?, ?, ?},  len = 2!
\end{longtable}

Notice that $5$ is shifted to the right by one position.
Now if we insert $11$ at index position $1$ we get this:

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,9,\,\,11,\,\,5\,\,]$ & \hspace{3 cm}\verb!x = {9, 11, 5, ?, ?},  len = 3!
\end{longtable}

If we insert $1$ at index position $3$ we get

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,9,\,\,11,\,\,5,\,\,1\,\,]$ & \hspace{3 cm}\verb!x = {9, 11, 5, 1, ?},  len = 4!
\end{longtable}

Now let me talk about removing a value from the container.
If we remove the value at position $2$, we get

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,9,\,\,11,\,\,1\,\,]$ & \hspace{3 cm}\verb!x = {9, 11, 1, ?, ?},  len = 3!
\end{longtable}

Look at the array \verb!x! and \verb!len! carefully. Note that the
\verb!len! $= 3$ tells us that the container we're modeling has three values,
therefore \verb!x[0]! $= 9$, \verb!x[1]! $= 11$, \verb!x[2]! $= 1$ are the
only values in the container; we ignore \verb!x[3]! and \verb!x[4]!.

If we now remove the value at position $0$, we get

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,11,\,\,1\,\,]$ & \hspace{3 cm}\verb!x = {11, 1, ?, ?, ?},  len = 2!
\end{longtable}

Get it? Note that you can only insert and remove at certain places.
For instance, right now we have

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,11,\,\,1\,\,]$ & \hspace{3 cm}\verb!x = {11, 1, ?, ?, ?},  len = 2!
\end{longtable}

You can only insert at position $0, 1, 2$ and remove at position $0, 1$.

For this assignment, if you insert or remove not within the valid range, the
variables are not changed. For instance, if we insert $7$ at position $4$ or
remove the value at position $3$, the container is still the same:

\begin{longtable}{ll}
concept to model & \hspace{3 cm}variables implementing the concept \\
$[\,\,11,\,\,1\,\,]$ & \hspace{3 cm}\verb!x = {11, 1, ?, ?, ?},  len = 2!
\end{longtable}

In the general case, if the container has length \verb!len!, you can insert at
index positions $0, 1, 2, \dots$, \verb!len! if \verb!len! is less than the
size of the array and you can remove the value at index position
$0, 1, 2, \dots$, \verb!len! $-\,1$.

The goals of this assignment is to build such a container using an array and a
length variable. 

(Note that if you restrict the usage of the container so that you only insert
at position \verb!len - 1!  and remove only at the index
position \verb!0!, i.e., values go into the container
at one end and go out from the \textit{other end},
you are then simulating a \textbf{queue}.
Queues occur frequently in the real world.
Examples
include a manufacturing line. An industrial engineer is interested in, for
instance, how frequently the queue of a manufacturing
line is congested based on the probabilistic
distribution of items entering and leaving the queue. Queues are also used
for computer network communication.
Now, suppose you only insert at \verb!len - 1! and remove at
\verb!len - 1!, i.e., the values go into the container at one end and also
the container at the \textit{same end}, then you're simulating a
\textbf{stack}.
You have seen that before: think of a stack of plates at a buffet:
plates go into the container of plates at the top and plates
leave the container at the top.
Stacks are called last-in-first-out (LIFO) containers
while queues are called first-in-first-out (FIFO) containers.
Both the stack and queue are very important
and are used extensively in computer science
including artificial intelligence, computer networks, computer graphics, etc.)

The following code skeleton is given. Here we are simulating our container
with a maximum size of $5$. The container contains integer values (the main
idea can be applied to an array of any type of values.) The program continually
prompts the user for an option: $0$ is to quit, $1$ is to insert, $2$ is to
remove. If the user enters an option not in the above choices, the program
reprompts the user. If the user enters $1$, the program prompts the user for
a position and a value to insert into the container. If the user enters $2$,
the program prompts the user for a position and removes the value at the
position. If the user enters an invalid position, the program does not perform
the requested option. If the user attempts to insert a value into the container
when it's already full, no action is taken. See the test cases.

Your functions must work for arrays of any size. Therefore, you should not
assume the array has at most $5$ elements. (See hints below.)

Note that the \verb!insert! and \verb!remove! functions do not only change the
array, they must change the \verb!len! variable as well. You already know that
functions cannot change the values of variables in the calling function.
For instance,

\begin{Verbatim}[frame=single,fontsize=\footnotesize]
#include <iostream>

void inc(int x)
{
    x++;
}

int main()
{
    int a = 5;
    inc(a);
    std::cout << a << std::endl; // value of a is still 5

    return 0;
}
\end{Verbatim}

If you want the function to modify the variable in the caller function, you
make the variable a reference variable. Try this:

\begin{Verbatim}[frame=single,fontsize=\footnotesize]
#include <iostream>

void inc(int & x) // x *will* affect the a in main()
{
    x++;
}

int main()
{
    int a = 5;
    inc(a);
    std::cout << a << std::endl; // a is changed!

    return 0;
}
\end{Verbatim}

Note that parameter \lq\lq \verb!int x!" is changed to \lq\lq \verb!int & x!".
This tells C++ that the parameter will affect the corresponding variable in
the caller function. Note that in the functions \verb!insert()! and
\verb!remove()!, the \verb!len! parameter is a reference variable. Note once
again that our container is described by three variables: the array \verb!x!,
the \verb!len! which denotes the number of things in the container, and
\verb!size! which describes the maximum number of values you can have in the
container.

\begin{Verbatim}[frame=single,fontsize=\footnotesize]
#include <iostream>

void println(int x[], int len)
{
    std::cout << "[ ";
    for (int i = 0; i < len; i++)
    {
        std::cout << x[i] << ' ';
    }
    std::cout << "]" << std::endl; 
}


// Inserts newvalue into container x at position index
void insert(int x[], int & len, int size, int index, int newvalue)
{
}


// Removes the value at position index of the container x
void remove(int x[], int & len, int size, int index)
{
}


int main()
{
    const int SIZE = 5;
    int x[SIZE] = {0};
    int len = 0;
    println(x, len);

    while (1)
    {
        int option = 0;
        std::cout << "option (0-quit, 1-insert, 2-remove): ";
        std::cin >> option;
        // Break the while loop if option is 0        
        
        // Prompt for index
        switch (option)
        {
             case 1:
                 // Prompt for new value and call the insert() function.
                 break;

             case 2:
                 // Call the remove() function.
                 break;
        }

        std::cout << std::endl;
        println(x, len);
    }

    return 0;
}
\end{Verbatim}


\resett
\nextt
\begin{console}[frame=single, commandchars=\\\{\}]
[ ]
option (0-quit, 1-insert, 2-remove): \userinput{0}
\end{console}

\nextt
\begin{console}[frame=single, commandchars=\\\{\}]
[ ]
option (0-quit, 1-insert, 2-remove): \userinput{1}
index: \userinput{7}
value: \userinput{2}

[ ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{4}

[ ]
option (0-quit, 1-insert, 2-remove): \userinput{0}
\end{console}

\nextt
\vspace{-6pt}
\begin{Verbatim}[frame=single, fontsize=\footnotesize,commandchars=\\\{\}]
[ ]
option (0-quit, 1-insert, 2-remove): \userinput{1}
index: \userinput{0}
value: \userinput{7}

[ 7 ]
option (0-quit, 1-insert, 2-remove): \userinput{1}
index: \userinput{0}
value: \userinput{3}

[ 3 7 ]
option (0-quit, 1-insert, 2-remove): \userinput{1}
index: \userinput{1}
value: \userinput{2}

[ 3 2 7 ]
option (0-quit, 1-insert, 2-remove): \userinput{1}
index: \userinput{3}
value: \userinput{8}

[ 3 2 7 8 ]
option (0-quit, 1-insert, 2-remove): \userinput{1}
index: \userinput{1}
value: \userinput{4}

[ 3 4 2 7 8 ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{0}

[ 4 2 7 8 ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{4}

[ 4 2 7 8 ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{3}

[ 4 2 7 ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{1}

[ 4 7 ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{1}

[ 4 ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{0}

[ ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{0}

[ ]
option (0-quit, 1-insert, 2-remove): \userinput{2}
index: \userinput{0}

[ ]
option (0-quit, 1-insert, 2-remove): \userinput{0}
\end{Verbatim}


\newpage
\textsc{Hint: SPOILERS AHEAD!!! WATCHOUT!!!}

\begin{itemize}
  \li If you want to insert at a position, you need to move the values
      starting at the index position to the right by one from the index
      position where insertion is to occur. Use a for--loop!!! Once that's
      done, you put the new value at the index position where insertion
      should occur. You should increment the \verb!len! variable. For instance,
      suppose the array has \verb!len! $5$ (and is, say, of \verb!size! $10$)
      and you need to insert a value of $6$ at index position $2$. Say the
      array looks like this:
      \[\verb!x!: 3, 7, 2, 7, 8, ?, ?, ?, ?, ?\]
      You need to write a for--loop to copy the values from index $2$ onward
      to the right by one step:
      \[\verb!x!: 3, 7, 2, 7, 8, ?, ?, ?, ?, ?\]
      \begin{center}
      \begin{tikzpicture}
        \draw[->](0,0.5) -- (0,0);
      \end{tikzpicture}
      \end{center}
      \[\verb!x!: 3, 7, 2, \underline{\mathbf{2, 7, 8}}, ?, ?, ?, ?\]
and then you put $6$ at index $2$:
      \[\verb!x!: 3, 7, \underline{\mathbf{6}}, 2, 7, 8, ?, ?, ?, ?\]

  \li If you want to remove the value at an index position, you move all the
      values to the right of that index position to the left by one index
      position. Once that's done, you need to decrement the \verb!len!
      variable. The idea is very similar to the case of inserting a value
      into the array except that you're moving a chunk of values in the
      opposite direction. For instance, suppose you have the following with
      \verb!len! $6$:
      \[\verb!x!: 3, 7, 6, 2, 7, 8, ?, ?, ?, ?\]
      Then, to remove the value at index position $3$, (i.e., the value $2$)
      you simply copy all the values to the right of $2$
      \[\verb!x!: 3, 7, 6, 2, \underline{\mathbf{7, 8}}, ?, ?, ?, ?\]
      to the left by one to get this:
      \[\verb!x!: 3, 7, 6, \underline{\mathbf{7, 8}}, ?, ?, ?, ?, ?\]
      and decrement the \verb!len! variable by $1$.
\end{itemize}
