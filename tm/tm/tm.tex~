\section{Turing Machines}


Informally, a Turing machine (TM) is like a DFA or a PDA except for
the following:
\begin{itemize}
\item For the DFA (and PDA), the machines read the input string one
 character at a time from the leftmost character to the rightmost. A
 TM can also read the input one character at a time. However
 the input string should be thought of as being written on an
 infinitely long tape; you should think of the tape as being padded
 infinitely to the right with blanks. The TM can actually write to it
 as well. Therefore you should think of the TM as having a read/write
 head that moves along an infinitely long string.
 Furthermore, the read/write head can move either
 left or right or it can also stay. The only restriction is that it
 must stay on the infinitely tape.
\item For the DFA, acceptance is
 determined by what the state the machine is in once the string is
 completely read. For the TM, since the input string is written on an
 infinite tape, there is really no end-of-string. Therefore for a TM, a string is
 accepted if the machine enters an accepting state, regardless of the
 position of the read/write head.
\end{itemize}

Even without a formal definition of a TM, you probably know by now
that the most important thing about running the TM is that you need
to know what happens when the machine is in a particular state and
it is about to read a particular character. What if the machine
capable of doing? Well, obviously it has to go to another (possibly
the same) state. It can overwrite the character it is reading; this
is sort of like the PDA. Furthermore it can move it's read/write
head either to the left or right or it stays. So the transition
function should look like:

\[\delta(q, a) = (p, b, D)\]

where $q$ and $p$ are states, $a$ and $b$ are the allowable
characters on the infinite tape and $D$ refers to the direction
moved by the read/write head. $D$ can take values $L$ (for left),
$S$ (for stay) and $R$ (for right).

Here's the formal definition. Most of this won't be a surprise to
you by now. There's one thing I should mention. We will distinguish
between the alphabet of the string used to generate a language (the
$\Sigma$) and the alphabet that the TM can write on the tape.

\begin{defn}
A {\bf Turing machine} TM $M$ is made up of
\begin{itemize}
 \item $Q$: a finite set of states.
 \item $\Sigma$: a finite set of input alphabet.
 \item $\Gamma$: a finite set of alphabet the TM using for read and write.
 $\Sigma$ is a subset of $\Gamma$.
 Furthermore the blank character is also in $\Gamma$.
 \item $q_0$: the initial state. This is in $Q$.
 \item $F$: the set of accepting states. $F$ is a subset of $Q$.
 \item $R$: the set of reject states. $R$ is a subset of $Q$.
 \item $B$: the blank symbol; this is in $\Gamma$ but not in $\Sigma$.
 In most TMs (and textbooks), this character is standardized and the same, 
 so it's usually not specified when describing a TM.
 \item $\delta : Q \times \Gamma \rightarrow Q 
\times \Gamma \times \{L, S, R\}$ is the transition function.
\end{itemize}
\end{defn}

There are many minor variations of the TM definition and they are
all essentially the same.
For instance:
\begin{tightlist}
\item Instead of having a set of accept states $F$, it's possible to redefine
the TM to have one single accept state without changing what the TM does.
In this case, the single accept state is usually written $q_\accept$.
\item Likewise it's possible to redefine a TM to have only one reject state.
In this case the special reject state is written $q_\reject$.
\item It's possible to rewrite the TM so that the read/write head does not
stay but always either move left or right.
In this case, the transition function is of the form:
\[
\delta : Q \times \Gamma \rightarrow Q 
\times \Gamma \times \{L, R\}
\]
\end{tightlist}

Here's how you draw a TM given the above specification: Everything
is the same as a DFA. For the transitions, suppose you have
\[
 \delta(q, a) = (p, b, R)
\]
Then you draw a directed edge or transition from state $q$ to
state $p$ and label it $a/b, R$ or $a \rightarrow b, R$

To be formal about computation we will introduce the following
notation:

\begin{defn}
Let
\[
 x_1 \ldots x_m q x_{m+1} \ldots x_n
\]
to denote that fact that the TM current has it's read/write head
pointing to the $(m+1)$-st character on the tape $x_{m+1}$; this
will be the {\it next} character the TM will read. This is called
an \defterm{instantaneous description} (ID). In some books this is
also called a \defterm{configuration}. Of course if you're running
the TM with string $x$, the initial ID is
\[
q_0 x
\]
Of course these are all just notation for description a computation
of the TM. In particular if $\delta(q,a) = (b,p,R)$, then
\[
 x q a y \derive xb p y
\]
The read/write head over-writes $a$ with $b$ and moves right. Make
sure you understand that! If instead of that you have $\delta(q,a) =
(b,p,L)$, then
\[
 x c q a y \derive x p c b y
\]
so that the character being read, $a$, is over-written by $b$ and
the read/write head moves left. And if the transition if
$\delta(q,a) = (b,p,S)$, then the read/write head stays:
\[
 x q a y \derive x p b y
\]
As always, if we will use $\derive^*$ to note ``the same or at
least one derivation”.
\end{defn}

\begin{defn}
$x \in \Sigma^*$ is \defterm{accepted} by $M$ is there is some $p
\in F$ such that
\[
 q_0 x \derive^* ypz
\]
for some strings $y,z$ in $\Gamma^*$. And, surprise-surprise, $L(M)$
is the set of strings accepted by $M$.
\end{defn}

\begin{defn}
\begin{itemize}
 \item It's easy to show that in fact you only need one accepting
 state. (Why?) Therefore some books will just have a special state
 called $q_{\accept}$ for the only accepting state of the TM.
 \item Note that if the TM tries to move to the left while it's already at the leftmost
 position on the tape, then the machine crashes and stops running. The string is not accepted.
 Instead of allowing this to happen, some books will define a
 special state $q_{\reject}$. Whenever the TM enters the $q_\reject$ state it
 stops (or halt) and the string is not accepted.
 \item From the above, the TM can reject by either entering the
 state $q_{\reject}$ or by moving left on the leftmost position on
 the tape. It's easy to see that you really do not need both
 cases. You can rewrite the TM so that if it tries to fall off the
 left edge, you make the TM go into $q_{\reject}$ instead. Here's
 how you do it. Before running the TM, shift all the checks of the
 input string to the right by one, and insert a ``beginning of tape
 marker''; you can use any symbol not used for instance a common symbol in some books is `\$'.
 Then include a transition so that is the TM is reading
 the ``beginning of tape marker'' and it attempts to move the
 left, replace it with a transition that enters $q_{\reject}$
 instead. This will stop the machine before it falls off the left
 edge.
 \item Although according to the above definition of a TM there is
 a transition for every state $q$ and every symbol $a$ in
 $\Gamma$, it is customary not to include transitions that enters
 the state $q_{\reject}$. Therefore in some books some transitions
 are left out and the authors say that \lq\lq if the TM is in a state $q$
 and is reading a character $a$ but there is no applicable
 transition, the machine crashes and the string is rejected." This
 is just the same as including a transition from such a state and
 symbol to the rejecting state and of course you cannot exit the
 rejecting state.
 \end{itemize}
\end{defn}

\begin{defn}
A language is said to be 
\defterm{Turing recognizable} 
or
\defterm{recursively enumerable} (r.e.)
if it is accepted by a TM.
\end{defn}

(Note: 
Computer Science is so new that many concepts still have multiple names.
Tune in after 100 hundred years to find out which name finally gets picked.)


Note one curious feature of the TM. It is possible for it to run
forever. That's not the case for either the DFA, NFA or PDA. In
particular it's possible for the string not to accepted by the TM
entering the $q_{\reject}$ state, the TM crashes by moving to the
left while at the leftmost position on the tape, or it does not
enter an accepting state.

\begin{defn}
A language is said to be \defterm{recursive} (rec.) if it is
accepted by a TM that always halts. A TM \defterm{always halts} if
giving any input string, the TM will either reach an accepting
state or the rejecting state. The accepting state and rejecting
state are called \defterm{halting states}.
\end{defn}

\begin{eg}
Let $L = \{a^n b^n c^n \,|\, n \geq 0\}$. We know that $L$ is not
a CFL. We will now prove that it is recursively enumerable, i.e.,
accepted by a TM.

TMs tend to large. So to simplify the specification of this TM,
transitions entering the $q_{\reject}$ state is not listed.

The idea is simple: Scan left and right, marking a single $a$ and
a single $b$ and a single $c$ in each right scan. We will need
special characters to denote that $a$,$b$ and $c$ are marked. We
will use $A$, $B$ and $C$ respectively. Of course if we cannot
find a $b$ or $c$ to match this $a$, the string is rejected. Now
once $c$ is marked, we move all the way to the left to look for
the first marked $a$ (i.e., $A$). Once that's found, we move
right. This would either be another $a$ or $B$. If it's $a$, we
repeat the process of marking $a$,$b$,$c$.

On the other hand if it's $B$, then there are no more $a$'s. Then
we just move right over all the marked characters (i.e., $B$ and
$C$) until we see a blank and accept the string. Of course if $b$
or $c$ is found, then the string is rejected; there shouldn't be
anymore $b$'s or $c$'s for the string to be accepted.

\newcommand\BLANK{\langle \operatorname{BLANK} \rangle}
That's the main idea. Here's the TM. We will use $\BLANK$ to
denote the blank character.

\[
\begin{tabular}{|c|c|l|}
  \hline
  $(q,x)$ & $\delta(q,x)$ & \mbox{} \\
  \hline
  $(q_0,a)$ & $(q_1,A,R)$ & Start marking phase: Mark $a$ and move right \\
  $(q_1,a)$ & $(q_1,a,R)$ & Fast forward over $a$ \\
  $(q_1,B)$ & $(q_1,B,R)$ & Fast forward over $B$ \\
  $(q_1,b)$ & $(q_2,B,R)$ & Mark $b$ and move right \\
  $(q_2,b)$ & $(q_2,b,R)$ & Fast forward over $b$ \\
  $(q_2,C)$ & $(q_2,C,R)$ & Fast forward over $C$ \\
  $(q_2,c)$ & $(q_3,C,L)$ & Mark $c$ and move left \\
  $(q_3,C)$ & $(q_3,C,L)$ & Rewind over $C$ \\
  $(q_3,B)$ & $(q_3,B,L)$ & Rewind over $B$ \\
  $(q_3,b)$ & $(q_3,b,L)$ & Rewind over $b$ \\
  $(q_3,a)$ & $(q_3,a,L)$ & Rewind over $a$ \\
  $(q_3,A)$ & $(q_0,A,R)$ & On seeing $A$, go to state $q_0$\\
  $(q_0,B)$ & $(q_4,B,R)$ & Start scanning phase: read first $B$ and move right\\
  $(q_4,B)$ & $(q_4,B,R)$ & Fast forward over $B$ \\
  $(q_4,C)$ & $(q_5,C,R)$ & Read first C and move right\\
  $(q_5,C)$ & $(q_5,C,R)$ & Fast forward over $C$\\
  $(q_5,\BLANK)$ & $(q_{\accept},B,S)$ & Accept string when a $\BLANK$ is found\\
  \hline
\end{tabular}
\]

Make sure you draw the state (or transition) diagram. Again
transitions which are not labeled go to the $q_{\reject}$ state.
Instead of writing infinitely many blanks, we will write one blank
just beyond $abc$. If we need to we can add blanks when we need to
(actually, for this TM only one blank is needed.)

Now let's trace the execution of $M$ for the string $abc$.
\begin{align*}
q_0 abc\BLANK
 &\derive Aq_1bc\BLANK \\
 &\derive ABq_2c\BLANK \\
 &\derive Aq_3BC\BLANK \\
 &\derive q_3ABC\BLANK \\
 &\derive Aq_0BC\BLANK \\
 &\derive ABq_4C\BLANK \\
 &\derive ABCq_5\BLANK \\
 &\derive ABCq_{\accept}\BLANK \\
\end{align*}

Now try to trace the execution of the TM for $aabbcc$ and
$aabbccc$.
\end{eg}

\begin{eg}
You can use TM to compute numbers. For instance you can use the
string $111$ to represent $3$. Given this data format, you can
define the output of a TM $M$ by what's on the tape when then
machine halts. Can you define a TM that computes the twice
function. In other words $M(111)$ = $111111$, i.e., if you put
$111$ on the tape and run the machine, it should halt with
$111111$ on the tape. If the TM does not halt on input $x$, then
we say $M(x)$ \defterm{diverges}.
\begin{itemize}
 \item You can design a
 TM to add numbers. For instance to add two 3 and 5, the input to
 the TM is $\#111\#11111$. The expected output is $11111111$. Can
 you design such a TM?
\item Can you design one to perform subtract
 of the form $m-n$ where $m\geq n$? In otherwise you want to
 design a TM $M$ such that $M(\#11111\#11) = 111$.
 \item Can you design a TM to do multiplication? For instance to
 compute the product of 3 and 4, you run the machine with
 $111\#1111$ and get $M(111\#1111) = 111111111111$.
 \item Can you design a TM $M$ that can powers of 2? For instance
 $M(1) = 11$, $M(111) = 11111111$.
 \item Of course you can also compute rationals. For instance you
 can represent the fraction 3/4 by 11101111. Can you design a TM
 to add rationals?
 \item You can also model negative numbers just by using a special
 character for sign.
 \item Of course you can combine all the above into a single TM.
\end{itemize}
\end{eg}

\begin{eg} Here's a trick. To prevent the case where the TM moves
left while it's already at the leftmost position, you need to
shift all the character one position to the right. Suppose the
symbol $\#$ is not used. Suppose the TM is $M$. How would you
write a new TM that will shift the input by one space to the
right, put $\#$ as the first character, and move the read/write
head so that it's about to read the first character of the input
string (i.e., first character to the right of $\#$. Once this
pre-processing step is done, the new TM starts simulating the old
one. In other words in terms of ID, you want a TM $M'$ that will
do the following: Suppose the new start state is $q_0'$.
\[
 q_0x \derive \#q_0x
\]
Since this modification can always be carried out on any TM, in
many books, it's assumed that the TM will never fall off the left
edge. In other words, these authors assume that it the TM tries to
move left on the leftmost spot, it will simply stay and not move.
\end{eg}

\begin{eg}
Design a TM that accepts $\{a^nb^nc^n \,|\, n \equiv 1
\,\,\,(\operatorname{mod} \, 4)\}$. The solution is easy. First
the TM checks the input is of the form $a^nb^nc^n$. (We've already
done that). After this point if the $a$'s might be marked with
another character. Let's say it's been replaced by $A$'s. First
the TM go to the leftmost $A$. It moves right so that the
read/write head is reading the next $A$ (or possibly $B$). It will
then continually read 4 $A$'s until a $B$ is reached. If that can
be done, then TM enters the $q_{\accept}$ state. Otherwise it
enters the $q_{\reject}$ state.
\end{eg}


There are many other computational models ($\lambda$--calculus
random access machines, general recursive functions, etc.) But in
the end they are all proven to be only as powerful as the original
Turing machines. Therefore solving a problem algorithmically is
believed to be equivalent to solving a problem using a Turing
machine. This is known as the
\defterm{Church-Turing thesis}.

\begin{eg}
In some books, a Turing machine is defined very similar to our
definition above except that the movements of the read/write head
is either left or right; the read/write head cannot stay at the
same spot. It seems that such a definition would result in a
weaker TM. Is that true?
\end{eg}


\newpage\myinput{tm/multitape/multitape.tex}
\newpage\myinput{tm/bidirectional/bidirectional.tex}
\newpage\myinput{tm/ntm/ntm.tex}
\newpage\myinput{tm/generators/generators.tex}



\newpage
\section{Languages which are not Turing Recognizable}

After so much work to build more and more powerful machines from DFA to PDA and then to Turing machines,
it's a let down that there are still languages that we cannot compute.
For a fixed $\Sigma$ say $\Sigma = \{0, 1\}$, there are still languages
not accepted by a Turing machine.

I'll show you why.

The first proof does not really construct a language which is not 
Turing recognizable.
We're also not using any kind of \lq\lq pumping lemma for Turing machines''.
Instead I am going to \lq\lq count'' the number of Turing machines
and the number of languages and then show you that there are more languages
than Turing machines.

Before we do that, I will need to expand your mind a little ... you 
see there are infinitely many Turing machines and infinitely many
languages!
We have to \lq\lq count'' in the world of infinities and I have to say
(in a sense) that the infinity of the Turing machines is smaller than
the infinity of languages.

So we have to go back to the days when you first were born ...
and to count all over again ...




\newpage
\section{Back to Basics ... Counting (a la Cantor)}

Let's being by reviewing what we mean by counting.
When I give you the following:
\[
\text{A, B, C, D, E}
\]
you should tell me that you are seeing 5 things.
Why is that? 
Because since you started to learn, you were told to associate
1, 2, 3, ... to the things you see.
So for instance in the above, you would do put your
finger on A and say \lq\lq one'',
move your finger to B and say \lq\lq two'', etc.
That's the same as doing this:
\begin{longtable}{ccccc}
A & B & C & D & E \\
$\uparrow$ & $\uparrow$ & 
$\uparrow$ & 
$\uparrow$ & 
$\uparrow$  \\
1 & 2 & 3 & 4 & 5
\end{longtable}
i.e., associating the number 1 to A (instead of associating your
verbal \lq\lq one'' to A), etc.
This association (think \lq\lq function'') is 1--1 and onto
(if you were taught to count correctly!)
If it's not 1--1, it might be something like this:
you might have for instance 1 and 2 pointing to A,
you would be counting A twice.
If the association is not onto, you would be missing some letter.

Another way to think of counting the above is there you're finding a
1--1 and onto function from the set 
\[
\{1, 2, 3, 4, 5\}
\]
to the set
\[
\{\text{A, B, C, D, E}\}
\]
Therefore counting
\[
\text{A, B, C, D, E}
\]
is the same as trying to a 1--1 and onto function from 
\[
\{1\}
\]
to $\{A, B, C, D, E\}$, or from 
\[
\{1, 2\}
\]
to $\{A, B, C, D, E\}$, or from 
\[
\{1, 2, 3\}
\] 
etc. until you succeed.
In our case we succeed when we use 
\[
\{1, 2, 3, 4, 5\}
\]
You can think of 
\[
\{1\}, \hspace{0.25cm}
\{1,2\}, \hspace{0.25cm}
\{1,2,3\}, \hspace{0.25cm}
\{1,2,3,4\}, \hspace{0.25cm}
\{1,2,3,4,5\}, \hspace{0.25cm}
\{1,2,3,4,5,6\}, \hspace{0.25cm}
\{1,2,3,4,5,6,7\}, ... 
\]
as our standard measurements for counting
sort of like standard weights for weighing things.
But why should we use 1--1 and onto functions and these sets as
a way to define counting?!?
Counting is so basic and such a primitive concept, why
bother trying to view counting as something involving sets, functions,
and 1--1 and onto functions?!?
Shouldn't \lq\lq counting'' be simpler than \lq\lq 1--1, onto functions''???

Well, the reason is because this definition of counting
uses sets ... and sets can be infinite.
For instance
I can use the whole set of natural numbers to count
the number of things in the set $X$:
\[
\{0, 1, 2, 3, ...\} \rightarrow X
\] 
and the standard measuring set $\{0, 1, 2, 3, ...\}$ is not finite!!!
(Remember: depending on who you talk to the set $\N$ might or might not
contain 0.)

Therefore if you want to say that two sets $X$ and $Y$ are different,
one way would be to say that $X$ has as many things as 
$\N = \{0, 1, 2, 3, ...\}$
while $Y$ has as many things as $\R$ ... that is if you know that 
$\R$ is \lq\lq bigger'' than $\N$ which I will show you in a minute.

First of all let me say that two sets $X$ and $Y$ are equinumerous
(or informally, they have the same size) if there is a 1--1 and onto function
from $X$ to $Y$.
In that case I will write $|X| = |Y|$.

Next, because \lq\lq finite or same size as $\N$'' is so commonly used,
I will create a definite for it.
I will say that a set $X$ is \defterm{countable} if one of the following
is true:
\begin{tightlist}
\item $X$ is finite, or
\item $|X| = |\N|$.
\end{tightlist}
If you do want to distinguish between the two, the first is said to be 
\defterm{countably finite} and the second is said to be 
\defterm{countably infinite}.

Now for some facts about countability ... be ready for this because
when you enter infinity ... things can be pretty weird.

First of all I claim that $\N$ has the same number of things
as $\N \cup \{\pi\}$, i.e.,
\[
|\N| = |\N \cup \{\pi\}|
\]
This seems to be obviously wrong.
But remember that counting means finding a 1--1 and onto function.
In this case to say that there are as many things in $\N$ as there
are in $\N \cup \{\pi\}$, I need to show you a 1--1 and onto function
between the two sets.
Here you go:
\begin{align*}
\N &\rightarrow \N \cup \{\pi\} \\
1 &\mapsto \pi \\
2 &\mapsto 1 \\
3 &\mapsto 2 \\
4 &\mapsto 3 \\
5 &\mapsto 4 \\
\vdots &\hspace{0.7cm} \vdots
\end{align*}
It should be clear that this function is 1--1 and onto.
Therefore
\[
|\N| = |\N \cup \{\pi\}|
\]

The above is closely related to a very interesting example created
by the famous German
mathematician David Hilbert called the Grand Hotel ...

You arrive at a hotel, the Grand Hotel (sometimes people call this
the Hotel Infinity).
The rooms are numbers 1, 2, 3, ... and there are as many rooms
as $\N$.
Unfortunately the hotel is full.
However the hotel owner, because he's really smart (probably
because he took automata theory),
simply told you to go to room 1 and tell the occupant in room 1
to go to room 2 and tell the occupant in room 2 to move to room 3 and
tell the occupant to do likewise, etc.
In general, the occupant in room $n$ moves to room $n + 1$
and the previous occupant in $n + 1$ moves to room $n + 2$.

As you can see the Grand Hotel is able to accomodate you even though 
it's already full 
Neat right?
(Unfortunately, all occupants are annoyed by having to move ...)

Now obviously, this scheme also works if you arrive with
a friend, i.e., there are \textit{two} new hotel guests.
No problem!
The two new guests occupy room 1 and room 2 and ... you know what to do.

But what if the number of new guests is not finite?
What if the number of new guests is in fact as numerous as $\N$ itself!!!
In terms out that 
\[
|\N \cup \N| = |\N|
\] 
Unbelievable!!!
Here's how you assign rooms 1, 2, 3, to $\N \cup \N$:
\[
pic
\]

What a happy owner of Grand Hotel!

But what if you have $\N \cup \N \cup \N$ guests?
No problemo amigo! (Sorry ...)
\[
pic
\]

Not only that ... in fact $| \N \cup \N \cup \N \cup \cdots | = |\N|$
where the union on the left is a union of countably infinite copies of 
$\N$. Wow!
To be more precise, I would write
\[
\left|
\bigcup_{n=1}^\infty \N
\right|
=
|\N|
\]
A union involving countable many sets is called a countable union.
The \lq\lq countable'' in \lq\lq countable union'' refers to the
number of sets you're trying to \lq\lq union-up'', not the sets themselves.
 
\begin{thm}
The countable union of countable sets is countable.
\end{thm}

Instead of cobbling together more and more copies of $\N$, 
let's take a break and look at other sets.
For instance there's $\Q$, the set of fractions.
Not surely there are more things in $\Q$ than in $\N$ because
$\Q$ contains $\N$ and surely the fraction $1/2$ is not in $\N$.
Right?

WRONG!

That's because you can associating values of $\N$ with values in $\Q$
in a wrong way.
You can think of $\Q$ as (more or less) $\N \times \N$.
For instance $3/7$ corresponds to the point $(3, 7)$ in $\N^2$
But wait a minute ... look at the picture of $\N \times \N$.
Doesn't it remind you of $\N \cup \N \cup \N \cup \cdots$?
To be more concrete, let me show you how to associate $\N$ with
the points in $\N \times \N$:
\[
pic
\]

There are some details you have to be careful about for instance
What about negative fractions?
The fractions also does not include something like $5/0$
(which is not defined!)
However in $\N \times \N$ we do have $(5, 0)$.
What about $(3, 6)$ that would correspond to the fraction $6/3$.
But this is also the same as $2/1$.
All these are not too difficult to overcome.

Note the technique very carefully.
In you try to label the points \textit{horizontally} like this:
\[
\]
you will get into trouble because you're ever going to return to 
start labeling the next row!!!

Your mind hurts, right?

\begin{ex}
Complete the proof of $|\Q| = |\N|$ by explaining what you should
do about negative fractions or about points like $(5, 0)$
or about the issue with $(6,3)$ and $(2,1)$.
\qed
\end{ex}

Now at this point, you might give up and say that $\R$ is probably
as big as $\N$.
Actually ... $\R$ is strictly bigger than $\N$ in size!!!
Phew!!! For a moment ... we thought the whole world is nothing more than
$\N$.

The proof that $\R$ is in fact bigger than $\N$ is important 
because the technique itself will be used later in a totally different
context ... in the world of languages and automata.

This is so important that I need a new section!!! ...


\newpage
\section{Cantor's Diagonal Trick: Counting $\R$}

Instead of showing that $\R$ is bigger than $\N$, I'm going to show 
you that in fact the interval of real numbers 
$[0, 1)$ is already bigger than $\N$.
The proof technique was invented by Georg Cantor, the mathematician
who defined this whole new way of counting by using 1--1 and onto functions.

First of all let me just declare that I'm going to prove our goal by 
contradiction.
I'm going to assume that $[0,1)$ is countable.
Therefore I can list the values in $[0,1)$, say
\[
x_0, x_1, x_2, x_3, \ldots
\]
(The goal
is to show you that I can find a value not in the above list.)

Next, I'm going to express the $x_i$ as decimal numbers.
For instance if $x_0 = 1/2$, then I'm going to write $x_0 = 0.5$ instead.
Furthermore, I'm going to write the numbers with infinitely many decimal
places.
For instance if $x_1 = 0.5$, I'm going to write
\[
x_0 = .5000000000000000\ldots
\]
I'm going to give names to the decimal digits of $x_0$.
The $i$--th digit is written $x_{0i}$
So in this case,
\begin{align*}
x_{00} &= 5 \\
x_{01} &= 0 \\
x_{02} &= 0 \\
x_{03} &= 0 \\
x_{04} &= 0 \\
\end{align*}
etc.
If $x_2$ is $0.14159265...$, then
\begin{align*}
x_{10} &= 1 \\
x_{11} &= 4 \\
x_{12} &= 1 \\
x_{13} &= 5 \\
x_{14} &= 9 \\
\end{align*}
etc.
So far so good ... we have a list of numbers $x_0, x_1, x_2, ...$ 
and a bunch of digits
\begin{align*}
x_{00}, x_{01}, x_{02}, ... \\
x_{10}, x_{11}, x_{12}, ... \\
x_{20}, x_{21}, x_{22}, ... \\
\end{align*}

Let me lay the digits in a grid:
\begin{python}
from latextool_basic import table
print table([('', '', '', ''),
('', '', '', ''),
('', '', '', ''),
('', '', '', '')
],
col_headings = ['$0$', '$1$', '$2$', '$3$', r'$\ldots$'],
row_headings = ['$x_0$', '$x_1$', '$x_2$', '$x_3$', r'$\ldots$'])
\end{python}
I will fill the cell at row $x_i$ and column $j$ with the $x_{ij}$.
For instance since $x_0 = 0.5000\ldots$ and $x_1 = 0.14159254\ldots$,
I have the following:
\begin{python}
from latextool_basic import table
print table([('5', '0', '0', '0', '...'),
('1', '4', '1', '5', '...'),
('', '', '', ''),
('', '', '', '')
],
col_headings = ['$0$', '$1$', '$2$', '$3$', r'$\ldots$'],
row_headings = ['$x_0$', '$x_1$', '$x_2$', '$x_3$', r'$\ldots$'])
\end{python}

Now I'm going to construct a value $y$ that is in $[0,1)$ that is
not in the above list.
I'm going to build $y$ by specifying the decimals of $y$.
Just like the $x_i$'s above, $y$ is going to look like this:
\[
y = 0.y_0 y_1 y_2 \cdots
\]
where $y_i$ is the $i$--digit of $y$ to the right of the decimal point.
In order for $y$ to contradict our assumption about 
the countability of $[0,1)$,
I will need $y$ not to be $x_0$, and not be $x_1$, and not be $x_2$, etc.

To make $y$ not $x_0$, I look at the first digit of $x_0$ to the right
of the decimal place, i.e., $x_{00}$.
All I need to do is to choose $y_0$ to be different from $x_{00}$.
For instance if $x_{00} = 5$, 
I can choose $0$ for $y_0$ (of course I can also choose $1$
for $y_0$ ... any digit that is not 5 works.)
In other words I make $y$ \textit{not} $x_0$ by making them different
at the first decimal place.

So at this point $y$ looks like
\[
y = 0.0y_2 y_3 \cdots
\]

Now suppose the second digit of $x_1$ to the right of the decimal point
is $1$.
Using the same trick, I will choose $y_1$ to be different from $x_{11} = 1$.
For instance I can choose $y_1 = 7$.
At this point
\[
y = 0.07 y_3 y_4 y_5 \cdots
\]

Etc.

In general, for $i \geq 0$, $y_{ii}$ to be an element in
\[
\{0, 1, 2, \ldots, 9\} - \{x_{ii}\}
\]
This will ensure that
\[
y \neq x_i
\]

Note that the form of $y$ tells me that $y$ is indeed in $[0,1)$.
We have found a value, $y$, in $[0,1)$ which is not in the list
\[
x_1, x_2, x_3, ...
\] 
which I assumed at the beginning is a complete list of values in $[0,1)$.

Contradiction!!!

Actually there's a small point:
What if I accidentally select $y_0 = 9$, $y_1 = 9$, $y_2 = 9$, ...
This means that $y$ looks like $0.9999\cdots$.
This value is not in $[0,1)$.
This value is actually $1$ and it not in $[0,1)$.
(Right? Check with your math textbooks or with your math instructors.)
In the same way $0.499999\cdots$ is actually the same as
$0.5$.
To avoid issues like these, I will just make sure that I will never choose
$9$ for the $y_i$'s.
Problem fixed!!!

This proof technique is called the \defterm{Cantor's diagonal trick}
(or Cantor's diagonal method if you want to make it sound more respectable.)

\begin{thm}
$\R$ is not countable.
\end{thm}

Now you might think that $[0,1)$ is much smaller than $\R$.
But in fact ...

\begin{ex}
Show that $|\R| = |[0, 1)|$.
\end{ex}

I am now going to show you that there is a language
(over a fixed $\Sigma$ throughout this argument of course, 
say $\Sigma = \{a,b\}$)
which is not accepted by a Turing machine, i.e.,
the language is not Turing--recognization (or recursively enumerable.)

I'll do this in two different ways:
the first way is to show that there
are more languages than Turing machines (the method is by counting)
and the second way is by defining a language that is not Turing--recognizable.

First of all ... how many Turing machines are there?
The number of Turing machines is actually countable.

Why?

Because each Turing machine can be encoded as a finite binary string.
This means that the collection of Turing machines
is a subset of 
\[
\Sigma^* 
= \bigcup_{n=0}^\infty \Sigma^n 
= \Sigma^0 \cup \Sigma^1 \cup \Sigma^2 \cup \cdots
\]
Note that each of the $\Sigma^n$ is countable (in fact finite!)
Therefore $\Sigma^*$ is a countable union of countable sets.
This implies that $\Sigma^*$ is countable.

\begin{thm}
The set of Turing machines (for a fixed $\Sigma$) is countable.
\end{thm}

Before we count $\LANG_\Sigma$,
the collection of languages of $\Sigma$,
let's try another counting example that involves Cantor's diagonal trick.

Let's count the number of functions from $\N$ to $\{0, 1\}$.
An element of this set is of the from
\[
f: \N \rightarrow \{0, 1\}
\]
For convenience, let me call this set $X$.
I claim that $X$ is not countable.
By my assumption, I can list the elements in $X$ like this:
\[
f_0, f_1, f_2, \ldots
\]
$f_0$ is of course completely determined by 
\[
f_0(0), f_0(1), f_0(2), f_0(3), \ldots
\]
Each $f_i(j)$ is either 0 or 1.
Now I'm going to build a function $g : \N \rightarrow \{0, 1\}$
which is not in the above list.
How?

This is actually very similar to the setup in Cantor's argument
above.
In this case we have:

\begin{python}
from latextool_basic import table
print table([('', '', '', ''),
('', '', '', ''),
('', '', '', ''),
('', '', '', '')
],
col_headings = ['$0$', '$1$', '$2$', '$3$', r'$\ldots$'],
row_headings = ['$f_0$', '$f_1$', '$f_2$', '$f_3$', r'$\ldots$'])
\end{python}

where the cell at row $f_i$ and column $j$ is filled with the
value of $f_i(j)$.
For instance if the table looks like this:
\begin{python}
from latextool_basic import table
print table([('1', '0', '1', '1'),
('0', '0', '0', '1'),
('1', '0', '1', '0'),
('0', '0', '1', '1')
],
col_headings = ['$0$', '$1$', '$2$', '$3$', r'$\ldots$'],
row_headings = ['$f_0$', '$f_1$', '$f_2$', '$f_3$', r'$\ldots$'])
\end{python}

Then $f_0(0) = 1$ and $f_1(2) = 0$, etc.

Well, $g$ is completely determined by 
\[
g(1), g(2), g(3), ...
\]
So I need to specify $g(n)$ for $n \geq 1$.
For $g(1)$, I'm going to choose a value for $g(1)$ so that 
$g$ is not $f_1$.
Well, that's easy ... I follow Cantor's diagonal trick
and choose $g(0)$ to be different from $f_0(0)$.
If $f_0(0)$ is $1$, I will set $g(0) = 0$.
If $f_0(1)$ is $0$, I will set $g(1) = 1$.
Likewise, I choose a value for $g(2)$ so that $g(2) \neq f_2(2)$.
Etc.

In general I construct my function $g$ such that
for each $n \geq 0$,
\[
g(n)
= 
\begin{cases}
0 & \text{ if } f_n(n) = 1 \\
1 & \text{ if } f_n(n) = 0 \\
\end{cases}
\]
I have constructed a function $g : \N \rightarrow \{0, 1\}$
such that $g \neq f_0$, $g \neq f_1$, ...
Therefore the list of functions $f_0, f_1, f_2, \ldots$ cannot be 
complete.

Therefore $X$ is not countable.

\begin{thm}
The set of functions from $\N$ to $\{0,1\}$ is not countable.
\end{thm}

\begin{ex}
Is the collection of subsets of $\N$ countable?
\qed
\end{ex}

\begin{ex}
The even integers are having a having a war with the odd integers.
(a) Each even integer has 1 cannonball.
However many ways can the even integers fire their cannonballs?
If it's infinite, then is it countable?
(b) What if each even integer has 5 cannonballs?
(c) What if each even integer has a finite number of cannonballs?
(The the number can be diffrent?
(d) Countable number?
\end{ex}

\begin{ex}
Assume that all (undirected) graphs with finitely
many nodes have their nodes labeled using 
$\N$. 
Is the collection of such graphs countable?
\qed
\end{ex}


\newpage
\section{Languages which are not Turing--Recognizable again}
Now I'm going to prove that the 
set of languages over $\Sigma$ (say $\Sigma = \{0, 1\}$)
is not countable.
I'll use $\Sigma = \{0, 1\}$ but the argument works in general.

First of all, recall that $\Sigma^*$ is countable
(see above ... remember???)
Say you list the words of $\Sigma^*$ as
\[
w_1, w_2, w_3, w_4, w_5, \ldots
\]
For instance in the case of $\Sigma = \{0, 1\}$,
you can like the $w_i$ like this:
\begin{align*}
w_1 &= \ep \\
w_2 &= 0 \\
w_3 &= 1 \\
w_4 &= 00 \\
w_5 &= 01 \\
w_6 &= 10 \\
w_7 &= 11 \\
...
\end{align*}


Now let's count $\LANG_\Sigma$, the collection of languages over $\Sigma$.
Given a language $L$,
$L$ contains words in $\Sigma^*$.
For instance suppose
\[
L = \{w_3, w_7, w_9\}
\]
In that case I can construct a function $\N \rightarrow \{0,1\}$
associated with $L$ is a natural way:
\begin{align*}
f(3) &= 1 \\
f(7) &= 1 \\
f(9) &= 1 \\
\end{align*}
and $f(n) = 0$ for $n \neq 3, 7, 9$.
In other words 
$f(n) = 1$ exactly when $w_n \in L$.
It's clear that if I can you a function $\N \rightarrow \{0, 1\}$
you can construct a language which is a subset of $\Sigma^*$.
This associated between functions of the form $\N \rightarrow \{0, 1\}$
and languages of $\LANG_\Sigma$ is clearly
a 1--1 and onto function.
Therefore 
there must be as many languages in $\LANG_\Sigma$
as there are functions $\N\rightarrow \{0, 1\}$.
I have already shown you that the collection of functions
of the form $\N \rightarrow \{0,1\}$ is not countable.
Therefore $\LANG_\Sigma$ must also be uncountable.

\begin{thm}
$\LANG_\Sigma$ 
is uncountable.
\end{thm}

\begin{ex}
Let $X$ be a finite set with $|X| > 1$.
Is $P(X)$ countable? ($P(X) = $ powerset of $X$.)
\end{ex}

The consequence is of course ...

\begin{thm}
There is a language that is not Turing--recognizable
(i.e., not recursively enumerable.)
\end{thm}

Too bad!!!
This means that there is a language that is not \lq\lq computable''.

The above theorem is not constructive in the sense that
it does not tell you what a non--Turing--recognizable language looks like.

Let me give you an example.
Although I \textit{am} going to describe the language,
I'll just warn you right away that it's not a language that is easily
described using \lq\lq patterns''
such as 
\[
a^n b^n, n \geq 0
\]
(like our first non-regular language) or something like
\[
a^n b^n c^n, n \geq 0
\]
(like our first non-context--free language).

First of all recall from above that $\Sigma^*$ is countable,
say the words are
\[
w_1, w_2, w_3, \ldots
\]
Also, note that the collection of Turing machines (over $\Sigma$) is also 
countable, say they are
\[
M_1, M_2, M_3, \ldots
\]

Notice that just like Cantor's diagonal trick, we again have
a grid which is (infinitely) countable in both directions:
\begin{python}
from latextool_basic import table
print table([('', '', '', ''),
('', '', '', ''),
('', '', '', ''),
('', '', '', '')
],
col_headings = ['$w_1$', '$w_2$', '$w_3$', '$w_4$', r'$\ldots$'],
row_headings = ['$M_1$', '$M_2$', '$M_3$', '$M_4$', r'$\ldots$'])
\end{python}

In the cell for $M_i$ and $w_j$, we put a \lq\lq accept'' 
if $M_i$ accepts $w_j$.
and \lq\lq not accept'' (not \lq\lq reject''!) if $M_i$ 
does not accept $w_j$.
(Why can't you put \lq\lq reject''?)
To make the above easier to read, you can think of using 
$1$ for \lq\lq accept'' and $0$ for \lq\lq not accept.
For instance if the table looks like this:
\begin{python}
from latextool_basic import table
print table([('0', '0', '1', '0', '...'),
('1', '0', '1', '1', '...'),
('0', '1', '1', '1', '...'),
('1', '0', '1', '1', '...'),
],
col_headings = ['$w_1$', '$w_2$', '$w_3$', '$w_4$', r'$\ldots$'],
row_headings = ['$M_1$', '$M_2$', '$M_3$', '$M_4$', r'$\ldots$'])
\end{python}

then $M_1$ does not accept $w_1$ but accept $w_3$.

Following Cantor's technique,
I want $L$ not to be accepting by $M_1$,
not accepted by $M_2$, etc.
For $L$ not be accept by $M_1$, I will want the following to be true:
\[
w_1 \in L \iff M_1 \text{ does not accept }  w_1
\]
In other words, if $M_1$ accepts $w_1$, then I will not put $w_1$ into $L$.
However if $w_1$ is not accepted by $M_1$, I will put $w_i$ into $L$.
Since $L$ has the exact 
opposite behavior as $L(M_1)$ in terms of accepting $w_1$,
$L$ cannot be $L(M_1)$.
I do the same for $w_2$, $w_3$, ...

In general for $i \geq 1$, I want
\[
w_i \in L \iff M_i \text{ does not accept }  w_i
\]
This ensures that $L \neq L(M_i)$ for all $i \geq 1$.
If you want to see $L$ in set notation, here you go:
\[
L = \{ w_i \mid i \geq 1 \text{ and } M_i \text{ does not accept } w_i \}
\]

AHA!
This means that $L$ cannot be accepted by any of the TMs
$M_1$, $M_2$, $M_3$, ...
Since this is a complete list of all TMs,
$L$ cannot be Turing--recognizable!!!

This $L$ is some times called the diagonal language.
I will write
\[
\DIAGONAL_\Sigma
\]
for this language.
Note that this is a subset of $\Sigma^*$, i.e., 
it is a language in $\LANG_\Sigma$.
(WARNING: Technically, this 
language depends on the ordering of both the TMs and 
words in $\Sigma^*$.)


(Note:
The above simply gives a pairing between $\TM$ and $\Sigma^*$:
\begin{align*}
\TM \times \Sigma^* &\rightarrow \{0,1\} \\
\langle M, w \rangle &=
\begin{cases}
1 & \text{ if $M$ accepts $w$} \\ 
0 & \text{ otherwise} \\ 
\end{cases}
\end{align*}
Composing with $\N$ (using any encoding of TMs and $\Sigma^*$, we get
\begin{align*}
\N \rightarrow \TM \times \Sigma^* &\rightarrow \{0,1\} \\
i \mapsto \langle M_i, w_i \rangle &=
\begin{cases}
1 & \text{ if $M$ accepts $w$} \\ 
0 & \text{ otherwise} \\ 
\end{cases}
\end{align*}



\newpage
\section{Closure Laws}

\begin{thm}
\begin{tightlist}
\item $L_1, L_2$ Turing--recogizable $\implies$
      $L_1 \cup L_2$ Turing--recogizable
\item $L_1, L_2$ Turing--recogizable $\implies$
      $L_1 \cap L_2$ Turing--recogizable
\item $L_1, L_2$ Turing--recogizable $\implies$
      $L_1 L_2$ Turing--recogizable
\item $L$ Turing--recogizable $\implies$
      $L^*$ Turing--recogizable
\item $L$ Turing--decidable $\iff$
      $\overline L$ Turing decidable. 
\item $L, \overline L$ Turing-recognizable
      $\iff$
      $L$ Turing--decidable.
\end{tightlist}
\end{thm}






\newpage
\input{tm/tm/decidability.tex}

\newpage
\chapter{Time complexity classes}
\newpage
\input{tm/tm/p.tex}
