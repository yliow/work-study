\section{Cantor's Diagonal Trick: Counting $\R$}

Instead of showing that $\R$ is bigger than $\N$, I'm going to show 
you that in fact the interval of real numbers 
$[0, 1)$ is already bigger than $\N$.
The proof technique was invented by Georg Cantor, the mathematician
who defined this whole new way of counting by using 1--1 and onto functions.

First of all let me just declare that I'm going to prove our goal by 
contradiction.
I'm going to assume that $[0,1)$ is countable.
Therefore I can list the values in $[0,1)$, say
\[
x_0, x_1, x_2, x_3, \ldots
\]
(The goal
is to show you that I can find a value not in the above list.)

Next, I'm going to express the $x_i$ as decimal numbers.
For instance if $x_0 = 1/2$, then I'm going to write $x_0 = 0.5$ instead.
Furthermore, I'm going to write the numbers with infinitely many decimal
places.
For instance if $x_1 = 0.5$, I'm going to write
\[
x_0 = .5000000000000000\ldots
\]
I'm going to give names to the decimal digits of $x_0$.
The $i$--th digit is written $x_{0i}$
So in this case,
\begin{align*}
x_{00} &= 5 \\
x_{01} &= 0 \\
x_{02} &= 0 \\
x_{03} &= 0 \\
x_{04} &= 0 \\
\end{align*}
etc.
If $x_2$ is $0.14159265...$, then
\begin{align*}
x_{10} &= 1 \\
x_{11} &= 4 \\
x_{12} &= 1 \\
x_{13} &= 5 \\
x_{14} &= 9 \\
\end{align*}
etc.
So far so good ... we have a list of numbers $x_0, x_1, x_2, ...$ 
and a bunch of digits
\begin{align*}
x_{00}, x_{01}, x_{02}, ... \\
x_{10}, x_{11}, x_{12}, ... \\
x_{20}, x_{21}, x_{22}, ... \\
\end{align*}

Let me lay the digits in a grid:
\begin{python}
from latextool_basic import table
print table([('', '', '', ''),
('', '', '', ''),
('', '', '', ''),
('', '', '', '')
],
col_headings = ['$0$', '$1$', '$2$', '$3$', r'$\ldots$'],
row_headings = ['$x_0$', '$x_1$', '$x_2$', '$x_3$', r'$\ldots$'])
\end{python}
I will fill the cell at row $x_i$ and column $j$ with the $x_{ij}$.
For instance since $x_0 = 0.5000\ldots$ and $x_1 = 0.14159254\ldots$,
I have the following:
\begin{python}
from latextool_basic import table
print table([('5', '0', '0', '0', '...'),
('1', '4', '1', '5', '...'),
('', '', '', ''),
('', '', '', '')
],
col_headings = ['$0$', '$1$', '$2$', '$3$', r'$\ldots$'],
row_headings = ['$x_0$', '$x_1$', '$x_2$', '$x_3$', r'$\ldots$'])
\end{python}

Now I'm going to construct a value $y$ that is in $[0,1)$ that is
not in the above list.
I'm going to build $y$ by specifying the decimals of $y$.
Just like the $x_i$'s above, $y$ is going to look like this:
\[
y = 0.y_0 y_1 y_2 \cdots
\]
where $y_i$ is the $i$--digit of $y$ to the right of the decimal point.
In order for $y$ to contradict our assumption about 
the countability of $[0,1)$,
I will need $y$ not to be $x_0$, and not be $x_1$, and not be $x_2$, etc.

To make $y$ not $x_0$, I look at the first digit of $x_0$ to the right
of the decimal place, i.e., $x_{00}$.
All I need to do is to choose $y_0$ to be different from $x_{00}$.
For instance if $x_{00} = 5$, 
I can choose $0$ for $y_0$ (of course I can also choose $1$
for $y_0$ ... any digit that is not 5 works.)
In other words I make $y$ \textit{not} $x_0$ by making them different
at the first decimal place.

So at this point $y$ looks like
\[
y = 0.0y_2 y_3 \cdots
\]

Now suppose the second digit of $x_1$ to the right of the decimal point
is $1$.
Using the same trick, I will choose $y_1$ to be different from $x_{11} = 1$.
For instance I can choose $y_1 = 7$.
At this point
\[
y = 0.07 y_3 y_4 y_5 \cdots
\]

Etc.

In general, for $i \geq 0$, $y_{ii}$ to be an element in
\[
\{0, 1, 2, \ldots, 9\} - \{x_{ii}\}
\]
This will ensure that
\[
y \neq x_i
\]

Note that the form of $y$ tells me that $y$ is indeed in $[0,1)$.
We have found a value, $y$, in $[0,1)$ which is not in the list
\[
x_1, x_2, x_3, ...
\] 
which I assumed at the beginning is a complete list of values in $[0,1)$.

Contradiction!!!

Actually there's a small point:
What if I accidentally select $y_0 = 9$, $y_1 = 9$, $y_2 = 9$, ...
This means that $y$ looks like $0.9999\cdots$.
This value is not in $[0,1)$.
This value is actually $1$ and it not in $[0,1)$.
(Right? Check with your math textbooks or with your math instructors.)
In the same way $0.499999\cdots$ is actually the same as
$0.5$.
To avoid issues like these, I will just make sure that I will never choose
$9$ for the $y_i$'s.
Problem fixed!!!

This proof technique is called the \defone{Cantor's diagonal trick}
(or Cantor's diagonal method if you want to make it sound more respectable.)

\begin{thm}
$\R$ is not countable.
\end{thm}

Now you might think that $[0,1)$ is much smaller than $\R$.
But in fact ...

\begin{ex}
Show that $|\R| = |[0, 1)|$.
\end{ex}

I am now going to show you that there is a language
(over a fixed $\Sigma$ throughout this argument of course, 
say $\Sigma = \{a,b\}$)
which is not accepted by a Turing machine, i.e.,
the language is not Turing--recognization (or recursively enumerable.)

I'll do this in two different ways:
the first way is to show that there
are more languages than Turing machines (the method is by counting)
and the second way is by defining a language that is not Turing--recognizable.

First of all ... how many Turing machines are there?
The number of Turing machines is actually countable.

Why?

Because each Turing machine can be encoded as a finite binary string.
This means that the collection of Turing machines
is a subset of 
\[
\Sigma^* 
= \bigcup_{n=0}^\infty \Sigma^n 
= \Sigma^0 \cup \Sigma^1 \cup \Sigma^2 \cup \cdots
\]
Note that each of the $\Sigma^n$ is countable (in fact finite!)
Therefore $\Sigma^*$ is a countable union of countable sets.
This implies that $\Sigma^*$ is countable.

\begin{thm}
The set of Turing machines (for a fixed $\Sigma$) is countable.
\end{thm}

Before we count $\LANG_\Sigma$,
the collection of languages of $\Sigma$,
let's try another counting example that involves Cantor's diagonal trick.

Let's count the number of functions from $\N$ to $\{0, 1\}$.
An element of this set is of the from
\[
f: \N \rightarrow \{0, 1\}
\]
For convenience, let me call this set $X$.
I claim that $X$ is not countable.
By my assumption, I can list the elements in $X$ like this:
\[
f_0, f_1, f_2, \ldots
\]
$f_0$ is of course completely determined by 
\[
f_0(0), f_0(1), f_0(2), f_0(3), \ldots
\]
Each $f_i(j)$ is either 0 or 1.
Now I'm going to build a function $g : \N \rightarrow \{0, 1\}$
which is not in the above list.
How?

This is actually very similar to the setup in Cantor's argument
above.
In this case we have:

\begin{python}
from latextool_basic import table
print table([('', '', '', ''),
('', '', '', ''),
('', '', '', ''),
('', '', '', '')
],
col_headings = ['$0$', '$1$', '$2$', '$3$', r'$\ldots$'],
row_headings = ['$f_0$', '$f_1$', '$f_2$', '$f_3$', r'$\ldots$'])
\end{python}

where the cell at row $f_i$ and column $j$ is filled with the
value of $f_i(j)$.
For instance if the table looks like this:
\begin{python}
from latextool_basic import table
print table([('1', '0', '1', '1'),
('0', '0', '0', '1'),
('1', '0', '1', '0'),
('0', '0', '1', '1')
],
col_headings = ['$0$', '$1$', '$2$', '$3$', r'$\ldots$'],
row_headings = ['$f_0$', '$f_1$', '$f_2$', '$f_3$', r'$\ldots$'])
\end{python}

Then $f_0(0) = 1$ and $f_1(2) = 0$, etc.

Well, $g$ is completely determined by 
\[
g(1), g(2), g(3), ...
\]
So I need to specify $g(n)$ for $n \geq 1$.
For $g(1)$, I'm going to choose a value for $g(1)$ so that 
$g$ is not $f_1$.
Well, that's easy ... I follow Cantor's diagonal trick
and choose $g(0)$ to be different from $f_0(0)$.
If $f_0(0)$ is $1$, I will set $g(0) = 0$.
If $f_0(1)$ is $0$, I will set $g(1) = 1$.
Likewise, I choose a value for $g(2)$ so that $g(2) \neq f_2(2)$.
Etc.

In general I construct my function $g$ such that
for each $n \geq 0$,
\[
g(n)
= 
\begin{cases}
0 & \text{ if } f_n(n) = 1 \\
1 & \text{ if } f_n(n) = 0 \\
\end{cases}
\]
I have constructed a function $g : \N \rightarrow \{0, 1\}$
such that $g \neq f_0$, $g \neq f_1$, ...
Therefore the list of functions $f_0, f_1, f_2, \ldots$ cannot be 
complete.

Therefore $X$ is not countable.

\begin{thm}
The set of functions from $\N$ to $\{0,1\}$ is not countable.
\end{thm}

\begin{ex}
Is the collection of subsets of $\N$ countable?
\qed
\end{ex}

\begin{ex}
The even integers are having a having a war with the odd integers.
(a) Each even integer has 1 cannonball.
However many ways can the even integers fire their cannonballs?
If it's infinite, then is it countable?
(b) What if each even integer has 5 cannonballs?
(c) What if each even integer has a finite number of cannonballs?
(The the number can be diffrent?
(d) Countable number?
\end{ex}

\begin{ex}
Assume that all (undirected) graphs with finitely
many nodes have their nodes labeled using 
$\N$. 
Is the collection of such graphs countable?
\qed
\end{ex}
