\sectionthree{CFG and PDA}
\begin{python0}
from solutions import *; clear()
\end{python0}

I'll call the next theorem our \lq\lq CFG = PDA'' theorem:
\begin{thm}
 $L$ is generated by a CFG iff $L$ is accepted by a PDA.
\end{thm}

\begin{eg}
 Consider the grammar
 \begin{align*}
  S &\rightarrow aAB \\
  A &\rightarrow aA \\
  A &\rightarrow a \\
  B &\rightarrow bB \\
  B &\rightarrow a
 \end{align*}
\end{eg}

Look at a leftmost derivation:
\[
 S \rightarrow aAB \rightarrow aaAB \rightarrow aaaB \rightarrow
 aaabB \rightarrow aaaba
\]

You want to be able to ``see'' a stack and something that tells
you where you are in reading the string. Now look at this:
\[
\underline{S} 
\implies a\underline{AB} 
\implies aa\underline{AB} 
\implies aaa\underline{B} 
\implies aaab\underline{B}
\implies aaaba
\]

Just think of the terms being underlined as terms in a stack.
The terminals show what your PDA has read so far.
Therefore the PDA's symbols are the variables of the grammar.

Here's the corresponding execution for the PDA we want to build:
\begin{center}
\begin{tabular}{|c|c|c|} \hline
remaining input & stack & sentential form in derivation \\ \hline
$aaaba$ & $S$  & $S$ \\
$aaba$  & $AB$ & $aAB$ \\
$aba$   & $AB$ & $aaAB$ \\
$ba$    & $B$ & $aaaB$ \\
$a$     & $B$ & $aaabB$ \\
$\ep$   & $\ep$ & $aaaba$ \\ \hline
\end{tabular}
\end{center}

Note in particular that at the end of the computation, the stack is empty.
So we use the acceptance rule that a string is accepted if the end of reading 
all the characters, the stack is empty.

Let's focus on just one derivation:
\[
a \underline{AB} \rightarrow aa \underline{AB}
\]
What should this correspond to in the computation of the PDA you're trying to
build?
Your PDA sees an $A$ on top of the stack.
What happens after that is that you see a character $a$ and $A$ is back on the
stack.
In other words this corresponds to the situation where the transition edge
of the PDA is labeled $(a, A \rightarrow A)$. Right?

Now what does this step of the computation come from?
It comes from the production rule $A \rightarrow aA$, i.e. $A$ is replaced by
$aA$.

Suppose you have a production of the form $A \rightarrow bBA$.
How should the corresponding transition be labeled?
Do you see that the transition is
\[
(b, A \rightarrow BA)
\]
What is the transition if the rule is $A \rightarrow BB$?
It's
\[
(\ep, A \rightarrow BB)
\]
right?

And what is the transition if the production rule is $A \rightarrow aaB$?
\[
(a, A \rightarrow aB)
\]

For the above example, here are the productions and the corresponding 
transition labels
\begin{center}
\begin{tabular}{|c|c|} \hline
production          & transition labels \\ \hline
$S \rightarrow aAB$ & $(a, S \rightarrow AB)$  \\
$A \rightarrow aA$  & $(a, A \rightarrow A)$  \\
$A \rightarrow a$   & $(a, A \rightarrow \ep)$ \\
$B \rightarrow bB$  & $(b, B \rightarrow B)$ \\
$B \rightarrow a$   & $(a, B \rightarrow \ep)$ \\ \hline
\end{tabular}
\end{center}

But wait a minute ... what about the states?
The CFG is completely defined in terms of the production rules ... and so far
the above is all about transitions ... no mention of states at all!!!

But hang on there.
Let's try to understand what we're computing above.
We simply continue to compute by looking at the stack.
We stop when ... the stack is empty!
So we have to use acceptance by null stack.
The PDA looks like this:

\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto,initial text=]
\node[state] (q1) at (3.5,0.0) {$q_1$};
\node[state,initial,accepting] (q0) at (0.0,0.0) {$q_0$};
\node[state] (q2) at (3.5,-3.0) {$q_2$};

\path[->]
(q0) edge [bend left=0,pos=0.5,above] node {$(\ep,\ep\rightarrow S\$)$} (q1)
(q1) edge [loop above] node {transitions from production rule} ()
(q1) edge [right] node {$(\ep,\$\rightarrow\ep)$} (q2)

;
\end{tikzpicture}
\end{center}
    


(Note that in the first transition to be executed, I'm pushing a string onto
the stack.)
Remember that the stack contains a sentential form to be processed.

\input{exercises/cfgpda0/main.tex}

\newpage
OK, now what about converting a PDA to a CFG?
The algorithm is very simple.
I'll refer you to our textbook.

\begin{eg}
Let's look at our PDA that accepts $\{a^n b^n \st n \geq 0\}$.
\begin{center}
\input{stdout57.tex}
\end{center}
Using the algorithm in the textbook, write down a CFG that accepts the same
language as the above PDA.
\end{eg}


Let's talk about how to construct a CFG from a PDA.
Before doing that we will clean up (simplify) the PDA a little so that
the PDA has the following properties:
\begin{mylist}
 \item[(1)] One accept state
 \item[(2)] Clear stack before accepting
 \item[(3)] Each transition is push or pop but not both
\end{mylist}
(1) and (2): EASY! (Right?)

(3) is not too bad:
\input{stdout58.tex}
becomes
\input{stdout59.tex}

Now we assume that the PDA has the above three properties and go on
to construct a grammar that accepts the same language.

The main idea is this:
As the execution of the PDA go from state $p$ to $q$, 
the \lq\lq work done'' is going to be 
described by a grammar variable $V_{pq}$, or rather
the production rule of $V_{pq}$.
(See the book for details.)
Here's the algorithm:
\begin{mylist}
\item[(1)] For each state $q$ (in the PDA), we have the production rule
\[
V_{qq} \rightarrow \ep
\]
(in the CFG).
The intuition here is that if the PDA is at $V_{q}$ and does not
do anything (no transition), then there is no work done. 
\item[(2)] For states $p, q, r$ (in the PDA), we have the production rule
\[
V_{pq} \rightarrow V_{pr} V_{rq}
\]
(in the CFG).
Here, the work done (if any) from $p$ to $r$ is the
work done from $p$ to $q$ and $q$ to $r$.
\item[(3)] For states $p, q, r, s$ in this part of the PDA:

\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto,initial text=]
\node[state] (q) at (5.0,-2) {$q$};
\node[state] (p) at (0.0,-2) {$p$};
\node[state] (s) at (3.5,0.0) {$s$};
\node[state] (r) at (1.5,0.0) {$r$};

\path[->]
(p) edge [left] node {$(a,\ep\rightarrow t)$} (r)
(s) edge [right] node {$(b,t\rightarrow\ep)$} (q)
;
\end{tikzpicture}
\end{center}
we get this production rule in the CFG:
\[
V_{pq} \rightarrow a V_{rs} b
\]  
WARNING: the transitions push a $t$ and pops the $t$ ... it's the same
stack symbol!!!
The intuition here is that the work done from $p$ to $q$ (if any)
is $a$ followed by the work done from $r$ to $s$ and $b$.
\end{mylist}
Hey ... what about the start symbol?
It's
\[
V_{q_0, q_\accept}
\]
where $q_0$ is the start state and $q_\accept$ is the unique accept state.

\begin{eg}
Here's the most famous CFL:
\[
L = \{ a^n b^n \st n \geq 0 \}
\]
\end{eg}
Here's a PDA accepting $L$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto,initial text=]
  \node[state,initial] (a) at (0,0) {$1$};
  \node[state]         (b) at (4,0) {$2$};

  \node[state,accepting] (d) at (0,-4) {$4$};
  \node[state]           (c) at (4,-4) {$3$};

  \path[->]
  (a) edge node {$(\ep, \ep\rightarrow \$)$} (b)

  (b) edge node {$(b, a\rightarrow \ep)$} (c)
  (b) edge [loop right] node {$(a, \ep\rightarrow a)$} (b)

  (c) edge node {$(\ep, \$ \rightarrow \ep)$} (d)
  (c) edge [loop right] node {$(b, a\rightarrow \ep)$} (c)
  ;
\end{tikzpicture}
\end{center}


The goal is to construct a CFG using the algorithm.

First we clean up.
There are two accepts states; otherwise everything is OK.
We make the start state non-accepting and transition to the 4.
But each transition must either push or pop so we can't do the above in a
single transition. 
This is what we do:


\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto,initial text=]
  \node[state,initial] (a) at (0,0) {$1$};
  \node[state]         (b) at (4,0) {$2$};

  \node[state] (e) at (0,-2) {$5$};

  \node[state,accepting] (d) at (0,-4) {$4$};
  \node[state] (c) at (4,-4) {$3$};

  \path[->]
  (a) edge node {$(\ep, \ep\rightarrow \$)$} (b)
  (a) edge node {$(\ep, \ep\rightarrow \$)$} (e)

  (b) edge node {$(b, a\rightarrow \ep)$} (c)
  (b) edge [loop right] node {$(a, \ep\rightarrow a)$} (b)

  (c) edge node {$(\ep, \$\rightarrow \ep)$} (d)
  (c) edge [loop right] node {$(b, a\rightarrow \ep)$} (c)

  (e) edge node {$(\ep, \$ \rightarrow \ep)$} (d)
  ;
\end{tikzpicture}
\end{center}

(or create a new transition from state 1 to 3, saving the necessity of state 
5.)

Done! Now to build the grammar ...

The variables are
\[
V_{11}, V_{12}, \ldots, V_{45}, V_{55}
\]
Wow! \textit{ 25} variables! (Actually that's an overkill 
... later you'll see that some are redundant.)

Now for the production rules.
First we have these:
\begin{align*}
V_{11} &\rightarrow \ep \\
&\vdots \\
V_{55} &\rightarrow \ep \\
\end{align*}
(5 production rules)
and these
\begin{align*}
V_{11} &\rightarrow V_{11} V_{11} \hskip 1cm (p = 1, q = 1, r = 1) \\
V_{12} &\rightarrow V_{11} V_{12} \hskip 1cm (p = 1, q = 1, r = 2) \\
V_{13} &\rightarrow V_{11} V_{13} \hskip 1cm (p = 1, q = 1, r = 3) \\
&\vdots
\end{align*}
(125 production rules!)
Now for the third type of production rules.
\begin{verbatim}
                 r       s
p r s q         (1)     (1)        
1 1 1 1         ^
               / NO SUCH TRANSITION      No transition from (p) to (r)
             (1)           (1)           NO NEW RULE
              p             q

1 1 1 2       SAME ...                   NO NEW RULE!

etc.
                 r       s
                (2)     (2)        
1 2 2 2         ^         \a,e->a
               /e,e->$     v             WHOA! Push $ but pop a!    
             (1)           (2)           NO NEW RULE!
              p             q

\end{verbatim}



\underline{CASE $p=1,q=2,r=2,s=2$:}
\input{stdout60.tex}
WHOA! Push \verb!$! but pop \verb!a!!!!. NO NEW RULE!!!

\underline{CASE $p=1,q=2,r=2,s=3$:}
\input{stdout61.tex}
WHOA! Push \verb!$! but pop \verb!a!!!!. NO NEW RULE!!!


So far we have not collected any new rules.
But ... there \textit{are} some that actually produce rules:


\underline{CASE $p=1,q=2,r=3,s=4$:}
\input{stdout62.tex}
AHA! Push \verb!$! but pop \verb!$!!!!. 
Add new rule $V_{14} \rightarrow \ep V_{23} \ep$, i.e.,
$V_{14} \rightarrow V_{23}$.


\begin{samepage}
\begin{verbatim}

etc.
                 r       s
                (2)     (3)        
2 2 2 3         ^         \b,a->e        AHA! Push a and pop a!!!
               /a,e->a     v             Add new rule V23 -> a V22 b
             (1)           (4)           i.e.  V14 -> V23
              p             q

\end{verbatim}
\end{samepage}

Do you see this:
\begin{samepage}
\begin{verbatim}
   +--------------------------+
   |        (2)    (2)        |
   |        ^        \        | p,r,s,q = 2,2,2,3
   |       /          v       |
   |     (2)          (3)     |
   +--------------------------+
   |     (2)          (3)     |
   |     ^              \     | p,r,s,q = 1,2,3,4
   |    /                v    |
   |  (1)                (3)  |
   +--------------------------+
\end{verbatim}
\end{samepage}
and then finally $V_{22} \rightarrow \ep$?

Do you see how to speed up this computation? Look for push and pop
of the same character. (Usually easier to make a list of transitions
based on push character and another based on pop character --
But when the PDA diagram is simple this is not necessary.

OK ... faster now ...
\begin{samepage}
\begin{verbatim}
                 r       s
p r s q         (5)     (5)        
1 5 5 4         ^         \e,$->e        AHA! Push $ and pop $!!!
               /e,e->$     v             Add new rule V14 -> e V55 e
             (1)           (4)           i.e.  V14 -> V55
              p             q

etc.
\end{verbatim}
\end{samepage}

Altogether
\begin{align*}
V_{14} &\rightarrow V_{23} \\
V_{23} &\rightarrow a V_{22} b \\
V_{23} &\rightarrow a V_{23} b  \hskip 1cm (\text{What's the $p,q,r,s$ for this one?})\\
V_{22} &\rightarrow \ep \\
V_{14} &\rightarrow V_{55} \\
V_{55} &\rightarrow \ep \\
\end{align*}
where $V_{14}$ is the starting symbol.
(I'm only listed the useful rules.)
Let's use a simpler notation:
\begin{align*}
S &\rightarrow T \\
T &\rightarrow a U b \\
T &\rightarrow a T b  \\
U &\rightarrow \ep \\
S &\rightarrow W \\
W &\rightarrow \ep \\
\end{align*}
The last two rules 
\begin{align*}
S &\rightarrow W \\
W &\rightarrow \ep \\
\end{align*}
basically say that $S$ can derive $\ep$:
\begin{align*}
S &\rightarrow T \\
T &\rightarrow a U b \st aTb \\
U &\rightarrow \ep \\
S &\rightarrow \ep
\end{align*}
We get rid of the rule $U \rightarrow \ep$ to get:
\begin{align*}
S &\rightarrow T \\
T &\rightarrow a b \st aTb \\
S &\rightarrow \ep
\end{align*}
The first two rules can be combined:
\begin{align*}
S &\rightarrow a b \st aSb \\
S &\rightarrow \ep
\end{align*}
And finally
\begin{align*}
S &\rightarrow aSb \st \ep \\
\end{align*}

V\'oila! (You were expecting this CFG right?)

The important thing is to understand the motivation behind this
construction.
This will then allow you to compute quickly and also understand the proof
of this theorem and correctness of the algorithm.

\input{exercises/cfgpda1/main.tex}

\input{exercises/cfgpda2/main.tex}

\input{exercises/cfgpda3/main.tex}
