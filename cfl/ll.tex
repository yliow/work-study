% https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/090%20Top-Down%20Parsing.pdf
% https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/090%20Top-Down%20Parsing.pdf

\newcommand\FIRST{\mathsc{First}}
\newcommand\FOLLOW{\mathsc{Follow}}

\sectionthree{LL grammars}
\begin{python0}
from solutions import *; clear()
\end{python0}

\begin{eg}
  Consider the follow CFG:
  \begin{align*}
    S &\rightarrow aA \mid B \mid \ep \\
    A &\rightarrow a \mid bA \mid S \\
    B &\rightarrow bBA \mid aB \mid S
  \end{align*}
  Suppose we want to derive $baa$.
\end{eg}

\begin{enumerate}[nosep]

\item I start off with
  \[
  S \implies ?
  \]

\item  On reading the first symbol of the string $\underline{b}aa$, I see $b$.
  The production rule to use cannot be $S \rightarrow aA$ or
  $S \rightarrow \ep$.
  It has to be $S \rightarrow B$ and then $B \rightarrow bBA$.
  We now have
  \[
  S \implies B \implies \underline{b}BA
  \]
  Note that this is the only way to produce the $b$ on the left
  from $S$
  (see underlined $b$).
  There is also $S \implies B \implies S \implies bBA$, but
  you can see that the $S \implies B \implies S$ is redundant.

\item
  The leftmost variable of $b\underline{B}A$ is $B$.
  I read the next symbol on the input $b\underline{a}a$ and see $a$.
  Therefore I need to somehow derive $B \istar a ...$.
  The only option is to use $B \rightarrow aB$.
  The derivation is now
  \[
  S \implies B \implies bBA \implies baBA
  \]
  (Hmmm ... do you see a stack in $bBA$? i.e., $b\underline{BA}$ where $B$
  is the top of the stack and $A$ is at the bottom?)
\item
  Now the leftmost variable of $ba\underline{B}A$ is $B$
  and the next input symbol
  of $b\underline{a}a$ is $a$
  If I choose to use $B \rightarrow aB$, I will get
  \[
  S \implies B \implies bBA \implies baBA \implies baaBA 
  \]
  since the next symbol in the input string is $ba\underline{a}$ (see
  underlined).
\item
  At this point, I reach the end of input string.
  Therefore I need $B \rightarrow \ep$ which can be achieved by
  using $B \rightarrow S$ followed by $S \rightarrow \ep$.
  Altogether, I get
  \begin{align*}
    S &\implies B \implies bBA \implies baBA \implies baaBA \implies baaBA \\
      &\implies baaSA \implies baa\ep A = baaA
  \end{align*}
\item
    In the same way, since I'm done deriving the input $baa$, I want to
  derive $\ep$ from $A$, which is through $A \implies S \implies \ep$.
  Altogether the derivation is
  \begin{align*}
    S &\implies B \implies bBA \implies baBA \implies baaBA \implies baaBA \\
    &\implies baaSA \implies baa\ep A = baaA \implies baaS \implies baa \ep = baa
  \end{align*}
\end{enumerate}

An \defterm{LL grammar} is a CFG that can be parsed
using LL derivations, i.e., derivations which are
parsed left-to-right (i.e., the decision on choosing
which production rule is based on reading the input
string character-by-character left-to-right)
and by producing a leftmost derivation (i.e.,
the leftmost variable is chosen to be replaced).
The LL stands for \lq\lq \underline{L}eft-to-right" and
\lq\lq \underline{L}eftmost derivation".

An \defterm{$LL(k)$ grammar}
is an LL CFG that can be parsed with $k$ lookaheads, i.e.,
every $\leq k$ symbols read from the input string is sufficient
to determine correctly which production rule to use for a
leftmost derivation.
This means that for any word in generated by the grammar,
during the derivation process, when we arrive at
\[
S \implies \ldots \implies aabaabaA...
\]
where the leftmost variable is $A$ and the next $\leq k$ input symbols are
$aabbb$, then there is a unique sequence of production rules
that will derive
\[
A \implies aabbb ...
\]  
The parser (the algorithm) that determines the correct production
rule for such a derivation is called an
\defterm{$LL(k)$ parser}\tinysidebar{$LL(k)$ parser}.

Note that only the $k$ symbols read from the input (and the leftmost
variable) is used to
determine the right production rule to use.
For instance this means that if the derivation arrives at a stage where
\[
S \implies \ldots \implies aaba\underline{BAaaaaAB}
\]
then there are terminal on the underlined sentential form
and the parser would also need to look at the sentential form and the input.
This can be easily modified simply by add some rules.
For instance suppose the $aaaa$ was created by a rule $A \rightarrow Aaaaa$,
then we just add replace the above rule by $A \rightarrow AZZZZ$ and
$Z \rightarrow a$, effectively changing this rule into Greibach normal form.

I will now focus on the $LL(1)$ parsers, i.e., I will only read one
input symbol.
Of course the main task is this: when given a variable, say $A$, and an input
symbol, say $a$, we need to find a sequence of derivations that does the
following:
\[
A \istar  a ...
\]
i.e., $A$ derives a sentential form that begins with $a$.
One possibility is that there's a production rule of the form
\[
A \implies aBCDEF
\]
But that's not that only case.
The $a$ might be derived not by $A$ but by another variable.
For instance
\[
A \implies BCD \implies a ....
\]
where $A \rightarrow BCD$ is a production rule and $B \rightarrow aBEF$
is another production rule.
But not only that: it's also possible that the $a$ is actually produced by
$C$ or $D$.
That happens if $B \rightarrow \ep$ is a production rule so that
the derivation might be
\[
A \implies BCD \implies \ep CD \implies \ep aaaaGHID ....
\]
where $C \rightarrow aaaaGHI$ is a production rule.

So the base case is to consider the first terminals that $A$ can product
by itself. This involves looking at production rules with $A$ on the left:
\[
A \rightarrow ?
\]
For instance if
\[
A \rightarrow abbbbBCD
\]
then I know \lq\lq $A$ can produce $a$" and I want to document that.
The set of terminals that $A$ can produce is usually called the
\defterm{first set}\tinysidebar{first set} of $A$.
This is usually denoted by
\defterm{$\mathsc{First}(A)$}
\tinysidebar{$\mathsc{First}(A)$}.

Then we have to consider the case where $A$ produces a terminal not
directly but through other variables.
This means we look at all production rules of the form
\[
A \rightarrow BCDEF
\]
In the following $a$ denotes a terminal.
\begin{enumerate}[nosep]
  \li If $B$ can derive $a...$ then put $a$ into $\mathsc{First}(A)$.
  \li If $B$ can derive $\ep$ and $C$ can derive $a$, then put $a$ into
  $\mathsc{First}(A)$.
  \li If $B,C$ can derive $\ep$ and $D$ can derive $a$, then put $a$ into
  $\mathsc{First}(A)$.
  \li Etc.
  \li If $B,C,D,E,F$ can derive $\ep$, then $A$ can derive $\ep$.
\end{enumerate}
Two things: First, instead of saying \lq\lq $B$ can derive $\ep$", it's also
convenient in this case to put $\ep$ into
$\mathsc{First}(B)$.
(Previously we say that $B$ is nullable and put $B$ is the
$\mathsc{Nullables}$ set.)
Second, I need to consider the case when $B$ is a terminal, say
\[
A \rightarrow bCDEF
\]
where $b$ is a terminal. Then I have to put $b$ into $\FIRST(A)$.
To make less of a fuss so that the the rules are simplified and need not
change too much,
I might as well define $\FIRST(b) = \{b\}$.

With the above, here's a rewrite of the above
\begin{enumerate}[nosep]
  \li For every terminal $a$, set $\mathsc{First}(a)$ to $\{a\}$.
  \li For every variable $A$, set $\mathsc{First}(A)$ to $\emptyset$.
  \li For each production rule of the form $A \rightarrow \ep$,
  put $\ep$ into $\mathsc{First}(A)$.
  \li For each production rule of the form $A \rightarrow BCDEF$ where
  $B,C,D,E,F$ are terminals or variables:
  \begin{enumerate}[nosep]
    \li Put $\mathsc{First}(B) - \{ \ep \}$ into $\mathsc{First}(A)$.
    \li If
    $\ep \in \mathsc{First}(B)$, then put
    $\mathsc{First}(B) - \{ \ep \}$ into $\mathsc{First}(A)$.
    \li
    If
    $\ep \in \mathsc{First}(B)$,
    $\ep \in \mathsc{First}(C)$ then put
    $\mathsc{First}(D) - \{ \ep \}$ into $\mathsc{First}(A)$.
    \li Etc.
    \li If
    $\ep \in \mathsc{First}(B)$,
    $\ep \in \mathsc{First}(C)$, ...,
    $\ep \in \mathsc{First}(F)$ then put
    $\ep$ into $\mathsc{First}(A)$.
  \end{enumerate}
\end{enumerate}
(Again, note that $\ep \in \FIRST(A)$ is the same as saying the $A$ is
in the sets of nullables.)
The above computes $\FIRST(A)$ for every variable $A$.

You can also compute $\FIRST(w)$ where $w$ is a string of terminals and variables.
(The reason for doing this is because we will be using such $\FOLLOW$ sets
in later computations.)
Suppose $w = w_1 \cdots w_n$ where each $w_i$ is either a terminal or a variable. 
\begin{enumerate}[nosep]
\item Set $\FIRST(w)$ to $\{\}$.
\item Put all values of $\FIRST(w_1) - \{\ep\}$ into $\FIRST(w)$.
\item If $\ep \in \FIRST(w_1)$, put all values of $\FIRST(w_2) - \{\ep\}$ into $\FIRST(w)$.
\item If $\ep \in \FIRST(w_1), \ep\in\FIRST(w_2)$, put all values of $\FIRST(w_3) - \{\ep\}$ into $\FIRST(w)$.
\item Etc.
\item If $\ep \in \FIRST(w_1), ..., \ep\in\FIRST(w_n)$, put $\ep$ into $\FIRST(w)$.
\end{enumerate}
So now with this definition, $\FIRST(w)$ is the set of all first terminals that
can appear in a derivation starting with $w$:
$w \istar a w'$ iff $a \in \FIRST(w)$ and
$w \istar \ep$ iff $\ep \in \FIRST(w)$.



\begin{eg}
  Consider the follow CFG:
  \begin{align*}
    S &\rightarrow aA \mid B \mid \ep \\
    A &\rightarrow a \mid bA \mid S \\
    B &\rightarrow bBA \mid \ep
  \end{align*}
\end{eg}
Here are the first sets
{\small
\begin{longtable}{|cc|}
  \hline
  $x$ & $\FIRST(x)$  \\ \hline
  $a$ & $a$          \\
  $b$ & $\ep, b$     \\
  $S$ & $\ep,a,b$    \\
  $A$ & $\ep,a,b$    \\
  $B$ & $\ep,b$      \\ \hline
\end{longtable}
}
  
Note that the above is what you usually see in compiler books.
Usually besides the fact that $\mathsc{First}(A) = \{a\}$
you also want to know which production rule allows
$A$ to derive a sentential form that begins with $a$.
If the rule is
$A \rightarrow aBC$, then you may want to record
$\mathsc{First}(A) = \{(a, A \rightarrow aBC) \}$
and of course if the first set of $A$ is huge you want to search for
$a$ to be fast.
In particular the data structure on the right can be
an array (or a hashtable).
And when all the first set of variables are collected
together, it might be arranged as a 2D array
with rows labeled by variables and columns labeled by terminals.

For the above example
{\small
\begin{longtable}{|c||c|c|c|}
  \hline
    & $\ep$            & $a$             & $b$                 \\ \hline\hline
$S$ & $S \implies \ep$ & $S \implies aA$ & $S \implies B \implies bBA$ \\ \hline
$A$ &                  & $A \implies a$  & $A \implies bA$  \\ \hline
$B$ & $B \implies \ep$ &                 & $B \implies bBA$ \\ \hline
\end{longtable}
}
(Of course the production rules $S \rightarrow B$ and $B \rightarrow bBA$ can
be combined, i.e., I could have run through the grammar to remove unit productions.)
If I want to derive $aa$ from the above grammar,
using the table I do
\begin{align*}
  S
  &\implies aA & & \text{using $(S, a)$} \\
  &\implies aa & & \text{using $(A, a)$}
\end{align*}

For the derivation to be successful, of course there
there cannot be two options in each cell of the above table.

Note that the grammar also generate $ba$ because of the derivation
\[
S \implies B \implies bBA \implies b \ep a = ba
\]
However if I follow the 1--lookahead strategy (i.e., use the table),
I would read the $b$ in $\underline{b}a$ and derive 
\[
S \implies B \implies bBA
\]
Reading the next input symbol, I see $a$, and the leftmost variable now is $B$.
However $(B,a)$ does not give me anything, i.e., $B$ cannot derive a first symbol of $a$.

Why?

Because it's not the $B$ that derives the $a$.
It's actually the $A$ after the $B$ that derives the $a$.

More generally,
if you have the following derivation
\[
ABCDEF \istar a...
\]
as part of complete derivation starting with $S$,
it might not be due to $A$ deriving $a...$ (like what we talked about
above regarding the $\mathsc{First}(A)$).
It might be due to $B$ (or $C$ or $D$ or ...).
This means that in the above derivation $A$ produces $\ep$:
\[
ABCDEF \istar \ep BCDEF \istar \ep aCDEF
\]
This will not be detected by $\FIRST(A)$ sets
because it really due to the fact that
\begin{enumerate}[nosep]
  \li $\ep \in \FIRST(A)$, $a \in \FIRST(B)$, or
  \li $\ep \in \FIRST(A)$, $\ep \in \FIRST(B)$, $a \in \FIRST(C)$, or
  \li etc.
\end{enumerate}

Going back to the earlier example when I was trying to derive $ba$
\[
S \implies B \implies bBA
\]
and I cannot move forward to derive $a$ as a first symbol using $B$,
I now need to have a way to derive $B \implies \ep$ but only is I know
$a \in \FIRST(A)$ is right after the $B$.
Now if I delay replacing $B$ by $\ep$, and replace $A$ by $a$,
the derivation would have been
\[
S \implies B \implies bBA \implies bBa
\]
I would say that $a$ \lq\lq follows" $B$.
In terms of the derivation tree, this means that either the $a$
is under the subtree of node $A$ or the $a$ is \textit{not} under the subtree
of node $A$ but appears as the first leaf of the subtree immediately to the right.

More generally, if there is some derivation
\[
S \istar wAaw'
\]
where $a$ is a terminal and $A$ is a variable, then $a \in \FOLLOW(A)$.
This can happen through applying a production rule where
\[
S \istar ... V ... \implies ... wAaw' ...
\]
i.e., through the production rule $V \rightarrow wAaw'$ where the
\lq\lq following"
terminal of $A$ is introduced during the same derivation step (on the righthand
side of the rule).
Of course it's possible that $A$ and $a$ are produced from a single production
rule but they are not immediately next to each other.
For instance the production rule is
\[
V \rightarrow wAw'aw''
\]
and furthermore $w' \istar \ep$. This means that $w'$ is a string of
variables which are nullable.
Of course if $\epsilon$--productions have been removed (see earlier section),
this $w'$ does does exist.

A second way is where $A$ and $a$ appears in the derivation \textit{not} through
the same production rule:
\[
S \istar ... V V' ... \implies ... (wAw')(w'' a w''') ...
\]
where the production rules are $V \rightarrow wAw'$ and
$V' \rightarrow w''Aw'''$; or there might be more productions between
$wAw'$ and $w''aw'''$:
\[
S \istar ... V \underline{...} V' ... \implies ... (wAw') \underline{w''''} (w'' a w''') ...
\]
Note that in this case, if $a$ is not derived in $wAw'$,
then it's derived in $w'''' (w'' a w''') ...$, i.e., the string after $wAw'$
and for the $a$ be follow $A$ immediately, this means that
the $w'$ in $wAw'$ must derive $\ep$ and the $w'''' (w'' a w''') ...$
must derive $a$ as the \textit{first} symbol. 
But that means either $w'$ is not there or at least derives $\ep$
and that $a$ follows $V$:
\[
S \istar ... V \underline{... V' ...} \implies ... (wAw') \underline{w'''' (w'' a w''') ...}
\]
Therefore to construct $\FOLLOW$ sets,
\begin{enumerate}[nosep]
\item Set $\FOLLOW(A) = \{\}$ for all variables $A$.
\item Set $\FOLLOW(S) = \{ \$ \} $
  (the \$ is just used as an end of string marker and we add \$ to the
  end of the original input; 
  as usual is to fix the issue of $\epsilon$-productions)
\item For each production $V \rightarrow wAw'$ where $w,w'$ are strings of
  terminals and variables
  and $A$ is a variable, put values of $\FIRST(w') - \{\ep\}$ into $\FOLLOW(A)$.
\item For each production $V \rightarrow wA$, put values of $\FOLLOW(V)$ into $\FOLLOW(A)$.
\item For each production $V \rightarrow wAw'$ where $\ep \in \FIRST(w')$,
  put values of $\FOLLOW(V)$ into $\FOLLOW(A)$.
\end{enumerate}

\begin{comment}
\begin{eg}
  From the earlier grammar
  \begin{align*}
    S &\rightarrow aA \mid B \mid \ep \\
    A &\rightarrow a \mid bA \mid S \\
    B &\rightarrow bBA \mid \ep
  \end{align*}
\end{eg}
{\small
\begin{longtable}{|cc|}
  \hline
  $x$ & $\FIRST(x)$  \\ \hline
  $a$ & $a$          \\
  $b$ & $\ep, b$     \\
  $S$ & $\ep,a,b$    \\
  $A$ & $\ep,a,b$    \\
  $B$ & $\ep,b$      \\ \hline
\end{longtable}
}
Here's our table using $\FIRST$ sets:
{\small
\begin{longtable}{|c||c|c|c|}
  \hline
    & $\ep$            & $a$             & $b$                 \\ \hline\hline
$S$ & $S \rightarrow \ep$ & $S \rightarrow aA$ & $S \rightarrow B \rightarrow bBA$ \\ \hline
$A$ &                  & $A \rightarrow a$  & $A \rightarrow bA$  \\ \hline
$B$ & $B \rightarrow \ep$ &                 & $B \rightarrow bBA$ \\ \hline
\end{longtable}
}
Note that $B$ is nullable (i.e., $\ep \in \FIRST(B)$) and $a$ follows $B$.
So
\[
BA \implies \ep a = a
\]
{\small
\begin{longtable}{|c||c|c|c|}
  \hline
    & $\ep$            & $a$             & $b$                 \\ \hline\hline
$S$ & $S \implies \ep$ & $S \implies aA$ & $S \implies B \implies bBA$ \\ \hline
$A$ &                  & $A \implies a$  & $A \implies bA$  \\ \hline
$B$ & $B \implies \ep$ & $BA \implies A \implies a$ & $B \implies bBA$ \\ \hline
\end{longtable}
}
\end{comment}
