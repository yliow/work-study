\sectionthree{Cocke--Younger--Kasami Algorithm}
\begin{python0}
from solutions import *; clear()
\end{python0}

The
\defterm{Cocke--Younger--Kasami algorithm} (\defterm{CYK})
\tinysidebar{Cocke--Younger--Kasami algorithm\\CYK}
is an algorithm that determine if a string is generated by a CFG.
And if a string is generated by the CFG,
the algorithm can also give all the possible derivations.
In other words, it is a string parsing algorithm.
The time complexity is $O(n^3)$ where $n$ is the length of the string
(details below).
Later, faster algorithms were discovered.
For instance there is one with time complexity $O(n^{2.8})$.
The algorithm uses a very important technique in the design of algorithms
-- dynamic programming technique -- it builds up a solution by combining
solutions of subproblems of the given problem. 
Dynamic programming is an extremely important algorithm design technique
an is frequently used even in research.
(So it's not just a neat trick used in basic undergrad courses.)
One CYK dynamic programming example is definitely not enough.
See CISS358 for more details on dynamic programming.

Of course you can parse a string $w$ without CYK:
If $w$ is $\ep$, just check if $S$ is a nullable symbol.
Assuming the CFG is in Chomsky normal form, then every
production will increase the length of the sentential form
or replace a variable with a terminal.
So you need $|w|$ productions to introduce $|w|$ variables into the
derivation process and you need $|w|$ productions to replace the variables
with terminals. So there are at most $2|w|$ derivation steps, which is
of course finite.
So you just check every possible sequence of $2|w|$ productions starting
with $S$ and see if you can arrive at $w$.
Is this a good algorithm?
(Note sarcasm ...)

The main idea of CYK is very simple.
First we assume the grammar $G$ is in Chomsky normal form.
\sidebar{{\scriptsize Chomsky, Chomsky, Chomsky!}}
Now suppose our string $w$ has length $n$.
Let $w_{i,j}$ denote the substring of $w$ starting at position $i$ with 
length $j$.
The first position is $1$ and the last position is $n$.
The string $w$ is just
\[
w = w_{1,1} w_{2,1} w_{3,1} w_{4,1} \cdots w_{n,1}
\]

\begin{eg} 
Let $w = baabaa$. Then $w_{2,3} = aab$.
\end{eg}


\input{exercises/cyk0/main.tex}

\newpage
First of all we can always determine if each $w_{i,1}$ can be
derived:
$A$ derives $w_{i,1}$ if and only if $A \rightarrow w_{i,1}$ is a production
(don't forget that we're assuming the grammar is in Chomsky Normal Form).
\sidebar{{\scriptsize Chomsky, Chomsky, Chomsky!}}


What about the general case?
How do you generate $w_{i,j}$?
This is a string starting at position $i$ and of length $j$.
What happens when you cut up the string?
Suppose you break it up into two strings $w_{i,j} = xy$.
Well, $x$ starts at the same index position in $w$ as $w_{i,j}$ right?
So it must be of the form
\[
x = w_{i,k}
\]
Since $x$ is a substring of $w_{i,j}$, it's length must be at most $j$.
Therefore $k \leq j$.
But let's assume that we really did cut up the string so that $y$ is not the 
empty string.
So $k < j$.
OK.
So we have
\[
  w_{i,j} = w_{i,k} y \text{ where } k < j
\]
Now let's think about $y$.

$y$ starts at position $i + k$, right?
And what is the length of $y$?
It's $|w| - |x|$ which is $j - k$.
So
\[
  y = w_{i + k, j - k}
\]
Viola.

Altogether, 
$w_{i,j}$ is the concatenation of $w_{i,k}$ and $w_{i+k, j-k}$
where $k < j$ (i.e., $k = 1, 2, \ldots, j - 1$):
\[
w_{i,j} = w_{i,k} w_{i+k, j-k}, \hskip 1cm (k = 1, 2, \ldots, j - 1)
\]
So what we'll do is
to find a variable, say $X$, deriving $w_{i,k}$:
\[
  X \istar w_{i,k}
\]
and 
another, say $Y$, deriving $w_{i+k, j-k}$
\[
  X \istar w_{i,k}
\]
for all the given $k$'s.
That means that $XY$ derives $w_{i,j}$
\[
  XY \istar w_{i,j}
\]
If the grammar is in Chomsky Normal Form, we will then look at the 
production rules to find a rule of the form $Z \rightarrow XY$.
If this is found, then $Z$ must derive $XY$ which derives $w_{i,j}$:
\[
  Z \implies XY \istar w_{i,j}
\]
That's the main idea.

The important thing to understand is that we are breaking down
out $w$ into two substrings exactly because the grammar is in
Chomsky Normal Form.
\sidebar{{\scriptsize Chomsky, Chomsky, Chomsky!}}
If the grammar has a production rule of the form
$Z \rightarrow WXY$, then our string $w$
might be derived through this production rule and in that case
we would have to break up $w$ into \textit{three} substrings
where $W$ derives the first, $X$ derives the second, and $Y$
derives the third.
The more variations there are in the right hand side of the
production rules of the grammar, the more cases
we would need to analyze to cover
all possibilities in the derivation process.
Get it?

Now let's go through an example ...


\newpage
\begin{eg}
Consider the grammar:
\begin{align*}
S &\rightarrow AB \st AC \\
A &\rightarrow BC \st a \\
B &\rightarrow CB \st b \\
C &\rightarrow AA \st b
\end{align*}
Note that this is already in Chomsky Normal Form.
Is $baaab$ generated by the grammar?
\end{eg}

\SOLUTION
For this example $w = baaab$.
We will systematically tabulate the variables deriving $w_{i,j}$.
The variables deriving $w_{i,j}$ will be placed at row $j$ and column $i$:
\input{stdout01.tex}

\underline{First Row}:
We first work out $w_{i,1} = b$:
\input{stdout02.tex}

$b$ is derived only by $B \rightarrow b$ and $C \rightarrow b$:
\input{stdout03.tex}
If you are interested in not just knowing if $baaaab$ is generated by the given grammar,
but you actually want to write down the derivation, it's helpful to include
some addition information for each variable in the cells.
I'll write these extra information in subscript.
I'll show you how these extra information will be used later.
\input{stdout04.tex}
In the above, the $B_b$ means \lq\lq $B$ will derive $b$''.

$a$ is derived by $A \rightarrow a$. This allows us to complete
the first row:
\input{stdout05.tex}

In summary, to fill the first row, you need only to look at the
productions of the form $\langle variable \rangle \rightarrow \langle terminal
\rangle$.
(Don't memorize this. You should understand the goal and the math involved.)

\underline{Second Row}:
Now let's look at the $j=2, i=1$, i.e. $w_{1, 2}$:
\input{stdout06.tex}
Now
\[
w_{1,2} = w_{1,1} w_{2,1}
\]
(There's only one way to cut up $w_{1,2}$ into two proper substrings.)
But we already know that the variable deriving $w_{1,1}$ is at the $(1,1)$
entry in the table: it's either $B$ or $C$.
We also know that the variable deriving $w_{2,1}$ is at the $(1,2)$ entry;
this is $A$.
Therefore we want to find a variable $V$ such that 
\[
V \rightarrow BA
\]
or
\[
V \rightarrow CA
\]
is a production rule.
(Why do we consider only this scenario? Let's hear it ... 
\textit{ Chomsky, Chomsky, Chomsky, ...}
$BA$ and $CA$ does not appear on the right-hand side of the productions in 
the grammar.
READ THIS PARAGRAPH AGAIN!
So there are no such $V$s.
We will indicate this by putting $\emptyset$ at $(2, 1$).

The cells we looked at in order to fill the entry at $(2,1)$ are shaded.
\input{stdout07.tex}

Using the same idea, we can fill in the entry at $(2,2)$:
\input{stdout08.tex}
Here, $C$ derives $AA$.
The subscript data of $C$, i.e. $(1,2)$ and $(1,3)$, tells us that $C$
derives $XY$ where variable $X$ is in cell $(1,2)$ and
$Y$ is in cell $(1, 3)$.

Here's the table with row 2 completed:
\input{stdout09.tex}

Again, recall the aim: We're trying to fill the $(j,i)$ 
entry of the table with a variable that can derive $w_{i,j}$.

\underline{Third Row}:
Now we look at $j = 3, i = 1$:
\input{stdout10.tex}
We want to to find a variable $V$ that derives $w_{1,3}$.
Recall from the above that we want to make use of previous results.
The following are the possible ways of breaking up $w_{1,3}$:
\[
w_{1,1}w_{2,2} \hskip 1cm \text{or} \hskip 1cm w_{1,2} w_{3,1}
\]
In other words if $w_{1, 3}$ is $xyz$ then the two ways to break up 
$w_{1,3}$ into two proper substrings are:
\[
x \cdot yz \hskip 1cm \text{or} \hskip 1cm  xy \cdot z
\]
We already know that the variable deriving $w_{1,1}$ is in the
entry at $(1,1)$ of the table: it's $B$ or $C$.
For $w_{2,2}$, just look at the entry at $(2,2)$; $C$ derives 
$w_{2,2}$.
Therefore $BC$ and $CC$ derives $w_{1,1}w_{2,2}$ which is just 
$w_{1, 3}$.
Now we want to find $V$ that derives $BC$ or $CC$:
\[
  V \implies XY \text{ where } X \in \{B, C\} \text{ and } Y \in \{C\} 
\]
and enter that
into the $(3,1)$ entry of the table.
Checking the grammar, we see that only $A$ can do this.
Therefore we have
\input{stdout11.tex}
We're not done yet because $w_{1,3}$ can also be $w_{1,2} w_{3,1}$.
\input{stdout12.tex}
When you check the entry at $(2,1)$, you see that no variable can derive $w_{1,2}$, i.e.,
there is no $V$ such that
\[
  V \implies XY \text{ where } X \in \emptyset, Y \in \{A\}
\]
Therefore we have nothing else to add to the entry at $(3,1)$.
Altogether we have:
\input{stdout13.tex}

Notice that while working on the entry at $(3,1)$, we looked at 
$(1,1),(2,2)$ and also $(2,1),(1,3)$.
Do you notice that there's a pattern in the pairs of cells that
contribute to the two cases in filling the cell at $(3,1)$?
\input{stdout14.tex}

Now we move on the the entry at $(3,2)$:
\input{stdout15.tex}

This corresponds to $w_{2,3}$ and
\[
w_{2,3} = w_{2,1}w_{3,2} \hskip 1cm \text{or} \hskip 1cm w_{2,2}w_{4,1}
\] 
First for $w_{2,3} = w_{2,1}w_{3,2}$, we want to find variables that can derive
$AC$; there's only one: $S$.
\input{stdout16.tex}

For $w_{2,3} = w_{2,2}w_{4,1}$, we want to find variables 
that can derive $CA$: there isn't any.
So there's nothing to add:
\input{stdout17.tex}

Notice the patterns of the pairs of cells that contribute to the 
computation at $(3,2)$:
\input{stdout18.tex}

Now following the same method, complete the second row yourself.

\[
  \text{[PAUSE]}
\]

\newpage
The table should now look like this:
\input{stdout19.tex}

\underline{Fourth Row}:
Now we look at the entry for $(4,1)$.
I think you can see the pattern now.
Basically you need to look at the following cases:
\input{stdout20.tex}
Note the traversal pattern:
\input{stdout21.tex}

For
\input{stdout22.tex}
we are looking for a variable $V$ such that
\[
  V \rightarrow XY \text{ where } X \in \{B,C\}, Y \in \{S\}
\]
There is no such $V$.
For
\input{stdout23.tex}
since there are no variables at $(2, 1)$, we don't have any $V$'s to add to $(4,1)$.
For
\input{stdout24.tex}
we want $V$ such that $V \rightarrow AA$. There's only one case: $V = C$.
Altogether we have
\input{stdout25.tex}

For entry (4,2) you should get:
\input{stdout26.tex}

For entry (4,3) you should get:
\input{stdout27.tex}

\underline{Fifth Row}:
\input{stdout28.tex}
At $(5, 1)$ we use $S \rightarrow AC$ and at $(5,2)$ we use $B \rightarrow CB$.

\underline{Sixth Row}.
Using the following traversal shown, you should get the following entry for (6,1):
... and we're done!!! Here's the final table:
\input{stdout29.tex}

So what have we achieved? First of all $S$ is in the entry at $(6,1)$.
What does this mean? 
Recall again that this means $S$ can derive $w_{1,6}$, which is the
string we started with, i.e. $baaaab$.
Secondly, you can write down the productions that derive $baaaab$ from $S$.
Can you write them down using the table? [SPOILERS AHEAD ...]

Of course CYK gives you even more.
For instance we also know that $B$ is also in the entry at (6,1).
This means that $B$ can also derive $baaab$.
If you look at the entry at (2,5), you conclude that $B$ can derive $aaab$.
In other words besides addressing the question of whether $baaaab$ can be
generated by the grammar, we have also answered the question for all
substrings of $baaaab$.
Make sure you see this.

OK ... so you know that $S$ can derive $baaaab$ (i.e.
$baaaab \in L(G)$ for the above CFG $G$).
But what is the derivation?
If you've understood the mathematical reasoning so far,
you should have no problems writing down the derivation.
\newcommand\ddd{&\implies}
\begin{align*}
  S_{(3,1)(3,4)}
  &\implies A_{(1,1)(2,2)} \cdot B_{(2,4)(1,6)} \\
  &\implies B_b \cdot C_{(1,2)(1,3)} \cdot B_{(2,4)(1,6)} & & \text{(or $C_b$ instead of $B_b$)} \\
  &\implies b \cdot C_{(1,2)(1,3)} \cdot B_{(2,4)(1,6)} \\
  &\implies b \cdot A_a \cdot A_a \cdot B_{(2,4)(1,6)} \\
  &\implies b \cdot a \cdot A_a \cdot B_{(2,4)(1,6)} \\
  &\implies b \cdot a \cdot a \cdot B_{(2,4)(1,6)} \\
  &\implies b \cdot a \cdot a \cdot C_{(1,4)(1,5)} \cdot B_b & &  \text{(or $C_b$ instead of $B_b$)} \\
  &\implies b \cdot a \cdot a \cdot A_a \cdot A_a \cdot B_b \\
  &\implies b \cdot a \cdot a \cdot a \cdot A_a \cdot B_b \\
  &\implies b \cdot a \cdot a \cdot a \cdot a \cdot B_b \\
  &\implies b \cdot a \cdot a \cdot a \cdot a \cdot b
\end{align*}

Note that if you are only interested in whether $baaaab$ is generated by the grammar
(and not the actual derivation), then you only need to fill the CYK table in
the following way:
\input{stdout30.tex}

The CYK algorithm requires us to fill data into half of an $n$--by--$n$
array -- there are altogether $(1/2)n^2$ cells to fill.
Each cell $X$ of the array requires us to go through at most $n$ pairs
of cells which are already fill and see if we can find a production rule
that can help in filling cell $X$.
(We can speed up the search for a suitable production rule
if we find a suitable organization for the collection
of production rules. Which one?)
Therefore the total runtime is $O(n^3)$.
The space complexity is of course $\Theta(n^2)$.
(If you want to take into account the grammar, then the runtime is
$O(n^3 |G|)$ where $|G|$ is the size of the grammar
which is the total count of all symbols that appear
in all the production rules.)

\input{exercises/cyk1/main.tex}

\input{exercises/cyk2/main.tex}

\input{exercises/cyk3/main.tex}

\input{exercises/cyk4/main.tex}

1. 
\input{stdout31.tex}
The derivations are
\begin{align*}
  S \implies AA \implies aA \implies aa \\
  S \implies AB \implies aB \implies aa \\
  S \implies BA \implies aA \implies aa \\
\end{align*}

\input{exercises/cyk5/main.tex}

\input{exercises/cyk6/main.tex}

\input{exercises/cyk7/main.tex}
