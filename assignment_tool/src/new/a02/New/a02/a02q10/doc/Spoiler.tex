SPOILER ALERT!!! ... 
SPOILER ALERT!!! ... 
SPOILER ALERT!!!

As a pre-processing step,
create a collection of unique fractions in your range, i.e., with
numerators in [-100, 100]
and denominators in [1, 100].

Then run through this collection of unique fractions with the same
idea as in Q9.

At this point, you don't know how to create an array of fractions.
You do know how to create an array of integers (or doubles or bools or chars).
So your collection of fractions has to be an array of numerators
and an array of denominators.
(You have seen this before in CISS240.)
So if the numerator array is \verb!n!
and the numerator array is \verb!d!,
then \verb!n[5]!,
\verb!d[5]!
would be the fifth unique fraction in your collection.

You can also sort this collection of fractions.
Why would you do that?
Before in your loops over the fractions, your second loop
can start with the same fraction value as the first, i.e., the second
loop should NOT start with the first fraction in your collection of fractions.
Therefore the structure of code should look like this:
\begin{console}
for i = 0, 1, 2, ..., n - 1: // assuming you have n unique fractions
    for j = i, ..., n - 1:
        for k = j, ..., n - 1:
            do something with fraction n[i]/d[i] and n[j]/d[j] and n[k]/d[k]  
\end{console}
Get it?

Another thing you should be aware of (which might be useful in the future).
Besides the \verb!int! type, there's also something called the
\verb!long long int! type which can represent larger integers not covered by
\verb!int!.
There's also something called \verb!long double!.
These are very useful for number crunching operations in cryptography, stocks,
physics, etc.
