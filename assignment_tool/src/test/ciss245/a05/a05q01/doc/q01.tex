%-*-latex-*-
This is a practice on pointers and using the free store (memory heap).

Your are given the function \verb!factorial()! which computes
the factorial of $n$. 
(Don't remember factorial? Review right away.
Also google \lq\lq factorial'' and read about the importance of
this function.)
The goal is to write a similar function \verb!factorial2()!
that does the same thing but in a different way.

The function \verb!factorial()! is really old stuff from the early days of
CISS240.
It uses integer variable \verb!i!
to run over the integer from \verb!1! to \verb!n!.
The product of these integers are stored in \verb!p!.
The function then returns a copy of the value of
\verb!p! which would be the factorial of \verb!n!
after the loop.

The function \verb!factorial2()! does the same thing but
uses pointers \verb!i! and \verb!p!.
These pointers must point to integer values in the free
store (or memory heap) and therefore you must allocate memory
for them.
Furthermore you must deallocate the memory used to prevent
memory leaks.
Because the memory (i.e., the final factorial value) used by \verb!p!
will be deallocate, you must retain it in an \verb!int!
variable. That's the purpose of \verb!ret!.

To make \verb!factorial()! and \verb!factorial2()! as similar
as possible, notice that I have mirrorred the \verb!ret!
variable in \verb!factorial!. For \verb!factorial!,
the variable \verb!ret! is redundant: obviously you could have
returned the value of \verb!p! in \verb!factorial()!.
I'm using \verb!ret! in \verb!factorial()! to make it easier for you
when you're writing \verb!factorial2()!.
Note that for the case of \verb!factorial2()!, you must
make a copy of the \verb!int! value from \verb!*p! to 
\verb!ret!. 
Why?
Because after you deallocate the memory used by \verb!p!
(i.e., release the memory that \verb!p! points to back to the free store),
you cannot refer to \verb!*p! anymore.
As an aside, the more natural way to write the \verb!factorial()! function
is this (see CISS240 notes/textbook):
\begin{console}
int factorial(int n)
{
    int p = 1;
    for (int i = 1; i <= n; i++)
    {
        p *= i;
    }
    return p;
}
\end{console}

The goal is to complete \verb!factorial2()!.
The following skeleton code must be used.
Do NOT declare any extra variables in \verb!factorial2()!.
Do NOT change \verb!main()!.

\begin{Verbatim}[commandchars=\~\!\@,frame=single]
#include <iostream>

int factorial(int n)
{
    int p = 1;
    int i = 1;

    // Compute factorial of n and store in p
    for (i = 1; i <= n; i++)
    {
         p *= i;
    }

    int ret = p; 
    return ret; 
}

int factorial2(int n)
{
    // Declare pointer p, allocate memory for p, and initialize *p
    int * p = new int;
    *p = 1;

    // Declare pointer i, allocate memory for i, and initialize *i
    // TO BE COMPLETED.

    // Compute the factorial of n and store at *p
    // TO BE COMPLETED.

    int ret = *p; // Copy factorial stored at *p into ret
    // Deallocate memory for i. TO BE COMPLETED.
    // Deallocate memory for p. TO BE COMPLETED.
    return ret;
}


int main()
{
    int n = 0;
    std::cin >> n;
    std::cout << factorial(n) << ' ' 
              << factorial2(n) << '\n';
    return 0;
}
\end{Verbatim}



\textsc{Test 1}
\begin{console}[commandchars=\\\{\}]
\underline{4}
24 24
\end{console}
