%-*-latex-*-
\sectionthree{\cpp\ STL \texttt{std::vector} exercises}
\begin{python0}
from solutions import *; clear()
\end{python0}

You know what you should:
practice all the new \cpp\ concepts (iterators and initializer list)
and redo as many array algorithms as you can.

\begin{ex}
  Implement a linear search function on a \verb!std::vector< T >!
  object \verb!v! using the concept of iterator.
  (This is just the \verb!std::find!.)
  The return value is an iterator (not an index).
  If the target value is not found, return \verb!v.end()!.
\end{ex}

\begin{ex}
  Implement a bubblesort function on a \verb!std::vector< T >!
  object using iterators.
\end{ex}

\begin{ex}
  Implement a binary search function on a \verb!std::vector< T >!
  object \verb!v! using iterators.
  If the target value is not found, return \verb!v.end()!.
  (Hint: You'll need \verb!std::distance!.)
\end{ex}

\begin{ex}\mbox{}
  \begin{enumerate}[nosep]
  \item
    Create a function \verb!randvec(n, a, b)!
    that returns a vector of size \verb!n!
    of random integers selected from \verb![a, b)!.
  \item
    Create a function \verb!randvec(n, p, q)!
    that returns a vector of size \verb!n!
    of random values selected from \verb!*p, *(p+1), ..., *(q-1)! (note:
    \verb!*q! is not included).
  \end{enumerate}
\end{ex}

\begin{ex}
  Write a function \verb!merge(u, v)! that accepts two
  sorted vectors and return a sorted vector from the values in
  \verb!u! and \verb!v!.
  Use the obvious algorithm that runs in $O(n)$.
  (Hint: scan both vectors at the same time and choose the smaller
  value from the two to be placed in the new vector.)
\end{ex}

\begin{ex}
  Implement a bubblesort function on a \verb!std::vector! of values
  of the form \verb!(a, b)! where \verb!a! is a student name (of \verb!std::string! type)
  and \verb!b! is a student id (of \verb!int! type).
  Sort in ascending order based on the student id.
  You must use \verb!std::pair!.
\end{ex}

\begin{ex}
  Let \verb!v! be a \verb!std::vector! of points in 2D space, i.e.,
  each value of \verb!v! is of the form \verb!(x, y)! where \verb!x! and
  \verb!y! are \verb!double!s.
  The \verb!std::pair! is used.
  You want to sort \verb!v! based on the distance from \verb!(0, 0)!.
  The distance of \verb!(x, y)! from \verb!(0, 0)! is given by the distance
  formula (or Pythagorus theorem).
  Since you will need to compute the distance of \verb!(x, y)! from the
  origin several times, you have decided to do this:
  you create a new \verb!std::vector!, called \verb!v1!, of \verb!(x, y, d)!
  where \verb!d! is the distance of \verb!(x, y)! from the origin.
  After your bubblesort, you copy the contents of \verb!v1! to \verb!v! (of course omitting the
  \verb!d! value).
  Test your program.
\end{ex}

\begin{ex}
  In the above exercise, for each \verb!std::pair< double > {x, y}! of \verb!v!,
  you create a \verb!std::tuple< tuple > {x, y, d}! in \verb!v1!.
  Now do this: create
  \verb!std::pair< std::pair< double >, double > {{x, y}, d}! for your values in \verb!v1!.
  (Read the above carefully!)
  Redo the above exercise.
\end{ex}

\begin{ex}
  Implement your own \verb!vector! class (see CISS245 assignment) and include
  an \verb!iterator! class
  and
  \verb!const_iterator! class
  inside you
  \verb!vector! class
  and should support dereferencing operator. 
  (See for instance the \verb!IntPointer! class
  example in the CISS245 notes.)
  Your \verb!vector! class should includes a
  \verb!begin()! and an \verb!end()! method.
  \qed
\end{ex}
