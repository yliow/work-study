%-*-latex-*-
\section{Quicksort: Hoare's partition strategy}

Here's the original quicksort partition strategy.
This was invented by Hoare around 1960.
In fact this was the first partition strategy since Hoare was the one
who discovered quicksort.

There's a slight difference between Hoare's version and the
earlier version:
For Hoare's version, the section of array to be sorted
is split into two parts (by the pivot),
but the pivot need not be exactly in the middle.

\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,6,7,3,4,9,2,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}
Suppose we choose this as the pivot value:
\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,6,7,3,4,9,2,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                  ('pivot', 6, -1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

Starting with one smaller than
the lowest index value, i.e. \verb!start - 1!,

\texttt{pivot = 3}
\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,6,7,3,4,9,2,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('i', 2, 1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

we increment an index variable, say \verb!i!,
until \verb!x[i] >= pivot!:

\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,6,7,3,4,9,2,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('i', 4, 1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

Next, starting with one larger than highest index value, i.e.
\verb!end + 1!,

\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,6,7,3,4,9,2,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('i', 4, 1),
                                 ('j', 12, 1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

we decrement an index variable, say \verb!j!,
until \verb!x[j] <= pivot!:

\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,6,7,3,4,9,2,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('i', 4, 1),
                                 ('j', 9, 1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

At this point, we swap \verb!x[i]! and \verb!x[j]!:

\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,2,7,3,4,9,6,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('i', 4, 1),
                                 ('j', 9, 1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

We repeat: we continually incrementing \verb!i!
and then performing the same check on \verb!i! as before
and we continually decrement \verb!j! and perform the same check on
\verb!j!
until we get to this point:

\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,2,7,3,4,9,6,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('i', 5, 1),
                                 ('j', 6, 1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

We swap \verb!x[i]! and \verb!x[j]! again to get

\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,2,3,7,4,9,6,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('i', 5, 1),
                                 ('j', 6, 1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

We repeat the same procedure to get this:

\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[3*[''] + [1,2,3,7,4,9,6,5,8] + 5*['']],
                   celllabels = [('start', 3, -1),
                                 ('j', 5, 1),
                                 ('i', 6, 1),
                                 ('end',   11, -1),
                                ]
)
p.add(s)
print(p)
\end{python}

It's important (in fact \textit{very} important)
to note that you increment \verb!i! before
you check the loop termination condition on \verb!i!.
Likewise, it's important to  note that you decrement \verb!j!
before you check the loop termination condition on \verb!j!.

Note that at this point,
\begin{tightlist}
\li \verb!x[start .. j]! contains values $\leq$ pivot
\li \verb!x[j + 1 .. end]! contains values $\geq$ pivot
\end{tightlist}

Here is Hoare's partitioning strategy:

\begin{Verbatim}[frame=single,fontsize=\footnotesize]
FUNCTION HOARE_PARTITION(x, start, end):

    pivot = select a pivot value in x[start..end]
    i = start - 1
    j = end + 1

    while 1:

         while 1:
             i = i + 1
             if x[i] >= pivot:
                 break

         while 1:
             j = j - 1
             if x[j] <= pivot:
                 break

         if i < j:
             swap x[i], x[j]
         else:
             break

    return j
\end{Verbatim}

\begin{Verbatim}[frame=single,fontsize=\footnotesize]
FUNCTION quicksort(x, start, end):

    if start < end:
        j = HOARE_PARTITION(x, start, end)
        quicksort(x, start, j)
        quicksort(x, j + 1, end)
\end{Verbatim}

Of course for the first call to quicksort, start is 0 and end is
$n - 1$ where $n$ is the size of the array x.

The general idea is that on applying Hoare partition on
\verb!x[start .. end]!, you will get an index value returned, \verb!j!,
such that
\verb!x[start .. j]! has values $\leq$ the pivot
and
\verb!x[j + 1 .. end]! has values $\geq$ the pivot.
The pivot need not be at index \verb!j!.

There's an important warning:
If the pivot you pick
is the largest and unique value and the pivot is
at the rightmost index,
you will get into an infinite loop.
For instance consider this:
\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[[1,2,3,4]],
                   celllabels = [('start', 0, -1),
                                 ('end',   3, -1),
                                ]
)
p.add(s)
print(p)
\end{python}
where we choose \verb!4! to be the pivot.
Then for this execution of Hoare partition we have this:
\begin{python}
from quicksort_init import *
p = Plot()
from quicksort_init import *
s = chunkedarray(cellwidth=0.8, 
                   cellheight=0.8,
                   arr=[[1,2,3,4]],
                   celllabels = [('start', 0, -1),
                                 ('i,j', 3, 1),
                                 ('end',   3, -1),
                                ]
                                
)
p.add(s)
print(p)
\end{python}
which will result in a return with value of \verb!j = 3!.
Unfortunately, back in quicksort, this will result in
calling quicksort \verb!start = 0! and \verb!end = 3! again.
The case where \verb!i = j = end! is called the trivial split case of
Hoare partition.
(What happens if the pivot is the unique largest value in the array
that is in the middle of the array instead of at the beginning?)

Therefore in your pivot selection:
do not pick a pivot value that is the largest and and unique value
of the array and is at the rightmost index.

Here's another way to do that Hoare's partition:
\begin{Verbatim}[frame=single,fontsize=\footnotesize]
FUNCTION HOARE_PARTITION(x, start, end):

    pivot = select a pivot value in x[start..end]
    i = start
    j = end

    while 1:

         while 1:
             if x[i] >= pivot:
                 break
             i = i + 1

         while 1:
             if x[j] <= pivot:
                 break
             j = j - 1

         if i < j:
             swap x[i], x[j]
             i = i + 1
             j = j - 1
         else:
             break

    return j
\end{Verbatim}



\newpage
\begin{ex}
Perform Hoare partition on
\verb![5,3,2,6,4,1,3,7]! with pivot value of \verb!5!.
What is the index value returned (i.e., the last value of \verb!j!)?
Is the index value returned always the index value of the pivot?
On return is the value of \verb!i! always the same as \verb!j!?
If the pivot at index \verb!j!?
\end{ex}

[ANSWER: 3,3,2,1,4,6,5,7. Return index value is \verb!j = 4!.
The value of \verb!i! is 5.
Note that the pivot \verb!5! ends up at index 6.]

\newpage
\begin{ex}
Perform Hoare partition on \verb![5,3,2,6,4,1,3,7]! with pivot value of
\verb!5!.
What is the last value of \verb!i! and \verb!j!?
If Hoare partition (and hence quicksort) staple?
\end{ex}

[ANSWER: 3,3,2,1,5,6,5,7. The last value of \verb!i! and \verb!j!
are the same: 4.
The partition is not staple: the two 5's switched their
relative place.] 
  

\newpage
\begin{ex}
Perform quicksort (using Hoare partition) on
\verb![1,1,1,1]!.
What happens when you do the same for an array of size $n$ of same values?
What is the runtime?
\end{ex}


\newpage
\begin{ex}
Perform quicksort (using Hoare partition) on
\verb![1,2,3,4]! (which is already sorted)
where you always choose the smallest value to be the
pivot.
What about the general case of \verb![1,2,3,...,n]!?
What is the runtime?
\end{ex}

\newpage
\begin{ex}
Give yourself a random array and 
perform a complete quicksort (using Hoare partition).on the array.
Next, for each partitioning, compare the values of
\verb!i! and \verb!j!.
Repeat the above a couple of time.
Conjecture a relationship between \verb!i! and \verb!j!.
\end{ex}

[ANSWER: Either \verb!i = j! or \verb!i = j + 1!.]


\newpage
\begin{ex}
Recall that if we choose 4 for the pivot when performing
quicksort (using Hoare partition) on
\verb![1,2,3,4]!, we run into a problem.
What about the following:
Perform Hoare partition on \verb![4,1,2,3]! where you choose
\verb!4! for the pivot.
What is the index value returned?
Will you run into an infinite loop when you perform the full
quicksort on the above array using Hoare partition?
\end{ex}

\newpage
\begin{ex}
Recall that if we choose \verb!4! for the pivot when performing
quicksort (using Hoare partition) on
\verb![!1,2,3,4]!, we run into a problem.
What about the following:
Perform Hoare partition on \verb![4,1,2,4]! where you choose
\verb!4! for the pivot.
What is the index value returned?
Will you run into an infinite loop when you perform the full
quicksort on the above array using Hoare partition?
\end{ex}
  

\newpage
\begin{ex}
What will go wrong if you use this partitioning strategy
instead (make sure you see that it's different from Hoare's partition):
\begin{Verbatim}[frame=single,fontsize=\footnotesize]
FUNCTION HOARE_PARTITION(x, start, end):

    pivot = select a pivot value in x[start..end]
    i = start
    j = end

    while 1:

         while 1:
             if x[i] >= pivot:
                 break
             i = i + 1


         while 1:
             if x[j] <= pivot:
                 break
             j = j + 1

         if i < j:
             swap x[i], x[j]
         else:                    
             break

    return j
\end{Verbatim}
\end{ex}

[ANSWER: The point: in Hoare's partition, the
\verb!i! increments before the check and the
\verb!j! decrements before the check.
In the above, the check on \verb!i! is before the check
and the decrement on \verb!j! is before the check.
If the \verb!i! and \verb!j! both points to a pivot,
\verb!i! and \verb!j! will stop moving -- you get an infinite loop.]
