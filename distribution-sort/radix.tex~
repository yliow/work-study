\section{Radix sort}

There are two basic variants of radix sort.
First I'll talk about the LSD (least significant digit) radix sort.

\subsection{LSD radix sort}

Suppose you have the following array (I'm going to draw it vertically):
\begin{python}
from latextool_basic import *
p = Plot()

def arr(x=0, y=0, xs=[]):
    xs = [[_] for _ in xs]
    return Array2d(x, y, xs, width=0.7, height=0.7)

def string(x=0, y=0, label=''):
    label = r'\text{\texttt{%s}}' % label
    return Rect2(x, y, x, y, label=label, linewidth=0)

a = arr(xs=[31,22,'02',25,34,41,'09'])
p += a
x, y = a[0][0].left()
p += string(x-0.3, y, 'x')
print p
\end{python}
First we sort the array \textit{by the ones digit} using a 
\textit{stable} sorting algorithm.
\begin{python}
from latextool_basic import *
p = Plot()

def arr(x=0, y=0, xs=[]):
    xs = [[_] for _ in xs]
    return Array2d(x, y, xs, width=0.7, height=0.7)

def string(x=0, y=0, label=''):
    label = r'\text{\texttt{%s}}' % label
    return Rect2(x, y, x, y, label=label, linewidth=0)

def bubble(xs, f):
    n = len(xs)
    #print "xs:", xs
    for i in range(n - 2, -1, -1):
        for j in range(0, i + 1):
            if f(xs[j]) > f(xs[j + 1]):
                xs[j], xs[j + 1] = xs[j + 1], xs[j]
        #print "xs:", xs

a = ['31','22','02','25','34','41','09']
a = [(_[-1],_) for _ in a]
bubble(a, lambda x:x[0])
a = [_ for __,_ in a] 
a = arr(xs=a)
p += a
x, y = a[0][0].left()
p += string(x-0.3, y, 'x')
print p
\end{python}
In the above, I used bubblesort (again sorting based on the ones digit).
Note for instance that \verb!22! appear before \verb!02!.
Now I'm going to perform a stable sort on the tens digit:
\begin{python}
from latextool_basic import *
p = Plot()

def arr(x=0, y=0, xs=[]):
    xs = [[_] for _ in xs]
    return Array2d(x, y, xs, width=0.7, height=0.7)

def string(x=0, y=0, label=''):
    label = r'\text{\texttt{%s}}' % label
    return Rect2(x, y, x, y, label=label, linewidth=0)

def bubble(xs, f):
    n = len(xs)
    #print "xs:", xs
    for i in range(n - 2, -1, -1):
        for j in range(0, i + 1):
            if f(xs[j]) > f(xs[j + 1]):
                xs[j], xs[j + 1] = xs[j + 1], xs[j]
        #print "xs:", xs

a = ['31','22','02','25','34','41','09']
a = [(_[-1],_) for _ in a]
bubble(a, lambda x:x[0])
bubble(a, lambda x:x[1])
a = [_ for __,_ in a] 
a = arr(xs=a)
p += a
x, y = a[0][0].left()
p += string(x-0.3, y, 'x')
print p
\end{python}
In the second pass, 
I used bubblesort, sorting on the tens digit.

Note for each pass of the radix sort, you can use any stable sort.
You want to pick the fastest (of course).

In the example above, since each pass is sorting digits, 
there are only 10 possible values.
we can use for instance 10 queues, one for each digit.
This ensures that the sorting process is stable:
a number that has joined a queue will always be ahead of another
that joined the queue later.
After each pass, the values of a queues are dequeued and put back 
into the original array, of course starting with 
the queue corresonding to \verb!0!.
Note that enqueue and dequeue takes constant time.
Therefore each pass of radix sort runs at $O(n)$.
If there are $d$ digits for each number, and therefore we need to 
run $d$ passes, then the runtime is
\[
O(nd)
\]
Of course if you're sorting only numbers, $d$ would be a constant.
In that case, the runtime is $O(n)$.
For space, the total amount of memory used by the queues of course
adds up to 
$O(n)$.

This is better than, for instance, if I were to use bubblesort.
Why? Because bubblesort runs at $O(n^2)$ and therefore with $d$ passes,
the runtime would be $O(dn^2)$.

Note that when we use queues for distribution, a value
enters the queue without begin compared when other values.
Therefore in this context (i.e. if you use queues or some kind of 
\lq\lq buckets''), radix sort is a distribution (non-comparison) sorting
algorithm.


\begin{ex}
What happens when you sort not by single digit for each pass, but
\textit{two} digits?
\qed
\end{ex}


\subsection{MSD radix sort}

If you
sort numbers using MSD radix sort you might see something like
$1, 19, 2, 3, 45, 9, 91$.
For numbers with different lengths, you can
pad on the right with a fake data that is infinitely large.

Suppose you have an array of string
\verb!"apple"!,
\verb!"abe"!,
\verb!"cat"!,
\verb!"ab"!,
\verb!"bee"!,
\verb!"cap"!.
Using MSD radix sort, you would get
\verb!"ab"!,
\verb!"abe"!,
\verb!"apple"!,
\verb!"bee"!,
\verb!"cap"!.
\verb!"cat"!
where the order of rach character is determined by its ASCII code.

The above ordering is called dictionary order.


