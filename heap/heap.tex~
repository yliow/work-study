\section{Heaps}

Look at this tree:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E   G
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{7}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
G=r'label=\texttt{0}',
) 
\end{python}

No is not a BST.
But the numbers are not totally random: each node has value $\geq$ all
the children.
This is called a \defterm{max heap}.

Not too surprising, this is called \defterm{min heap}:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D   E G
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,C-E,C-G',
A=r'label=\texttt{5}',
B=r'label=\texttt{8}',
C=r'label=\texttt{10}',
D=r'label=\texttt{12}',
E=r'label=\texttt{13}',
G=r'label=\texttt{15}',
) 
\end{python}

Each node has value $\leq$ all children.

Note that I have only defined max and min heaps for \textit{binary} 
trees.

More generally you can define heaps with respect to an ordering relation.
In the above the ordering is $\geq$ (for max heap) and $\leq$ (for min heap).


Although most of what we'll talk about regarding heaps works
for all binary max/min heaps, we are usually only interested in
complete heaps, i.e., all the levels are full except possibly for the last.
This will ensure that the height is $O(\log n)$.
Furthermore, the places where the level is not filled (if any)
is \lq\lq on the
right''.
For instance instead of a max heap like this:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E   G
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{7}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
G=r'label=\texttt{0}',
) 
\end{python}

we will usually consider this instead:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E G
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{7}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
G=r'label=\texttt{0}',
) 
\end{python}

This will ensure that when this heap is implemented
inside an array, the values occupied are contiguous.

\begin{python}
from latextool_basic import *
p = Plot()
p += Array2d(0, 0, width=0.6, height=0.6, 
             xs=[['10','5','7','2','1','0','','','','']])
print p
\end{python}

(Cells which are not relevant are left blank.
Of course there are integer values there -- but we don't care about them.)
Furthermore, this array would usually come with a
\texttt{len} variable (in the above example \texttt{len} would have value
\texttt{6}) which would tell me the index position of the first available
cell in the array

\begin{python}
from latextool_basic import *
p = Plot()
p += Array2d(0, 0, width=0.6, height=0.6, 
             xs=[['10','5','7','2','1','0','?','','','']])
print p
\end{python}

which would correspond nicely with the
next available node in the tree to keep the tree in the \lq\lq heap shape'',
i.e., complete and unfilled nodes on a level (if any) on the right:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E G H
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-H',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{7}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
G=r'label=\texttt{0}',
H=r'label=\texttt{?}',
) 
\end{python}

From now on, I will assume that a max (or min) heap look like that,
i.e., is complete where the unfilled slots (if any)
are all on the same level
and all \lq\lq on the right''.

\newpage
\begin{ex}
How many max heaps can you draw if the heap contains
the values 1, 2, 3, 4?
\qed
\end{ex}


\newpage
\begin{ex}
Suppose you have this array:
\[
5, 4, 3, 2, 1
\]
(index 0 is on the left).
Assume that this array represents a binary tree.
\begin{tightlist}
  \item Is this binary tree a max heap?
  \item How many arrays with the above values represent a max heap?
\end{tightlist}
\qed
\end{ex}

\newpage
\begin{ex}
  Look at this complete binary tree again:

  \begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E G
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{7}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
G=r'label=\texttt{0}',
) 
\end{python}

Suppose the size is $n$ (in the example $n = 6$).
Locate all the leaves.
Is there a formula for the number of leaves in terms of $n$?
(Try more examples.)
What is the index $i$ such that $i, i + 1, \cdots, n - 1$
are the indices of all the leaves in the array implementation of the
above complete tree?
\qed
\end{ex}

\newpage
\subsection{Insert}

Look at this max heap again:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E G
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{7}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
G=r'label=\texttt{0}',
) 
\end{python}

Suppose I want to insert a \verb!3! into the above tree.
To maintain the shape of a heap, I have to do it here:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E G F
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{7}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
F=r'label=\texttt{3}',
G=r'label=\texttt{0}',
) 
\end{python}

(Don't forget that heaps are implemented with arrays
and therefore I can find the available slots in the array
right away with the length variable of the array.)
In this case the tree becomes perfect.
It's also a max heap.

But what if I want to add \verb!8! into the tree instead?
I can again put it at the same spot:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E G F
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{7}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
F=r'label=\texttt{8}',
G=r'label=\texttt{0}',
) 
\end{python}

Of course this is not a max heap any more.
But I can follow the path back to the root (i.e., follow the 
parent pointer) and swap the values of two relevant nodes
(while keeping the tree structure intact, i.e., that it's still a max heap):

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
 B   C
D E F G
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{8}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
) 
\end{python}

Now it's a max heap again.
In terms of the array implementation of the above heap, basically
this:

\begin{python}
from latextool_basic import *
p = Plot()
p += Array2d(0, 0, width=0.6, height=0.6, 
             xs=[['10','5','7','2','1','0','8','','','']])
print p
\end{python}

becomes this:

\begin{python}
from latextool_basic import *
p = Plot()
p += Array2d(0, 0, width=0.6, height=0.6, 
             xs=[['10','5','8','2','1','0','7','','','']])
print p
\end{python}

(Don't forget that technically speaking, there should also be a
length variable.)

Suppose I do this again: I add a \verb!9!.
It must go here:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C
 D E G F
H
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{8}',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
F=r'label=\texttt{7}',
G=r'label=\texttt{0}',
H=r'label=\texttt{9}',
) 
\end{python}

(Draw the array implementation for the above.)
I swap to get this:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C
 D E G F
H
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{7}',
G=r'label=\texttt{0}',
H=r'label=\texttt{2}',
) 
\end{python}

and then swap again:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H',
A=r'label=\texttt{10}',
B=r'label=\texttt{9}',
C=r'label=\texttt{8}',
D=r'label=\texttt{5}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
) 
\end{python}

(Draw the arrays for the above so that you see how the array changes.)

This works even when you swap all the way to the root.
Say I add a \verb!20!.
It must go here:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{10}',
B=r'label=\texttt{9}',
C=r'label=\texttt{8}',
D=r'label=\texttt{5}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{20}',
) 
\end{python}

After 3 swaps I get:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{20}',
B=r'label=\texttt{10}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{5}',
) 
\end{python}

and I get a max heap again.


\begin{ex}
Draw the max heap after each
of the above swaps and draw the corresponding array.
\qed
\end{ex}
  
Now if you think about it,
if you have the following
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
     C
    F G
   H I
""",
minimum_size='8mm',
edges='A-C,C-G,C-F,F-H,F-I',
A=r'shape=None,label=\texttt{}',
B=r'label=\texttt{5}',
C=r'label=$\alpha$',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
F=r'label=$\beta$',
G=r'shape=tree,label=$T_3$',
H=r'shape=tree,label=$T_1$',
I=r'shape=tree,label=$T_2$',
) 
\end{python}

where 
\begin{tightlist}
\li the subtree at $\beta$ is a max heap,
\li the subtree at $\alpha$ is also a max heap if we ignore the 
its left subtree, 
\li and $\beta > \alpha$, 
\end{tightlist}
then
on swapping $\alpha$ and $\beta$:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
   A 
     C
    F G
   H I
""",
minimum_size='8mm',
edges='A-C,C-G,C-F,F-H,F-I',
A=r'shape=None,label=\texttt{}',
B=r'label=\texttt{5}',
C=r'label=$\beta$',
D=r'label=\texttt{2}',
E=r'label=\texttt{1}',
F=r'label=$\alpha$',
G=r'shape=tree,label=$T_3$',
H=r'shape=tree,label=$T_1$',
I=r'shape=tree,label=$T_2$',
) 
\end{python}

we have a max heap at $\beta$.
This process is called \defterm{bubble-up} or \defterm{heapify-up}.

\begin{console}[commandchars=\\\{\}]
ALGORITHM: heap_insert (for max heap)
INPUT: x - an array representing a heap
       len - length of heap, number of value in the heap
       key - value to be inserted

Insert node with key as a leaf in the right place, i.e.,
x[len] = key
len = len + 1 (note that now the key is at index len - 1)

i = len - 1
while i is not 0 and value at i > value at parent(i):
    swap value at i and value at parent(i)
    i = parent(i)
\end{console}

Here \texttt{parent(i)} gives the index of the
parent of the value at index \texttt{i}.
The corresponding algorithm for min heap is similar.
Recall that part that \lq\lq bubbles up'' the new key value is
called \defterm{heapify-up} (this is for max heap).

\begin{console}
ALGORITHM: heapify_up (for max heap)
INPUT: x - an array representing a heap
       len - length of heap in x
       i - index where heapify up begins

while i is not 0 and value at i > value at parent(i):
    swap value at i and value at parent(i)
    i = parent(i)
\end{console}

So if you like, the heap insert pseodocode looks like this
(if the heapify-up algorithm is available):

\begin{console}
ALGORITHM: heap_insert (for max heap)
INPUT: x - an array that represents a heap
       len - length of heap in x (pass by reference)
       key - key to be inserted into x

Insert node with key as a leaf in the right place, i.e.,
x[len] = key
len = len + 1 (note that now the key is at index len - 1)

heapify_up x starting at index len - 1
\end{console}


Note that the runtime is
\[
O(\log n)
\]
Why?
Because the heapify-up basically \lq\lq bubble up''
the inserted key value from the point of insert (at leaf level)
up to the root,
possibly stopping before reaching the root.
But in the worse case, this means that
worse runtime depends on the height which is $O(\log n)$
since the tree is complete.



%One really important thing to note is this:
%this works no matter where you put the new node with the new value:
%any leaf position will work.


\newpage
\begin{ex}
  Starting with this max heap:
  
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{20}',
B=r'label=\texttt{10}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{5}',
) 
\end{python}

Do the following assuming that the array implementation
of the above heap is an array of size 20.
\begin{tightlist}
\item Draw the array implementation of the above max heap.
\item Insert \texttt{5}. Draw the max heap after the insert
and after each necessary swap (technically, until all the swaps are done
the tree is not a max heap). Draw the array implementation
after each swap.
\item Do the same with \texttt{15}.
\item Do the same with \texttt{11}.
\item Do the same with \texttt{22}.
\end{tightlist}
\qed
\end{ex}


\newpage
\begin{ex}
Starting with an empty \textit{min} heap.
Do the following, drawing the heap and the array implementation.
\begin{tightlist}
  \item Insert \texttt{10}.
  \item Insert \texttt{15}.
  \item Insert \texttt{5}.
  \item Insert \texttt{2}.
  \item Insert \texttt{8}.
  \item Insert \texttt{0}.
  \item Insert \texttt{5}.
\end{tightlist}
(First, you want to study the operations for max heap very carefully.
Then, you translate the operations to the case of min heap.)
\qed
\end{ex}




\newpage
\subsection{Delete}

Suppose now I want to delete
  \texttt{8}
  from this max heap:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{20}',
B=r'label=\texttt{10}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{5}',
) 
\end{python}

I remove the node that is rightmost node of the last level --
this corresponds to the last value in the array implementation.
In the above case, that's the value \texttt{5}.
I then overwrite \texttt{8} with \texttt{5}.
I get this:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H 
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H',
A=r'label=\texttt{20}',
B=r'label=\texttt{10}',
C=r'label=\texttt{5}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
) 
\end{python}

Now this is not a max heap.
I look at the children of \texttt{5}: \texttt{0} and \texttt{7}.
Swap \texttt{5} with the max which is \texttt{7},
I get this:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H 
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H',
A=r'label=\texttt{20}',
B=r'label=\texttt{10}',
C=r'label=\texttt{7}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{5}',
H=r'label=\texttt{2}',
) 
\end{python}

Clearly, we keep pushing \texttt{5} down as much as possible until
we get a max heap again.
It might take more than one swap.

This above method works as long as \texttt{5} is a descendent of the
value to be removed.
Usually the value to be delete is in fact the root of the heap.
When the root is to be deleted, then the operation is called
\defterm{extract max} for the case of max heap
(and \defterm{extract min} for the case of
min heap.)

Let's do another example.
Let's delete \texttt{20} (the root) from this max heap:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{20}',
B=r'label=\texttt{10}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{5}',
) 
\end{python}

Again, I overwrite \texttt{20} with \texttt{5}
(\texttt{5} is chosen, again because it's the rightmost
in the last level, or equivalently, it's the last in the
corresponding array implementation.)
I get this:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H 
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H',
A=r'label=\texttt{5}',
B=r'label=\texttt{10}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
) 
\end{python}

I do the same again as above: I pick the larger of the children
of \texttt{5}, which in this case is \texttt{10} and swap with \texttt{5}.
I get this:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H 
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H',
A=r'label=\texttt{10}',
B=r'label=\texttt{5}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
) 
\end{python}

It's not a max heap yet.
I look at the children of \texttt{5} and choose the largest,
which would be \texttt{9}, and swap it with \texttt{5}.
Here's what I get:


\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H',
A=r'label=\texttt{10}',
B=r'label=\texttt{9}',
C=r'label=\texttt{8}',
D=r'label=\texttt{5}',
E=r'label=\texttt{1}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
) 
\end{python}

Ahhh ... at this point I have a max heap -- I'm done!

The part of the algorithm where you perform swaps to move the
\texttt{5} down is called \defterm{heapify--down} or \defterm{bubble--down}.

\begin{console}[commandchars=\\\{\}]
ALGORITHM: heap_delete (for max heap)
INPUT: x - an array representing a max heap
       len - the length of the heap in x
       i - index of value to be removed (note usually
           this is 0, so we let 0 be the default value)

Replace value at index i with the last value, i.e., the
rightmost value of the last level:
x[i] = x[len - 1]
len = len - 1

while 1:
    l = left(i), index of left child of value at index i
    r = right(i), index of right child of value at index i
    swap_index = -1
    if l < len and r < len: # 2 children
        if value at index l >= value at index r:
            swap_index = l
        else:
            swap_index = r
    else if l < len and r >= len: # 1 child (left child)
        swap_index = l

    if swap_index is -1 or
        value at swap_index < value at i:
        break
    else:
        swap values at index i and at index swap_index
        i = swap_index
\end{console}

(Note that because of the shape of the tree -- a complete tree --
a node cannot have a right child but no left child.)

Recall what I just said: usually the delete operation for max heap
occurs at index 0, i.e., you're removing the maximum value in the max heap.
In that case the operation is also called extract-max or delete-max.
You'll see why when we use this delete operation to perform heapsort
and when we use this for priority queues.

Note that the runtime is
\[
O(\log n)
\]
since the heapify-down operation basically moves
a value in the tree down to the leaf level, possibly stopping
early.
This means that the worse runtime must be
the height of the tree which is $O(\log n)$.

And as mentioned above, the process of moving a value down
by continually swap a value with the larger of the children
whenever the larger of the children is greater than the value
is called \defterm{heapify-down}.

\begin{console}
ALGORITHM: heapify_down (for max heap)
INPUT: heap (as array with length variable len)
       i - index where heapify begins

while
    l = left(i), index of left child of value at index i
    r = right(i), index of right child of value at index i
    swap_index = -1
    if l < len and r < len: # 2 children
        if value at index l >= value at index r:
            swap_index = l
        else if value at index l < value at index r:
            swap_index = r
    else if l < len and r >= len: # 1 child (left child)
        swap_index = l

    if swap_index is not -1 and
       value at swap_index > value at i:
        swap values at index i and at index swap_index
        i = swap_index
    else:
        break
\end{console}

\newpage
\begin{ex}
You are given this max heap:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
        A 
    B       C 
  D   E   F   G
 H I J K L M N O
P
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I,E-J,E-K,F-L,F-M,G-N,G-O,H-P',
A=r'label=\texttt{34}',
B=r'label=\texttt{28}',
C=r'label=\texttt{16}',
D=r'label=\texttt{23}',
E=r'label=\texttt{25}',
F=r'label=\texttt{13}',
G=r'label=\texttt{7}',
H=r'label=\texttt{10}',
I=r'label=\texttt{8}',
J=r'label=\texttt{24}',
K=r'label=\texttt{14}',
L=r'label=\texttt{3}',
M=r'label=\texttt{9}',
N=r'label=\texttt{5}',
O=r'label=\texttt{4}',
P=r'label=\texttt{9}',
) 
\end{python}

Do the following one after another.
Drawing the tree including the swaps and the final
max heap. Also, draw the corresponding array.
\begin{tightlist}
  \item Delete \texttt{28}.
  \item Delete \texttt{34}
  \item Delete \texttt{16}
  \item Delete the maximum value in the max heap, i.e., perform extract max.
  \item Delete the maximum value in the max heap, i.e., perform extract max.
\end{tightlist}
\end{ex}

\newpage
\begin{ex}
  Draw a min heap with 15 distinct values.
  Extract the minimum and draw the min heap.
  Do it again.
  \qed
\end{ex}
  
\begin{comment}
\subsection{Heap and complete trees}

Recall that we have complete freedom in choosing where to insert a new node.
We also have complete freedom in choosing any leaf to use to overwrite
a node to be deleted as long as the leaf is a descendent of the node whose
value is to delete.
In particular, if we are remove the value of the root of the heap,
we can choose any leaf.

It's because of the above,
after every insert and root value removal,
we can alway ensure that the heap is complete.
Recall that a complete binary tree that is almost full except that the
last level might not have all the leaves.
are at the same level.
Furthermore, we can force to have
all the leaves to be all on the left side of the whole
tree.
This is what I mean by \lq\lq left side'' of the tree:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
      A 
   B     C
 D   E F   G
H I J
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I,E-J',
A=r'label=',
B=r'label=',
C=r'label=',
D=r'label=',
E=r'label=',
F=r'label=',
G=r'label=',
H=r'label=',
I=r'label=',
J=r'label=',
) 
\end{python}

This can be achieved by
\begin{tightlist}
\li During insert, always insert a leaf just to the right of the
rightmost leaf at the last level.
\li During delete, always using the right most leaf of the 
last level whenever we remove the root.
\end{tightlist}
\end{comment}




\newpage
\begin{ex}
Build a max heap by inserting the following into an empty tree:
1, 3, 5, 7, 6, 4, 2, 8, 9, 0.
Make sure the tree is complete after each insert and the leaves
at the lowest level are all on the left.
\qed
\end{ex}

\newpage
\begin{ex}
Using the max heap from the previous question,
remove the following values one after another:
1, 3, 5, 7, 6, 4, 2, 8, 9, 0.
Make sure that after each delete, the tree is complete after each insert and the leaves
at the lowest level are all on the left.
\qed
\end{ex}

\newpage
\begin{ex}
  Suppose that in max heap, there are two 5's.
  One 5 was inserted at 9AM and the second 5 was inserted
  at 10AM.
  Will the 5 inserted at 9AM be deleted from the heap
  before the 5 inserted at 10AM?
\end{ex}

\newpage
Being complete means that the heaps can have the minimal possible height.
At this point, you ought to know that this is a good thing.

This also implies right away that the worse runtimes for 
insert and delete is $O(\log n)$ for both insert and delete
as long as we keep the heap complete.



\newpage
\subsection{Heaps using array trees}

The thing about heaps being \lq\lq complete with last level leaves on the
left'' is very important when we want to implement the heap using an array.
Review the notes on array trees if you need to.

Make sure you see that in the mapping of the binary tree to an array,
we are filling the array one level of the time at a time going 
left-to-right.



\newpage
\begin{ex}
Using an array, 
build a max heap by inserting the following into an empty tree:
1, 3, 5, 7, 6, 4, 2, 0, 8, 9.
Make sure the tree is complete after each insert and the leaves
at the lowest level are all on the left.
Call the array \texttt{x}
(assume it has size at least 10)
and use integer variable \texttt{len}
for the length of \texttt{x}.
Of course initially \texttt{len} is 0.
\qed
\end{ex}

\newpage
\begin{ex}
Using the max heap (using an array) from the previous question,
remove the following values one after another left to right:
\[
1, 3, 5, 7, 6, 4, 2, 0, 8, 9
\]
Call the array \texttt{x} and use integer variable \texttt{len}
for the length of \texttt{x}.
Of course initially \texttt{len} is 10.
Make sure that after each delete, the tree is complete after each delete and 
the leaves
at the lowest level are all on the left.
\qed
\end{ex}



\newpage
\section{Heapsort}

\textsc{Building a max heap -- slow method.}
We can use the heaps to sort arrays.
For instance suppose you have an array \verb!x! of 10 values.
Looking just at the first value, \verb!x[0]!, you have a heap of one
value.
Now insert \verb!x[1]! into the heap with only \verb!x[0]!.
At this point \verb!x[0..1]! is a heap -- say we want to sort it in 
ascending order, which means that we're using max heap (you see why later).
Now we repeat to get \verb!x[0..2]! to be a max heap.
Etc.
When we're done, we have a max heap of \verb!x[0..9]!.
Inserting into a heap requires $\log_2 n$ steps where $n$ is the
size of the heap.
Therefore the 
runtime to create the heap 
from an array of $n$ values is, informally speaking, 
$\log_2 1 + \log_2 2 + \cdots + \log_2 n$
which is $\log_2 n! \leq \log_2 n^n = n \log_2 n$.
There's a faster algorithm usually called build max heap -- see below.

\textsc{Heapsort given a max heap.}
Now we delete the root from the heap.
Because this is a max heap, the root, is the 
maximum value of \verb!x[0..9]!.
We swap \verb!x[0]! and \verb!x[9]!
and re-heapify to get a heap \verb!x[0..8]!.
In other words we're essentially doing a delete of the value at \verb!x[0]!
(the extract max operation), putting this value at \texttt{x[9]}.

We repeat the above to get a heap \verb!x[0..7]!.
At this point the largest value of the array is at \verb!x[9]!
and the second largest is at \verb!x[8]!.

We repeat until the heap has only one value, i.e., the heap is \verb!x[0]!.
The whole array must be sorted in ascending order.

The runtime is, informally, $\log_2 n + \log_2 (n - 1) + \cdots$
which is $\log_2 n! \leq \log_2 n^n = n \log_2 n$.

So the total time for the above process,
creating the heap and then removing roots from the 
heap is roughly $2 n \log_2 n$ and therefore
the runtime for heapsort is $O(n \log_2 n)$.

Note that the heapsort has a worse runtime of $n \log_2 n$
whereas quicksort can have a worse runtime of $n^2$
although
on the average quicksort is $O(n \log n)$ and 
typically quicksort is faster than heapsort by a constant
factor.
Although mergesort does achieve $n \log_2 n$ for worse runtime,
remember that mergesort needs $O(n)$ space.
However heapsort is not stable whereas mergesort is stable.

\begin{ex}
  Give an example showing that heapsort is not
  stable.
\end{ex}
  
\textsc{Building a max heap -- fast and right method.}
As mentioned at the beginning of this section,
you can create the max heap by continually inserting values into the
the max heap.
The runtime is $O(n \log n)$.
Instead of doing that you can
also execute heapify-down on all the non-leaves positions
of the given array is a systematic way: from the non-leaf at the
lowest level to the root, more or less the opposite of the
breadth-first traversal (ignoring the leaves).
This method of building a max heap is called
\defterm{build-max-heap} (duh)
and is also called \defterm{heapify}.

Note that if the size of the array is $n$,
then the indices of the leaves are
$n/2$ (integer division), $n/2 + 1$, $n - 1$.
Therefore you can convert the array to a max heap
if you perform heapify-down at indices
$n/2, n/2-1, n/2-2,...,0$, you will get a max heap too.

The runtime of build-max-heap is
\[
O(n)
\]
which is faster than the process above
of inserting one node at a time into the max heap.
However this does not improve the overall heapsort
since the second part of the heapsort process will still run
in $O(n \log n)$.

\begin{console}
ALGORITHM: build_max_heap (or heapify)
INPUT: x - array containing n values x[0..n-1] that will
           represent a max heap at the end of this
           algorithm.
       n - length of x

Perform heapify bottom-up from the first nonleaf to the
root, i.e.,

for i = n/2, n/2 - 1, n/2 - 2, ..., 0:
    perform heapify-down on x at i
\end{console}

As mentioned at the beginning of this section, the runtime of
this build-max-heap has runtime
\[
O(n)
\]

Let me show you how to 
build a max heap given an array.
Let's say we're given this array:
\[
1, 0, 9, 8, 3, 2, 4, 7, 6
\]
Here's the array drawn as a complete tree:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{1}',
B=r'label=\texttt{0}',
C=r'label=\texttt{9}',
D=r'label=\texttt{8}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{4}',
H=r'label=\texttt{7}',
I=r'label=\texttt{6}',
) 
\end{python}

Ignoring all leaves, we heapify in this order: 8,9,0,1.
We ignore the leaves because the main idea of build-max-heap
is to continually make subheaps.
Each leaf is already a leaf.

Heapify-down at \texttt{8}: No change since the
subtree at \texttt{8} is a max heap.
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{1}',
B=r'label=\texttt{0}',
C=r'label=\texttt{9}',
D=r'label=\texttt{8}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{4}',
H=r'label=\texttt{7}',
I=r'label=\texttt{6}',
) 
\end{python}

Heapify-down at \texttt{9}:
No change since the subtree at \texttt{9} is a max heap.
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{1}',
B=r'label=\texttt{0}',
C=r'label=\texttt{9}',
D=r'label=\texttt{8}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{4}',
H=r'label=\texttt{7}',
I=r'label=\texttt{6}',
) 
\end{python}

Heapify-down at \texttt{0}:
I need 2 swaps.
After that the subtree at position where \texttt{0} originally 
was a max heap.
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{1}',
B=r'label=\texttt{8}',
C=r'label=\texttt{9}',
D=r'label=\texttt{7}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{4}',
H=r'label=\texttt{0}',
I=r'label=\texttt{6}',
) 
\end{python}

Heapify-down at \texttt{1}:
I need 2 swaps.
After that the subtree at the place
where \texttt{1} was is a max heap.
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{9}',
B=r'label=\texttt{8}',
C=r'label=\texttt{4}',
D=r'label=\texttt{7}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{1}',
H=r'label=\texttt{0}',
I=r'label=\texttt{6}',
) 
\end{python}
I'm done!

Hence I get this array (which represents the above max heap):
\[
9,8,4,7,3,2,1,0,6
\]


\newpage
\begin{ex}
Draw the corresponding array at the end of each stage
for the above computation
\qed
\end{ex}


\newpage
\begin{ex}
Perform build-max-heap on the following array:
\[
5,3,0,7,1,2,6,9,4,8
\]
showing every step (like in the above example).
\qed
\end{ex}


\newpage
\begin{ex}
Perform build-max-heap on the following array:
\[
2,1,5,0,3,7,9,6,4,8
\]
showing every step (like in the above example).
\qed
\end{ex}


\newpage
\begin{ex}
Perform build-max-heap on the following array:
\[
0,1,2,3,4,5,6,7,8,9
\]
showing every step (like in the above example).
\qed
\end{ex}


  

\newpage
Here again is the max heap I constructed using build-max-heap (or heapify):

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{9}',
B=r'label=\texttt{8}',
C=r'label=\texttt{4}',
D=r'label=\texttt{7}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{1}',
H=r'label=\texttt{0}',
I=r'label=\texttt{6}',
) 
\end{python}

Let's perform heapsort on this max heap.
Recall that extract-max will throw away the root by replacing
the value at the root with the last value in the tree (i.e.,
the rightmost value at the last level of the tree).
Instead of replacing the root with the last value,
I will swap the root value and last value.
Otherwise it's the same extract-max operation.
Let's do it.
First I swap the root value and the last value:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{6}',
B=r'label=\texttt{8}',
C=r'label=\texttt{4}',
D=r'label=\texttt{7}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{1}',
H=r'label=\texttt{0}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
(I underlined the \texttt{\underline{9}} to remind myself
that the \texttt{9} should not be considered part of the max heap.)
In terms of an array the above diagram would correspond to this array:

\begin{python}
from latextool_basic import *
p = Plot()
a = Array2d(0, 0, width=0.6, height=0.6, 
             xs=[['6','8','4','7','3','2','1','0','9']])
p += a
p0 = a[0][7].bottomright(); p0 = (p0[0], p0[1] - 0.2)
p1 = a[0][7].topright(); p1 = (p1[0], p1[1] + 0.2)
p += Line(points=[p0, p1], linewidth=0.1)
p += Rect(x0=0, y0=-1, x1=2, y1=-1, s=r'\texttt{len = 8}', linewidth=0) 
print p
\end{python}

I still need to heapify-down the \texttt{6} to get this:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{8}',
B=r'label=\texttt{7}',
C=r'label=\texttt{4}',
D=r'label=\texttt{6}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{1}',
H=r'label=\texttt{0}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}


I repeat:
first I swap the root (i.e., \texttt{8}) and
the last value of the tree (i.e., \texttt{0}) to get this:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{0}',
B=r'label=\texttt{7}',
C=r'label=\texttt{4}',
D=r'label=\texttt{6}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{1}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
then I heapify-down \texttt{0} to get this:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{7}',
B=r'label=\texttt{6}',
C=r'label=\texttt{4}',
D=r'label=\texttt{0}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{1}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
This is the second extract-max.

I swap the root value (i.e., \texttt{7}) and the last value
of the tree (i.e., \texttt{1})
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{1}',
B=r'label=\texttt{6}',
C=r'label=\texttt{4}',
D=r'label=\texttt{0}',
E=r'label=\texttt{3}',
F=r'label=\texttt{2}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
and heapify at \texttt{1} to get this:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{6}',
B=r'label=\texttt{3}',
C=r'label=\texttt{4}',
D=r'label=\texttt{0}',
E=r'label=\texttt{1}',
F=r'label=\texttt{2}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}

I swap \texttt{6} and \texttt{2}:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{2}',
B=r'label=\texttt{3}',
C=r'label=\texttt{4}',
D=r'label=\texttt{0}',
E=r'label=\texttt{1}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
and heapify-down at \texttt{2} to get:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{4}',
B=r'label=\texttt{3}',
C=r'label=\texttt{2}',
D=r'label=\texttt{0}',
E=r'label=\texttt{1}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}

I swap \texttt{4} and \texttt{1}:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{1}',
B=r'label=\texttt{3}',
C=r'label=\texttt{2}',
D=r'label=\texttt{0}',
E=r'label=\texttt{\underline{4}}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
and heapify-down at \texttt{1} to get this:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{3}',
B=r'label=\texttt{1}',
C=r'label=\texttt{2}',
D=r'label=\texttt{0}',
E=r'label=\texttt{\underline{4}}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}

I swap \texttt{3} and \texttt{0}:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{0}',
B=r'label=\texttt{1}',
C=r'label=\texttt{2}',
D=r'label=\texttt{\underline{3}}',
E=r'label=\texttt{\underline{4}}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
heapify-down at \texttt{0}:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{2}',
B=r'label=\texttt{1}',
C=r'label=\texttt{0}',
D=r'label=\texttt{\underline{3}}',
E=r'label=\texttt{\underline{4}}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}

Swap \texttt{2} and \texttt{0}:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{0}',
B=r'label=\texttt{1}',
C=r'label=\texttt{\underline{2}}',
D=r'label=\texttt{\underline{3}}',
E=r'label=\texttt{\underline{4}}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
heapify-down at \texttt{0}:
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{1}',
B=r'label=\texttt{0}',
C=r'label=\texttt{\underline{2}}',
D=r'label=\texttt{\underline{3}}',
E=r'label=\texttt{\underline{4}}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}

I swap \texttt{1} and \texttt{0}
\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{0}',
B=r'label=\texttt{\underline{1}}',
C=r'label=\texttt{\underline{2}}',
D=r'label=\texttt{\underline{3}}',
E=r'label=\texttt{\underline{4}}',
F=r'label=\texttt{\underline{6}}',
G=r'label=\texttt{\underline{7}}',
H=r'label=\texttt{\underline{8}}',
I=r'label=\texttt{\underline{9}}',
) 
\end{python}
Clearly there's no need to heapify-down since the tree now has size 1.

As an array, we see that the tree is
\[
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
\]
Sorted!

Here's the algorithm:
\begin{console}
ALGORITHM: heapsort
INPUT: x - array
       n - length of x

Perform build_max_heap on x
for i = n - 1, n - 2, ..., 1: 
    swap x[0] and x[i]
    perform heapify_down on x with length i at index 0

swap x[0] and x[1]
\end{console}

\newpage
\begin{ex}
Here's an array:
\[
5, 7, 4, 0, 8
\]
Perform heapsort on the array.
(Execute build-max-heap and then continually perform
extract-max and heapify.
Draw the tree after every extract-max and heapify and draw the
corresponding array.)
\qed
\end{ex}

\newpage
\begin{ex}
Here's an array:
\[
1, 3, 5, 7, 6, 4, 2, 0, 8, 9.
\]
Perform heapsort on the array.
(Execute build-max-heap and then continually perform
extract-max and heapify.
Draw the tree after every extract-max and heapify and draw the
corresponding array.)
\qed
\end{ex}

\newpage
\begin{ex}
Here's an array:
\[
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
\]
Perform heapsort on the array.
(Execute build-max-heap and then continually perform
extract-max and heapify.
Draw the tree after every extract-max and heapify and draw the
corresponding array.)
\qed
\end{ex}

\newpage
\begin{ex}
Here's an array:
\[
9, 8, 7, 6, 5, 4, 3, 2, 1, 0
\]
Perform heapsort on the array to get a \textit{descending} array.
(Execute build-min-heap and then continually perform
extract-min and heapify.
Draw the tree after every extract-min and heapify and draw the
corresponding array.)
\qed
\end{ex}


\newpage
\begin{ex}
Here's an array:
\[
3, 9, 0, 7, 2, 5, 4, 1, 0
\]
Perform heapsort on the array.
(Execute build-max-heap and then continually perform
extract-max and heapify.
Draw the tree after every extract-max and heapify and draw the
corresponding array.)
\qed
\end{ex}


\newpage
\begin{ex}
An array $x$ of size $n$ represents a max heap.
What is the fastest way to find the minimum value in $x$?
\qed
\end{ex}
% The minimum must be a leave. Look at $n/2, ..., n - 1$.
% n-1 - n/2 + 1 = n - n / 2 accesses.




\newpage
\begin{ex}
Figure out a good algorithmn to merge two max heaps.
\qed
\end{ex}



\newpage
\subsection{Implementation}

\begin{ex}
Write a class \texttt{MaxHeap} that works like this:
\begin{console}
int x;
MaxHeap< int > heap;
x = heap.size();       // x = 0 
heap.insert(5);        // [5]
heap.insert(7);        // [7, 5]
heap.insert(9);        // [9, 5, 7]
x = heap.size();       // x = 3
std::cout << heap;     // Prints "[9, 5, 7]".

int a = heap.delete(); // [7, 5], deleting at index 0
                       // a = 9
x = heap.max();        // x = 9. The root is not deleted.

heap[0] = 1;           // [1, 5], heap is also like a
                       // std::vector.
heap.heapify_down(0);  // [5, 1]

heap[1] := 10;         // [5, 10]
heap.heapify_up(1);    // [10, 5]

heap.resize(5);
heap[0] = 5;
heap[1] = 7;
heap[2] = 8;
heap[3] = 10;
heap[4] = 2;
std::cout << heap;     // Prints "[5, 7, 8, 10, 2]".
heap.build();          // build-max-heap with 5 values
                       // already in the heap.
std::cout << heap;     // Prints "[10, 7, 8, 5, 2]".

heap.clear();          // []
\end{console}
\end{ex}
Clearly the following must work: copy constructor, destructor,
\verb!operator=!, \verb!operator==!.
The class should look like this:
\begin{console}
template < typename T >
class MaxHeap
{
public:
private:
    std::vector < T > x;
};
\end{console}



\newpage
\begin{ex}
  It's common to implement a heap by using arrays and implement the
  ADT using functions instead of using a class with methods.
  For instance this would be allow one to implement heapsort easily
  to sort an array directly.
  Implement the heap ADT described below where an a vector is used
  to represent the heap.
\begin{console}
int x;
std::vector< int > heap;

maxheap_insert(heap, 5);   // [5]
maxheap_insert(heap, 7);   // [7, 5]
maxheap_insert(heap, 9);   // [9, 5, 7]

int a = maxheap_delete(heap); // [7, 5]
                           // a = 9
x = maxheap_max(heap);     // x = 9. Root is not deleted.

heap[0] = 1;               // [1, 5]
maxheap_heapify_down(heap, 0); // [5, 1]

heap[1] = 10;              // [5, 10]
maxheap_heapify_up(heap, 1); // [10, 5]

heap.resize(5);
heap[0] = 5;
heap[1] = 7;
heap[2] = 8;
heap[3] = 10;
heap[4] = 2;
maxheap_build(heap);       // [10, 7, 8, 5, 2]

heap.resize(5);
heap[0] = 2;
heap[1] = 6;
heap[2] = 8;
heap[3] = 10;
heap[4] = 5;
maxheap_heapsort(heap)     // [2, 5, 6, 8, 10]
\end{console}
The functions above should be function templates.
\qed
\end{ex}




\newpage
\section{Priority queues}

Recall a queue is a data structure that supports
enqueue and dequeue.
Think of people lining up at a ticket booth.
A \defterm{priority queue} is queue where people join a queue \textit{but}
they have priority numbers.
Say, a higher number means higher priority.
Obviously, you can implement such a priority queue
using a max heap.
The runtimes are then as follows:
\begin{tightlist}
  \item enqueue: $O(\log n)$
  \item dequeue: $O(\log n)$
\end{tightlist}


In this case, both inserts and deletes have runtime of $O(\log n)$.
This is obviously better than say using a deque where you have to 
move a node forward one-step-at-a-time in the deque based on the priority.
If you use a deque to implement
a priority queue, then in the worse case, where value enters the
priority queue with highest priority, this value will enter the
end of the deque and move one step at a time all the way to the front.
So using a deque to implement a priority would mean that you have a
worse runtime of $O(n)$!


Sometimes, one needs to change the priority of a job.
Here's an example ...

Linux allows user to display running processes using the
\verb!ps! command:
priority of processes.
The following is a list of processes that I'm running:
{\scriptsize
\begin{console}
[student@localhost n]$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000  3148 26588  0  80   0 -  8250 poll_s pts/0    00:07:46 xemacs
0 R  1000  7239 26588  0  80   0 -  1253 -      pts/0    00:00:00 ps
0 S  1000 26588 20828  0  80   0 -  1574 wait   pts/0    00:00:01 bash
0 S  1000 28473     1  1  80   0 - 75939 poll_s pts/0    00:00:34 atril
\end{console}
}
The priority is under the column labeled \texttt{NI}.
Notice that \texttt{xemacs} is running with priority \texttt{0}.
I can change the priority of my \texttt{xemacs} to this:
{\scriptsize
\begin{console}
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000  3148 26588  0  81   1 -  8250 poll_s pts/0    00:07:47 xemacs
0 R  1000  8093 26588  0  80   0 -  1253 -      pts/0    00:00:00 ps
0 S  1000 26588 20828  0  80   0 -  1574 wait   pts/0    00:00:01 bash
0 S  1000 28473     1  1  80   0 - 76240 poll_s pts/0    00:00:35 atril
\end{console}
}
In Linux a higher priority means lower priority number.
So a min heap is more relevant.
But I'll stick to max heap since if you understood max heap, then
min heap is easy.

So suppose I already have a priority queue (as a heap):

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{10}',
B=r'label=\texttt{9}',
C=r'label=\texttt{8}',
D=r'label=\texttt{5}',
E=r'label=\texttt{3}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{1}',
) 
\end{python}

Suppose \texttt{1} is increased to \texttt{12}:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{10}',
B=r'label=\texttt{9}',
C=r'label=\texttt{8}',
D=r'label=\texttt{5}',
E=r'label=\texttt{3}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{12}',
) 
\end{python}

I'm sure you can see very quickly that in order to make this back to
a max heap, I need to heapify-up \texttt{12}.
In this case I need to swap 3 times to get this:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{12}',
B=r'label=\texttt{10}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{3}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{5}',
) 
\end{python}

\begin{console}
ALGORITHM: increase_key (for max heap)
INPUT: x - heap (using an array)
       n - length of heap in x
       i - index where key will increase
       k - new key value (k > x[i])

x[i] = k
Perform heapify-up on x starting at index i.
\end{console}
So is the above represent processes with priorities, the low priority
process moves up, in fact to the top, so it will be the next process to
be executed.
The worse runtime of increase-key for max heap is
\[
O(\log n)
\]

Using the above, suppose \texttt{10} is decreased to \texttt{1}:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{12}',
B=r'label=\texttt{1}',
C=r'label=\texttt{8}',
D=r'label=\texttt{9}',
E=r'label=\texttt{3}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{5}',
) 
\end{python}

Of course this is not a max heap anymore.
To make this back to a max heap, clearly the simplest thing to do is
to heapify-down.
In this case I need two swaps to get this:

\begin{python}
from latextool_basic import *
print r"""
\begin{center}
%s
\end{center}
""" % graph(yscale=1, xscale=1,
layout="""
    A 
  B   C 
 D E F G
H I
""",
minimum_size='8mm',
edges='A-B,A-C,B-D,B-E,C-G,C-F,D-H,D-I',
A=r'label=\texttt{12}',
B=r'label=\texttt{9}',
C=r'label=\texttt{8}',
D=r'label=\texttt{5}',
E=r'label=\texttt{3}',
F=r'label=\texttt{0}',
G=r'label=\texttt{7}',
H=r'label=\texttt{2}',
I=r'label=\texttt{1}',
) 
\end{python}


Here's decrease key:

\begin{console}
ALGORITHM: decrease_key (for max heap)
INPUT: x - heap (using an array)
       n - length of heap in x
       i - index where key will increase
       k - new key value (k < x[i])

x[i] = k
Perform heapify_down on x at starting at index i.
\end{console}
The worse runtime of decrease-key for max heap is clearly
\[
O(\log n)
\]


\newpage
\begin{ex}
Let $x$ be the array
\[
4, 9, 2, 6, 3, 8, 0, 1, 5, 7
\]
First heapify it.
Next do the following:
\begin{tightlist}
  \item Perform increase-key from on the key with value \texttt{2}
  and change it to \texttt{11}.
  \item Perform decrease-key from on the key with value
  \texttt{7} and change it to \texttt{-1}.
\end{tightlist}
\qed
\end{ex}



\newpage
\begin{ex}
Continuing the implementation of the heap ADT using functions,
implement the increase-key and decrease-key
functions:
\begin{console}
int x;
std::vector< int > heap;

heap.resize(5);
heap[0] = 5;
heap[1] = 7;
heap[2] = 8;
heap[3] = 10;
heap[4] = 2;
maxheap_build(heap);      // [10, 7, 8, 5, 2]

maxheap_increasekey(heap, 2, 12); // heap[2] is changed
                          // to 12. heap has to be
                          // reorganized to become
                          // maxheap again.
                          
maxheap_decreasekey(heap, 2, 0); // heap[2] is changed
                          // to 0. heap has to be
                          // reorganized to become
                          // maxheap again.
\end{console}
\end{ex}

\begin{comment}
\subsection{API}

Here are some very common operations:

\begin{console}
create_heap      create an empty heap
heapify          create a heap from a collection of data
                 (usually an array)
find_max         find max value for a max heap
find_min         find min value for a min heap
delete_max       delete max value in a max heap
delete_min       delete min value in a min heap
increase_key     increase value of a node
decrease_key     decrease value of a node
insert           insert a value into a heap
merge            merge two heaps
\end{console}

\subsection{Implementation}

Frequently heaps are implemented using arrays, i.e., they are array trees.
\end{comment}


\newpage
\begin{ex}
  Johnny is writing
  a scheduler for his game
  and wanted to use a balanced binary search tree (AVL)
  to handle jobs with priority
  (collision computation, collisiion resolution, shadow computation,
  drawing, sound, etc.) with
  instead of heaps.
  What are the advantages and disadvantages?
  Compare and contrast.
  \qed
\end{ex}

\newpage
\begin{ex}
  Analyze and implement a FIFOMinHeap.
  This is a minheap that is FIFO on values with the
  same priority.
  In other words, if two values
  of the same priority
  are inserted into a minheap,
  then value inserted earlier will be
  removed before the other value.
  (There are at least two different ways of doing
  the above.)
\end{ex}

\begin{comment}
There are 2 ways of doing the above.

Method 1:
For object $x$, instead of using $x.priority$,
use $(priority, time)$ where the minheap maintains
a time that is incremented every time
an insert occurs. The ordering of $(priority, time)$
is dictionary.
For the case of maxheap, decrement the time counter.

Disadvantage: If the heap runs for a very long time,
the time might overflow.

Method 2:
The heap is made up of linked list of values.
Each linked list contains values of the same priority.
When a value $x$ is inserted, if $x.priority$ occurs in
the minheap, insert $x$ into the correct linked list.
If x's priority is new, create a new linked list and
insert into heap.
Note that we need to know if a linked list of the
correct priority exists in the heap.
We can have a hash table of (priority, heap index).
During heap operations (heapify-up and -down), the
hash table must be updated during the swaps.
If the root linked list is empty, it is removed from the heap.
If the heap allows priority modification, then
a non-root linked list can become empty -- this should not be
delete.
Therefore during the extract-root operation,
need to loop over the extract-root operation until
the new root is a non-empty linked list.
\end{comment}
