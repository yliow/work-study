\section{Regular Expressions}

\begin{comment}
\textbf{Objectives}
\begin{tightlist}
\item Verify if an expression is an regular expression
\item Describe informal the language generated by a regex
\item Given an informal description of a regular language,
  write down the corresponding regex
\item Translate between a regex and a state diagram
\item Translate between a regex and a DFA
\item Translate between a regex and an NFA
\end{tightlist}
\mbox{}
\end{comment}

Note that both DFA and NFA description of a finite state automata
uses sets and functions.

Let
\[
L = \{ a b^n \st n \geq 0 \}
\]
This is a regular language, i.e., it is accepted by a DFA.
Describing a language by specifying a DFA is tedious
(whether using the formal method or by using a DFA diagram.)
A \textbf{regular expression} is a concise \textbf{textual} description
of a regular language. For the above example the regex is
\[
ab^*
\]

You will see later that regular expressions are equal in power to
DFA and NFA. 
Historically, regex actually appears first: 
Regex was first studied as a mathematical tool for describing
how our brain thinks.

Application: This is the method used in most software
systems. In particular, regular expressions are absolutely crucial
to web application where there are lots of check for validity of
input strings.

First let me define what regular expressions are:

\begin{defn} Let $\Sigma$ be a finite set. A \defone{regular
expression} (regex) over $\Sigma$ is a string 
made up of characters from $\Sigma$ and the symbols $\emptyset$, 
${}^*$, $\cup$, $($, and $)$.
It is defined 
recursively as follows:
\begin{axioms}
\item[(RE1)] $\emptyset$ is a regular expression
\item[(RE2)] $\ep$ is a regular expression
\item[(RE3)] $c$ is a regular expression for every $c \in \Sigma$
\item[(RE4)] If $r$ is a regular expression, then so is $r^*$
\item[(RE5)] If $r$,$r'$ are regular expressions, then so is $r
  \cup r'$
\item[(RE6)] If $r$,$r'$ are regular expressions, then so is $rr'$
  (Sometimes $rr'$ is written $r \cdot r'$ where $\cdot$
  should be treated as a symbol.)
\item[(RE7)] If $r$ is a regular expression, then so is
$(r)$.
\end{axioms}
\end{defn}

You should think of the regex as a string. So the $\cup$ is just a
special character; later we'll see that this character corresponds
to set union when we compute the language corresponding to a regex.
Likewise $a \in \Sigma$ is a regex should be thought of
as a character in a regex. In fact some authors will use a
different symbol to denote $\emptyset$, $a$ (of $\Sigma$), $\cup$,
${}^*$, $\cdot$ in describing a regex.

\begin{eg}
Let $\Sigma = \{a,b\}$. The $aa^* \cup ba^*b$ is a regular
expression since: 
\begin{tightlist}
 \item $a$ is a regex by (RE3)
 \item $a^*$ is a regex by (RE4)
 \item $aa^*$ is a regex by  
 \item $b$ is a regex by 
 \item $ba^*$ is a regex by
 \item $ba^*b$ is a regex by 
 \item $aa^* \cup ba^*b$ is a regex by
\end{tightlist}
Make sure you know which rule is used.
\qed
\end{eg}

\newpage
\begin{ex}
  Let $\Sigma = \{0,1\}$. Show that the following are regular expressions.
  \begin{tightlist}
    \item $0 1 \cup (1 0 \cup 1 1)$
    \item $1^* \cup (\cup (1 0 \cup 1 1)$
  \end{tightlist}
  \qed
\end{ex}


\newpage
\begin{ex} Which of the following are not regex over $\{a, b\}$?
\begin{tightlist}
\item $\emptyset \emptyset$
\item $\emptyset^*$
\item ${}^*\emptyset$
\item $a^* \cap b$
\item $a^* bc$
\item $a \cup cup a$  
\item $P(a \cup b)$
\end{tightlist}
\qed
\end{ex}


\newpage
For those authors who prefer to invent new symbols to use in a
regex, they usually use bold. For instance instead of writing the
regex $aa^* \cup ba^*b$, they would write $\mathbf{ aa^* \cup
ba^*b}$. (Sorry, I can't bold the union and Kleene star).


The above defines regex.
It doesn't tell you anything about languages.
The following relates a regex to its language:

\begin{defn}
 Let $r$ be a regex defined over $\Sigma$. 
 $L(r)$, the language generated by $r$, is defined recursively as follows:
 \begin{tightlist}
  \item $L(\emptyset) = \emptyset$
  \item $L(a) = \{a\}$ for $a \in \Sigma$
  \item $L(r^*) = (L(r))^*$ for $a \in \Sigma$. (The ${}^*$ on the left
        is a symbol used in a regex while the ${}^*$ on the right is the 
        Kleene star operator on languages.)
  \item $L(r \cup r') = L(r) \cup L(r')$. (The $\cup$ on the right is
        set union.)
  \item $L(rr') = L(r)L(r')$
  \item $L((r)) = L(r)$
 \end{tightlist}
\end{defn}

\begin{eg}
  \mbox{}
  \begin{tightlist}
  \item $L((a \cup b)^*) = L(a \cup b)^* = (L(a) \cup L(b))^* = (\{a\} \cup
    \{b\})^* = \{a,b\}^*$
  \item $L(\emptyset 0) = L(\emptyset) L(0) = \emptyset  \{0\} = \{\}$
  \item $L( 0^* \cup (0^*10^*10^*10^*)^*)$ is the language of strings
    where the number of 1's is divisible by 3.
  \end{tightlist}
  \qed
\end{eg}


With parentheses, we can have very complex regex.
But just like in arithmetic expressions where we do not write to
write $((1 + 2) + 3) + 4)$ but use conventions to write $1 + 2 + 3 + 4$,
we have operator precedence for regular expressions.
The convention is 
\begin{tightlist}
\li ${}*$ is highest
\li $\cdot $ is next
\li $\cup$ is the lowest
\end{tightlist}
So for instance the regular expression $a\cdot b \cup a\cdot b^*$ 
is really the same as
\[
a\cdot b \cup a\cdot b^*
=
(a\cdot b) \cup (a\cdot (b^*))
\]
This is important when it comes to computing the language recognized by 
the regular expression since it tells you how to break down the regular 
expression:
\begin{align*}
L(a\cdot b \cup a\cdot b^*)
&= L((a\cdot b) \cup (a\cdot (b^*))) \\
&= L(a\cdot b) \cup L(a\cdot (b^*)) \\
&= L(a\cdot b) \cup (L(a) \cdot L(b^*)) \\
&= ... &
\end{align*}



\begin{ex}
What is the language generated by the regex $aa^* \cup ba^*b$?
Write down all words of length $\leq 5$ of this language.
\qed
\end{ex}

\textbf{Solution.}
\begin{align*}
 L(aa^* \cup ba^*b)
  &= L(aa^*) \cup L(ba^*b) \cr
  &= L(a)L(a^*) \cup L(b)L(a^*)L(b) \cr
  &= \{a\}L(a)^* \cup \{b\}L(a)^*\{b\} \cr
  &= \{a\}\{a\}^* \cup \{b\}\{a\}^*\{b\} \cr
  &= \{ a^n \,|\, n \geq 1 \} \cup \{ ba^nb \,|\, n \geq 0 \}
 \end{align*}

It's a good idea for the above and all the following exercises to 
write down the corresponding DFA and NFA for comparison.


\newpage
\begin{ex}
Write down the regex $r$ for the language over $\{a, b\}$ 
such that $L(r) = \{\}$.
\qed
\end{ex}


\newpage
\begin{ex}
Write down the regex $r$ for the language over $\{a, b\}$ 
such that $L(r) = \{a\}$.
\qed
\end{ex}


\newpage
\begin{ex}
Write down the regex $r$ for the language over $\{a, b\}$ 
such that $L(r) = \{a, b\}$.
\qed
\end{ex}

\newpage
\begin{ex}
Write down the regex $r$ for the language over $\{a, b\}$ 
such that $L(r) = \{ab, ba\}$.
\qed
\end{ex}

\newpage
\begin{ex}
Write down the regex $r$ for the language $L$ over $\Sigma = \{a, b\}$ 
such that 
\[
L(r) = \{w \in \Sigma^* \mid w \text{ contains $a^3$} \}
\]
\qed
\end{ex}

\newpage
\begin{ex}
Write down the regex $R$ for the language $L$ over $\Sigma = \{a, b\}$ 
such that 
\[
L = \{w \in \Sigma^* \mid w \text{ contains exactly 3 $a$'s} \}
\]
\qed
\end{ex}


\newpage
\begin{ex}
Write down the regex $R$ for the language $L$ over $\Sigma = \{a, b\}$ 
such that 
\[
L = \{w \in \Sigma^* \mid |w| \equiv 1 \pmod{3} \}
\]
\qed
\end{ex}


\newpage
\begin{ex}
 Write down the regex for the language over $\{a,b\}$ containing strings
  which has either exact 3 a's or the substring $aba$.
\qed
\end{ex}



\newpage
Here's the relationship between regex, DFA, and NFA:

\begin{thm}
  \begin{enumerate}[label=\textnormal{(\alph*)},itemsep=0pt,nosep,noitemsep,partopsep=0pt,topsep=0pt,parsep=0pt]
    \mbox{}
  \item If $R$ is a regex, then $L(R)$ is a regular
    language
  \item If $L$ is a regular language, then there is a regex $R$
    such that $L(R) = L$.
  \end{enumerate}
\end{thm}

In the next few sections, I'll show you how to convert between
regex and NFA, i.e., given a regex $r$, how to find an NFA
such that 
\[
L(N) = L(r)
\]
and also given an NFA $N$, how to construct a regex $r$ such that
\[
L(r) = L(N)
\]

Theoretically, the class of languages recognized by regex is
exactly the same as the class of regular languages. 
This means that DFA, NFA, and regexes are \lq\lq equal in power''.

In terms of actual computation, 
the above tells you how to convert a regex to a DFA for computation.
For instance regexes are used in compilers to recognize
lexemes and tokens.
Compiler tools usually accept regexes.
The actual computational processes
that recognizes the lexemes
can be done through the corresponding 
DFAs.

Now just imagine you're writing a computer program using a high
level programming language. Suppose the there is a function
provided for you to check if a string is in a regular language.
Obviously you have to specify your regular language. Clearly
finite sets are easy: just specify everything in the set. But
there are regular languages which are infinite. You now know that
regular languages can be described using (1) a DFA, (2) an NFA, or
(3) regex.

Regex is the simplest.

Here is an example of using the regex provided by the programming
language Python. The regex in Python allows you to verify if a
string matches a regex. (There are actually three modes of
matchings). Clearly you can't find a key on your keyboard for
$\cup$: In most programming languages or packages with regex
facilities, the $|$ is used in place of $\cup$. The search
function in the re module accepted a regex and a string.

\begin{eg} Suppose you want match strings adef or bdef. You can do
the following in Python:
\begin{console}
>>> import re
>>> regex = re.compile("(a|b)def")
>>> print regex.match("adef")
<$\_$sre.SRE$\_$Match object at 0x00E1F0C8>
>>> print regex.match("bdef")
<$\_$sre.SRE$\_$Match object at 0x00E1F170>
>>> print regex.match("abcd")
None
>>>
\end{console}
The \texttt{a|b} as a Python regular expression
means $a \cup b$ as a mathemtical regular expression.
\end{eg}

For a fix $\Sigma$, you have a collection of regex over $\Sigma$.
You can think of $\cup$ and $\cdot$ are operators.
Just like there are algebraic rules for real numbers,
there are algebraic rules for regular expressions.
Knowing these rules will help you simplify regulars and check quickly
if two regular expressions are the same, i.e., they
generated the same language.
\begin{tightlist}
\item $r (r'r'') = (rr')r''$
\item $r \emptyset = \emptyset = \emptyset r$
\item $\ep r = r = \ep r$
\item $r \cup r' = r' \cup r$
\item $r \cup r = r$
\item $r \cup \emptyset = r = \emptyset \cup r$
\item $r \cup \Sigma^* = \Sigma^* = \Sigma^* \cup r$
\item $r (r' \cup r'') = rr' \cup rr''$
\item $(r' \cup r'')r = r'r \cup r''r$
\item $r^{**} = r^*$
\item $\ep^* = \ep$
\item $\ep \cup rr^* = r^*$
\item $\ep \cup r \cup r^2r^* = r^*$
\item $\ep \cup r \cup r^2 \cup r^3r^* = r^*$
\item $\ep \cup r \cup r^2 \cup \cdots \cup r^n \cup r^{n+1}r^* = r^*$
\item $rr^* = r^*r$
\end{tightlist}
\mbox{}

Let's prove that $a(a^* \cup \emptyset) \cup \ep  = a^*$.
\[
(a^* \cup \emptyset)a \cup \ep 
= a^*a \cup \ep = aa^* \cup \ep = a^*
\]
To make life simpler for programmers, the regex in Python has
extra characters or strings to simplify programming.
\begin{itemize}
 \item $[abcdef]$ is the same as $a|b|c|d|e|f$.
 \item $[0-9]$ is the same as $0|1|2|3|4|5|6|7|8|9$
 \item $[a-z]$ will match any ASCII character from 'a' to 'z'
 \item $[a-z]\{3-5\}$ will accept 3 or 4 or 5 ASCII characters from 'a' to 'z'.
\end{itemize}
This list is incomplete. For more information, use google to check
regular expressions for UNIX.

Regex is used not just in work related to compilers. Regex is also
used to verify for instance if a user's input is valid. In fact
regex is a cornerstone in web programming.
